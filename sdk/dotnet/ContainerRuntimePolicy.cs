// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Pulumiverse.Aquasec
{
    [AquasecResourceType("aquasec:index/containerRuntimePolicy:ContainerRuntimePolicy")]
    public partial class ContainerRuntimePolicy : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Allowed executables configuration.
        /// </summary>
        [Output("allowedExecutables")]
        public Output<ImmutableArray<Outputs.ContainerRuntimePolicyAllowedExecutable>> AllowedExecutables { get; private set; } = null!;

        /// <summary>
        /// List of allowed registries.
        /// </summary>
        [Output("allowedRegistries")]
        public Output<ImmutableArray<Outputs.ContainerRuntimePolicyAllowedRegistry>> AllowedRegistries { get; private set; } = null!;

        /// <summary>
        /// Indicates the application scope of the service.
        /// </summary>
        [Output("applicationScopes")]
        public Output<ImmutableArray<string>> ApplicationScopes { get; private set; } = null!;

        /// <summary>
        /// If true, all network activity will be audited.
        /// </summary>
        [Output("auditAllNetworkActivity")]
        public Output<bool?> AuditAllNetworkActivity { get; private set; } = null!;

        /// <summary>
        /// If true, all process activity will be audited.
        /// </summary>
        [Output("auditAllProcessesActivity")]
        public Output<bool?> AuditAllProcessesActivity { get; private set; } = null!;

        /// <summary>
        /// Detects brute force login attempts
        /// </summary>
        [Output("auditBruteForceLogin")]
        public Output<bool?> AuditBruteForceLogin { get; private set; } = null!;

        /// <summary>
        /// If true, full command arguments will be audited.
        /// </summary>
        [Output("auditFullCommandArguments")]
        public Output<bool?> AuditFullCommandArguments { get; private set; } = null!;

        [Output("auditing")]
        public Output<Outputs.ContainerRuntimePolicyAuditing> Auditing { get; private set; } = null!;

        /// <summary>
        /// Username of the account that created the service.
        /// </summary>
        [Output("author")]
        public Output<string> Author { get; private set; } = null!;

        [Output("blacklistedOsUsers")]
        public Output<Outputs.ContainerRuntimePolicyBlacklistedOsUsers> BlacklistedOsUsers { get; private set; } = null!;

        /// <summary>
        /// If true, prevent containers from running with access to host network.
        /// </summary>
        [Output("blockAccessHostNetwork")]
        public Output<bool?> BlockAccessHostNetwork { get; private set; } = null!;

        /// <summary>
        /// If true, prevent containers from running with adding capabilities with `--cap-add` privilege.
        /// </summary>
        [Output("blockAddingCapabilities")]
        public Output<bool?> BlockAddingCapabilities { get; private set; } = null!;

        /// <summary>
        /// If true, exec into a container is prevented.
        /// </summary>
        [Output("blockContainerExec")]
        public Output<bool?> BlockContainerExec { get; private set; } = null!;

        /// <summary>
        /// Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
        /// </summary>
        [Output("blockCryptocurrencyMining")]
        public Output<bool?> BlockCryptocurrencyMining { get; private set; } = null!;

        [Output("blockDisallowedImages")]
        public Output<bool?> BlockDisallowedImages { get; private set; } = null!;

        /// <summary>
        /// Detect and prevent running in-memory execution
        /// </summary>
        [Output("blockFilelessExec")]
        public Output<bool?> BlockFilelessExec { get; private set; } = null!;

        /// <summary>
        /// If true, prevent containers from running with the capability to bind in port lower than 1024.
        /// </summary>
        [Output("blockLowPortBinding")]
        public Output<bool?> BlockLowPortBinding { get; private set; } = null!;

        /// <summary>
        /// If true, running containers in non-compliant pods is prevented.
        /// </summary>
        [Output("blockNonCompliantWorkloads")]
        public Output<bool?> BlockNonCompliantWorkloads { get; private set; } = null!;

        /// <summary>
        /// If true, running non-kubernetes containers is prevented.
        /// </summary>
        [Output("blockNonK8sContainers")]
        public Output<bool?> BlockNonK8sContainers { get; private set; } = null!;

        /// <summary>
        /// If true, prevent containers from running with privileged container capability.
        /// </summary>
        [Output("blockPrivilegedContainers")]
        public Output<bool?> BlockPrivilegedContainers { get; private set; } = null!;

        /// <summary>
        /// If true, prevent containers from running with root user.
        /// </summary>
        [Output("blockRootUser")]
        public Output<bool?> BlockRootUser { get; private set; } = null!;

        /// <summary>
        /// If true, prevent containers from running with the privilege to use the IPC namespace.
        /// </summary>
        [Output("blockUseIpcNamespace")]
        public Output<bool?> BlockUseIpcNamespace { get; private set; } = null!;

        /// <summary>
        /// If true, prevent containers from running with the privilege to use the PID namespace.
        /// </summary>
        [Output("blockUsePidNamespace")]
        public Output<bool?> BlockUsePidNamespace { get; private set; } = null!;

        /// <summary>
        /// If true, prevent containers from running with the privilege to use the user namespace.
        /// </summary>
        [Output("blockUseUserNamespace")]
        public Output<bool?> BlockUseUserNamespace { get; private set; } = null!;

        /// <summary>
        /// If true, prevent containers from running with the privilege to use the UTS namespace.
        /// </summary>
        [Output("blockUseUtsNamespace")]
        public Output<bool?> BlockUseUtsNamespace { get; private set; } = null!;

        /// <summary>
        /// If true, prevents containers from using specific Unix capabilities.
        /// </summary>
        [Output("blockedCapabilities")]
        public Output<ImmutableArray<string>> BlockedCapabilities { get; private set; } = null!;

        /// <summary>
        /// List of executables that are prevented from running in containers.
        /// </summary>
        [Output("blockedExecutables")]
        public Output<ImmutableArray<string>> BlockedExecutables { get; private set; } = null!;

        /// <summary>
        /// List of files that are prevented from being read, modified and executed in the containers.
        /// </summary>
        [Output("blockedFiles")]
        public Output<ImmutableArray<string>> BlockedFiles { get; private set; } = null!;

        /// <summary>
        /// List of blocked inbound ports.
        /// </summary>
        [Output("blockedInboundPorts")]
        public Output<ImmutableArray<string>> BlockedInboundPorts { get; private set; } = null!;

        /// <summary>
        /// List of blocked outbound ports.
        /// </summary>
        [Output("blockedOutboundPorts")]
        public Output<ImmutableArray<string>> BlockedOutboundPorts { get; private set; } = null!;

        /// <summary>
        /// Prevent containers from reading, writing, or executing all files in the list of packages.
        /// </summary>
        [Output("blockedPackages")]
        public Output<ImmutableArray<string>> BlockedPackages { get; private set; } = null!;

        /// <summary>
        /// List of volumes that are prevented from being mounted in the containers.
        /// </summary>
        [Output("blockedVolumes")]
        public Output<ImmutableArray<string>> BlockedVolumes { get; private set; } = null!;

        /// <summary>
        /// Bypass scope configuration.
        /// </summary>
        [Output("bypassScopes")]
        public Output<ImmutableArray<Outputs.ContainerRuntimePolicyBypassScope>> BypassScopes { get; private set; } = null!;

        [Output("containerExec")]
        public Output<Outputs.ContainerRuntimePolicyContainerExec> ContainerExec { get; private set; } = null!;

        /// <summary>
        /// List of processes that will be allowed.
        /// </summary>
        [Output("containerExecAllowedProcesses")]
        public Output<ImmutableArray<string>> ContainerExecAllowedProcesses { get; private set; } = null!;

        [Output("created")]
        public Output<string> Created { get; private set; } = null!;

        [Output("cve")]
        public Output<string?> Cve { get; private set; } = null!;

        [Output("defaultSecurityProfile")]
        public Output<string?> DefaultSecurityProfile { get; private set; } = null!;

        /// <summary>
        /// The description of the container runtime policy
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        [Output("digest")]
        public Output<string?> Digest { get; private set; } = null!;

        /// <summary>
        /// Drift prevention configuration.
        /// </summary>
        [Output("driftPreventions")]
        public Output<ImmutableArray<Outputs.ContainerRuntimePolicyDriftPrevention>> DriftPreventions { get; private set; } = null!;

        [Output("enableCryptoMiningDns")]
        public Output<bool?> EnableCryptoMiningDns { get; private set; } = null!;

        /// <summary>
        /// If true, fork bombs are prevented in the containers.
        /// </summary>
        [Output("enableForkGuard")]
        public Output<bool?> EnableForkGuard { get; private set; } = null!;

        [Output("enableIpReputation")]
        public Output<bool?> EnableIpReputation { get; private set; } = null!;

        [Output("enablePortScanProtection")]
        public Output<bool?> EnablePortScanProtection { get; private set; } = null!;

        /// <summary>
        /// Whether allowed executables configuration is enabled.
        /// </summary>
        [Output("enabled")]
        public Output<bool?> Enabled { get; private set; } = null!;

        /// <summary>
        /// Indicates that policy should effect container execution (not just for audit).
        /// </summary>
        [Output("enforce")]
        public Output<bool?> Enforce { get; private set; } = null!;

        /// <summary>
        /// Indicates the number of days after which the runtime policy will be changed to enforce mode.
        /// </summary>
        [Output("enforceAfterDays")]
        public Output<int?> EnforceAfterDays { get; private set; } = null!;

        [Output("enforceSchedulerAddedOn")]
        public Output<int> EnforceSchedulerAddedOn { get; private set; } = null!;

        /// <summary>
        /// List of excluded application scopes.
        /// </summary>
        [Output("excludeApplicationScopes")]
        public Output<ImmutableArray<string>> ExcludeApplicationScopes { get; private set; } = null!;

        /// <summary>
        /// Executable blacklist configuration.
        /// </summary>
        [Output("executableBlacklists")]
        public Output<ImmutableArray<Outputs.ContainerRuntimePolicyExecutableBlacklist>> ExecutableBlacklists { get; private set; } = null!;

        [Output("failedKubernetesChecks")]
        public Output<Outputs.ContainerRuntimePolicyFailedKubernetesChecks> FailedKubernetesChecks { get; private set; } = null!;

        [Output("fileBlock")]
        public Output<Outputs.ContainerRuntimePolicyFileBlock> FileBlock { get; private set; } = null!;

        /// <summary>
        /// Configuration for file integrity monitoring.
        /// </summary>
        [Output("fileIntegrityMonitoring")]
        public Output<Outputs.ContainerRuntimePolicyFileIntegrityMonitoring> FileIntegrityMonitoring { get; private set; } = null!;

        /// <summary>
        /// Process limit for the fork guard.
        /// </summary>
        [Output("forkGuardProcessLimit")]
        public Output<int?> ForkGuardProcessLimit { get; private set; } = null!;

        [Output("imageName")]
        public Output<string?> ImageName { get; private set; } = null!;

        [Output("isAuditChecked")]
        public Output<bool?> IsAuditChecked { get; private set; } = null!;

        [Output("isAutoGenerated")]
        public Output<bool?> IsAutoGenerated { get; private set; } = null!;

        [Output("isOotbPolicy")]
        public Output<bool?> IsOotbPolicy { get; private set; } = null!;

        [Output("lastupdate")]
        public Output<int> Lastupdate { get; private set; } = null!;

        /// <summary>
        /// Container privileges configuration.
        /// </summary>
        [Output("limitContainerPrivileges")]
        public Output<ImmutableArray<Outputs.ContainerRuntimePolicyLimitContainerPrivilege>> LimitContainerPrivileges { get; private set; } = null!;

        /// <summary>
        /// If true, prevents the container from obtaining new privileges at runtime. (only enabled in enforce mode)
        /// </summary>
        [Output("limitNewPrivileges")]
        public Output<bool?> LimitNewPrivileges { get; private set; } = null!;

        [Output("linuxCapabilities")]
        public Output<Outputs.ContainerRuntimePolicyLinuxCapabilities> LinuxCapabilities { get; private set; } = null!;

        /// <summary>
        /// Configuration for Real-Time Malware Protection.
        /// </summary>
        [Output("malwareScanOptions")]
        public Output<Outputs.ContainerRuntimePolicyMalwareScanOptions> MalwareScanOptions { get; private set; } = null!;

        /// <summary>
        /// If true, system time changes will be monitored.
        /// </summary>
        [Output("monitorSystemTimeChanges")]
        public Output<bool?> MonitorSystemTimeChanges { get; private set; } = null!;

        /// <summary>
        /// Name assigned to the attribute.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        [Output("noNewPrivileges")]
        public Output<bool?> NoNewPrivileges { get; private set; } = null!;

        [Output("onlyRegisteredImages")]
        public Output<bool?> OnlyRegisteredImages { get; private set; } = null!;

        [Output("packageBlock")]
        public Output<Outputs.ContainerRuntimePolicyPackageBlock> PackageBlock { get; private set; } = null!;

        [Output("permission")]
        public Output<string?> Permission { get; private set; } = null!;

        [Output("portBlock")]
        public Output<Outputs.ContainerRuntimePolicyPortBlock> PortBlock { get; private set; } = null!;

        [Output("readonlyFiles")]
        public Output<Outputs.ContainerRuntimePolicyReadonlyFiles> ReadonlyFiles { get; private set; } = null!;

        [Output("readonlyRegistry")]
        public Output<Outputs.ContainerRuntimePolicyReadonlyRegistry> ReadonlyRegistry { get; private set; } = null!;

        [Output("registry")]
        public Output<string?> Registry { get; private set; } = null!;

        [Output("registryAccessMonitoring")]
        public Output<Outputs.ContainerRuntimePolicyRegistryAccessMonitoring> RegistryAccessMonitoring { get; private set; } = null!;

        [Output("repoName")]
        public Output<string?> RepoName { get; private set; } = null!;

        [Output("resourceName")]
        public Output<string?> ResourceName { get; private set; } = null!;

        [Output("resourceType")]
        public Output<string?> ResourceType { get; private set; } = null!;

        /// <summary>
        /// Restricted volumes configuration.
        /// </summary>
        [Output("restrictedVolumes")]
        public Output<ImmutableArray<Outputs.ContainerRuntimePolicyRestrictedVolume>> RestrictedVolumes { get; private set; } = null!;

        [Output("reverseShell")]
        public Output<Outputs.ContainerRuntimePolicyReverseShell> ReverseShell { get; private set; } = null!;

        [Output("runtimeMode")]
        public Output<int?> RuntimeMode { get; private set; } = null!;

        [Output("runtimeType")]
        public Output<string?> RuntimeType { get; private set; } = null!;

        /// <summary>
        /// Logical expression of how to compute the dependency of the scope variables.
        /// </summary>
        [Output("scopeExpression")]
        public Output<string> ScopeExpression { get; private set; } = null!;

        /// <summary>
        /// List of scope attributes.
        /// </summary>
        [Output("scopeVariables")]
        public Output<ImmutableArray<Outputs.ContainerRuntimePolicyScopeVariable>> ScopeVariables { get; private set; } = null!;

        /// <summary>
        /// Scope configuration.
        /// </summary>
        [Output("scopes")]
        public Output<ImmutableArray<Outputs.ContainerRuntimePolicyScope>> Scopes { get; private set; } = null!;

        [Output("systemIntegrityProtection")]
        public Output<Outputs.ContainerRuntimePolicySystemIntegrityProtection> SystemIntegrityProtection { get; private set; } = null!;

        [Output("tripwire")]
        public Output<Outputs.ContainerRuntimePolicyTripwire> Tripwire { get; private set; } = null!;

        [Output("type")]
        public Output<string?> Type { get; private set; } = null!;

        [Output("updated")]
        public Output<string> Updated { get; private set; } = null!;

        [Output("version")]
        public Output<string?> Version { get; private set; } = null!;

        [Output("vpatchVersion")]
        public Output<string?> VpatchVersion { get; private set; } = null!;

        [Output("whitelistedOsUsers")]
        public Output<Outputs.ContainerRuntimePolicyWhitelistedOsUsers> WhitelistedOsUsers { get; private set; } = null!;


        /// <summary>
        /// Create a ContainerRuntimePolicy resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ContainerRuntimePolicy(string name, ContainerRuntimePolicyArgs? args = null, CustomResourceOptions? options = null)
            : base("aquasec:index/containerRuntimePolicy:ContainerRuntimePolicy", name, args ?? new ContainerRuntimePolicyArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ContainerRuntimePolicy(string name, Input<string> id, ContainerRuntimePolicyState? state = null, CustomResourceOptions? options = null)
            : base("aquasec:index/containerRuntimePolicy:ContainerRuntimePolicy", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/pulumiverse/pulumi-aquasec",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ContainerRuntimePolicy resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ContainerRuntimePolicy Get(string name, Input<string> id, ContainerRuntimePolicyState? state = null, CustomResourceOptions? options = null)
        {
            return new ContainerRuntimePolicy(name, id, state, options);
        }
    }

    public sealed class ContainerRuntimePolicyArgs : global::Pulumi.ResourceArgs
    {
        [Input("allowedExecutables")]
        private InputList<Inputs.ContainerRuntimePolicyAllowedExecutableArgs>? _allowedExecutables;

        /// <summary>
        /// Allowed executables configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyAllowedExecutableArgs> AllowedExecutables
        {
            get => _allowedExecutables ?? (_allowedExecutables = new InputList<Inputs.ContainerRuntimePolicyAllowedExecutableArgs>());
            set => _allowedExecutables = value;
        }

        [Input("allowedRegistries")]
        private InputList<Inputs.ContainerRuntimePolicyAllowedRegistryArgs>? _allowedRegistries;

        /// <summary>
        /// List of allowed registries.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyAllowedRegistryArgs> AllowedRegistries
        {
            get => _allowedRegistries ?? (_allowedRegistries = new InputList<Inputs.ContainerRuntimePolicyAllowedRegistryArgs>());
            set => _allowedRegistries = value;
        }

        [Input("applicationScopes")]
        private InputList<string>? _applicationScopes;

        /// <summary>
        /// Indicates the application scope of the service.
        /// </summary>
        public InputList<string> ApplicationScopes
        {
            get => _applicationScopes ?? (_applicationScopes = new InputList<string>());
            set => _applicationScopes = value;
        }

        /// <summary>
        /// If true, all network activity will be audited.
        /// </summary>
        [Input("auditAllNetworkActivity")]
        public Input<bool>? AuditAllNetworkActivity { get; set; }

        /// <summary>
        /// If true, all process activity will be audited.
        /// </summary>
        [Input("auditAllProcessesActivity")]
        public Input<bool>? AuditAllProcessesActivity { get; set; }

        /// <summary>
        /// Detects brute force login attempts
        /// </summary>
        [Input("auditBruteForceLogin")]
        public Input<bool>? AuditBruteForceLogin { get; set; }

        /// <summary>
        /// If true, full command arguments will be audited.
        /// </summary>
        [Input("auditFullCommandArguments")]
        public Input<bool>? AuditFullCommandArguments { get; set; }

        [Input("auditing")]
        public Input<Inputs.ContainerRuntimePolicyAuditingArgs>? Auditing { get; set; }

        /// <summary>
        /// Username of the account that created the service.
        /// </summary>
        [Input("author")]
        public Input<string>? Author { get; set; }

        [Input("blacklistedOsUsers")]
        public Input<Inputs.ContainerRuntimePolicyBlacklistedOsUsersArgs>? BlacklistedOsUsers { get; set; }

        /// <summary>
        /// If true, prevent containers from running with access to host network.
        /// </summary>
        [Input("blockAccessHostNetwork")]
        public Input<bool>? BlockAccessHostNetwork { get; set; }

        /// <summary>
        /// If true, prevent containers from running with adding capabilities with `--cap-add` privilege.
        /// </summary>
        [Input("blockAddingCapabilities")]
        public Input<bool>? BlockAddingCapabilities { get; set; }

        /// <summary>
        /// If true, exec into a container is prevented.
        /// </summary>
        [Input("blockContainerExec")]
        public Input<bool>? BlockContainerExec { get; set; }

        /// <summary>
        /// Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
        /// </summary>
        [Input("blockCryptocurrencyMining")]
        public Input<bool>? BlockCryptocurrencyMining { get; set; }

        [Input("blockDisallowedImages")]
        public Input<bool>? BlockDisallowedImages { get; set; }

        /// <summary>
        /// Detect and prevent running in-memory execution
        /// </summary>
        [Input("blockFilelessExec")]
        public Input<bool>? BlockFilelessExec { get; set; }

        /// <summary>
        /// If true, prevent containers from running with the capability to bind in port lower than 1024.
        /// </summary>
        [Input("blockLowPortBinding")]
        public Input<bool>? BlockLowPortBinding { get; set; }

        /// <summary>
        /// If true, running containers in non-compliant pods is prevented.
        /// </summary>
        [Input("blockNonCompliantWorkloads")]
        public Input<bool>? BlockNonCompliantWorkloads { get; set; }

        /// <summary>
        /// If true, running non-kubernetes containers is prevented.
        /// </summary>
        [Input("blockNonK8sContainers")]
        public Input<bool>? BlockNonK8sContainers { get; set; }

        /// <summary>
        /// If true, prevent containers from running with privileged container capability.
        /// </summary>
        [Input("blockPrivilegedContainers")]
        public Input<bool>? BlockPrivilegedContainers { get; set; }

        /// <summary>
        /// If true, prevent containers from running with root user.
        /// </summary>
        [Input("blockRootUser")]
        public Input<bool>? BlockRootUser { get; set; }

        /// <summary>
        /// If true, prevent containers from running with the privilege to use the IPC namespace.
        /// </summary>
        [Input("blockUseIpcNamespace")]
        public Input<bool>? BlockUseIpcNamespace { get; set; }

        /// <summary>
        /// If true, prevent containers from running with the privilege to use the PID namespace.
        /// </summary>
        [Input("blockUsePidNamespace")]
        public Input<bool>? BlockUsePidNamespace { get; set; }

        /// <summary>
        /// If true, prevent containers from running with the privilege to use the user namespace.
        /// </summary>
        [Input("blockUseUserNamespace")]
        public Input<bool>? BlockUseUserNamespace { get; set; }

        /// <summary>
        /// If true, prevent containers from running with the privilege to use the UTS namespace.
        /// </summary>
        [Input("blockUseUtsNamespace")]
        public Input<bool>? BlockUseUtsNamespace { get; set; }

        [Input("blockedCapabilities")]
        private InputList<string>? _blockedCapabilities;

        /// <summary>
        /// If true, prevents containers from using specific Unix capabilities.
        /// </summary>
        public InputList<string> BlockedCapabilities
        {
            get => _blockedCapabilities ?? (_blockedCapabilities = new InputList<string>());
            set => _blockedCapabilities = value;
        }

        [Input("blockedExecutables")]
        private InputList<string>? _blockedExecutables;

        /// <summary>
        /// List of executables that are prevented from running in containers.
        /// </summary>
        public InputList<string> BlockedExecutables
        {
            get => _blockedExecutables ?? (_blockedExecutables = new InputList<string>());
            set => _blockedExecutables = value;
        }

        [Input("blockedFiles")]
        private InputList<string>? _blockedFiles;

        /// <summary>
        /// List of files that are prevented from being read, modified and executed in the containers.
        /// </summary>
        public InputList<string> BlockedFiles
        {
            get => _blockedFiles ?? (_blockedFiles = new InputList<string>());
            set => _blockedFiles = value;
        }

        [Input("blockedInboundPorts")]
        private InputList<string>? _blockedInboundPorts;

        /// <summary>
        /// List of blocked inbound ports.
        /// </summary>
        public InputList<string> BlockedInboundPorts
        {
            get => _blockedInboundPorts ?? (_blockedInboundPorts = new InputList<string>());
            set => _blockedInboundPorts = value;
        }

        [Input("blockedOutboundPorts")]
        private InputList<string>? _blockedOutboundPorts;

        /// <summary>
        /// List of blocked outbound ports.
        /// </summary>
        public InputList<string> BlockedOutboundPorts
        {
            get => _blockedOutboundPorts ?? (_blockedOutboundPorts = new InputList<string>());
            set => _blockedOutboundPorts = value;
        }

        [Input("blockedPackages")]
        private InputList<string>? _blockedPackages;

        /// <summary>
        /// Prevent containers from reading, writing, or executing all files in the list of packages.
        /// </summary>
        public InputList<string> BlockedPackages
        {
            get => _blockedPackages ?? (_blockedPackages = new InputList<string>());
            set => _blockedPackages = value;
        }

        [Input("blockedVolumes")]
        private InputList<string>? _blockedVolumes;

        /// <summary>
        /// List of volumes that are prevented from being mounted in the containers.
        /// </summary>
        public InputList<string> BlockedVolumes
        {
            get => _blockedVolumes ?? (_blockedVolumes = new InputList<string>());
            set => _blockedVolumes = value;
        }

        [Input("bypassScopes")]
        private InputList<Inputs.ContainerRuntimePolicyBypassScopeArgs>? _bypassScopes;

        /// <summary>
        /// Bypass scope configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyBypassScopeArgs> BypassScopes
        {
            get => _bypassScopes ?? (_bypassScopes = new InputList<Inputs.ContainerRuntimePolicyBypassScopeArgs>());
            set => _bypassScopes = value;
        }

        [Input("containerExec")]
        public Input<Inputs.ContainerRuntimePolicyContainerExecArgs>? ContainerExec { get; set; }

        [Input("containerExecAllowedProcesses")]
        private InputList<string>? _containerExecAllowedProcesses;

        /// <summary>
        /// List of processes that will be allowed.
        /// </summary>
        public InputList<string> ContainerExecAllowedProcesses
        {
            get => _containerExecAllowedProcesses ?? (_containerExecAllowedProcesses = new InputList<string>());
            set => _containerExecAllowedProcesses = value;
        }

        [Input("created")]
        public Input<string>? Created { get; set; }

        [Input("cve")]
        public Input<string>? Cve { get; set; }

        [Input("defaultSecurityProfile")]
        public Input<string>? DefaultSecurityProfile { get; set; }

        /// <summary>
        /// The description of the container runtime policy
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("digest")]
        public Input<string>? Digest { get; set; }

        [Input("driftPreventions")]
        private InputList<Inputs.ContainerRuntimePolicyDriftPreventionArgs>? _driftPreventions;

        /// <summary>
        /// Drift prevention configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyDriftPreventionArgs> DriftPreventions
        {
            get => _driftPreventions ?? (_driftPreventions = new InputList<Inputs.ContainerRuntimePolicyDriftPreventionArgs>());
            set => _driftPreventions = value;
        }

        [Input("enableCryptoMiningDns")]
        public Input<bool>? EnableCryptoMiningDns { get; set; }

        /// <summary>
        /// If true, fork bombs are prevented in the containers.
        /// </summary>
        [Input("enableForkGuard")]
        public Input<bool>? EnableForkGuard { get; set; }

        [Input("enableIpReputation")]
        public Input<bool>? EnableIpReputation { get; set; }

        [Input("enablePortScanProtection")]
        public Input<bool>? EnablePortScanProtection { get; set; }

        /// <summary>
        /// Whether allowed executables configuration is enabled.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Indicates that policy should effect container execution (not just for audit).
        /// </summary>
        [Input("enforce")]
        public Input<bool>? Enforce { get; set; }

        /// <summary>
        /// Indicates the number of days after which the runtime policy will be changed to enforce mode.
        /// </summary>
        [Input("enforceAfterDays")]
        public Input<int>? EnforceAfterDays { get; set; }

        [Input("enforceSchedulerAddedOn")]
        public Input<int>? EnforceSchedulerAddedOn { get; set; }

        [Input("excludeApplicationScopes")]
        private InputList<string>? _excludeApplicationScopes;

        /// <summary>
        /// List of excluded application scopes.
        /// </summary>
        public InputList<string> ExcludeApplicationScopes
        {
            get => _excludeApplicationScopes ?? (_excludeApplicationScopes = new InputList<string>());
            set => _excludeApplicationScopes = value;
        }

        [Input("executableBlacklists")]
        private InputList<Inputs.ContainerRuntimePolicyExecutableBlacklistArgs>? _executableBlacklists;

        /// <summary>
        /// Executable blacklist configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyExecutableBlacklistArgs> ExecutableBlacklists
        {
            get => _executableBlacklists ?? (_executableBlacklists = new InputList<Inputs.ContainerRuntimePolicyExecutableBlacklistArgs>());
            set => _executableBlacklists = value;
        }

        [Input("failedKubernetesChecks")]
        public Input<Inputs.ContainerRuntimePolicyFailedKubernetesChecksArgs>? FailedKubernetesChecks { get; set; }

        [Input("fileBlock")]
        public Input<Inputs.ContainerRuntimePolicyFileBlockArgs>? FileBlock { get; set; }

        /// <summary>
        /// Configuration for file integrity monitoring.
        /// </summary>
        [Input("fileIntegrityMonitoring")]
        public Input<Inputs.ContainerRuntimePolicyFileIntegrityMonitoringArgs>? FileIntegrityMonitoring { get; set; }

        /// <summary>
        /// Process limit for the fork guard.
        /// </summary>
        [Input("forkGuardProcessLimit")]
        public Input<int>? ForkGuardProcessLimit { get; set; }

        [Input("imageName")]
        public Input<string>? ImageName { get; set; }

        [Input("isAuditChecked")]
        public Input<bool>? IsAuditChecked { get; set; }

        [Input("isAutoGenerated")]
        public Input<bool>? IsAutoGenerated { get; set; }

        [Input("isOotbPolicy")]
        public Input<bool>? IsOotbPolicy { get; set; }

        [Input("lastupdate")]
        public Input<int>? Lastupdate { get; set; }

        [Input("limitContainerPrivileges")]
        private InputList<Inputs.ContainerRuntimePolicyLimitContainerPrivilegeArgs>? _limitContainerPrivileges;

        /// <summary>
        /// Container privileges configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyLimitContainerPrivilegeArgs> LimitContainerPrivileges
        {
            get => _limitContainerPrivileges ?? (_limitContainerPrivileges = new InputList<Inputs.ContainerRuntimePolicyLimitContainerPrivilegeArgs>());
            set => _limitContainerPrivileges = value;
        }

        /// <summary>
        /// If true, prevents the container from obtaining new privileges at runtime. (only enabled in enforce mode)
        /// </summary>
        [Input("limitNewPrivileges")]
        public Input<bool>? LimitNewPrivileges { get; set; }

        [Input("linuxCapabilities")]
        public Input<Inputs.ContainerRuntimePolicyLinuxCapabilitiesArgs>? LinuxCapabilities { get; set; }

        /// <summary>
        /// Configuration for Real-Time Malware Protection.
        /// </summary>
        [Input("malwareScanOptions")]
        public Input<Inputs.ContainerRuntimePolicyMalwareScanOptionsArgs>? MalwareScanOptions { get; set; }

        /// <summary>
        /// If true, system time changes will be monitored.
        /// </summary>
        [Input("monitorSystemTimeChanges")]
        public Input<bool>? MonitorSystemTimeChanges { get; set; }

        /// <summary>
        /// Name assigned to the attribute.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("noNewPrivileges")]
        public Input<bool>? NoNewPrivileges { get; set; }

        [Input("onlyRegisteredImages")]
        public Input<bool>? OnlyRegisteredImages { get; set; }

        [Input("packageBlock")]
        public Input<Inputs.ContainerRuntimePolicyPackageBlockArgs>? PackageBlock { get; set; }

        [Input("permission")]
        public Input<string>? Permission { get; set; }

        [Input("portBlock")]
        public Input<Inputs.ContainerRuntimePolicyPortBlockArgs>? PortBlock { get; set; }

        [Input("readonlyFiles")]
        public Input<Inputs.ContainerRuntimePolicyReadonlyFilesArgs>? ReadonlyFiles { get; set; }

        [Input("readonlyRegistry")]
        public Input<Inputs.ContainerRuntimePolicyReadonlyRegistryArgs>? ReadonlyRegistry { get; set; }

        [Input("registry")]
        public Input<string>? Registry { get; set; }

        [Input("registryAccessMonitoring")]
        public Input<Inputs.ContainerRuntimePolicyRegistryAccessMonitoringArgs>? RegistryAccessMonitoring { get; set; }

        [Input("repoName")]
        public Input<string>? RepoName { get; set; }

        [Input("resourceName")]
        public Input<string>? ResourceName { get; set; }

        [Input("resourceType")]
        public Input<string>? ResourceType { get; set; }

        [Input("restrictedVolumes")]
        private InputList<Inputs.ContainerRuntimePolicyRestrictedVolumeArgs>? _restrictedVolumes;

        /// <summary>
        /// Restricted volumes configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyRestrictedVolumeArgs> RestrictedVolumes
        {
            get => _restrictedVolumes ?? (_restrictedVolumes = new InputList<Inputs.ContainerRuntimePolicyRestrictedVolumeArgs>());
            set => _restrictedVolumes = value;
        }

        [Input("reverseShell")]
        public Input<Inputs.ContainerRuntimePolicyReverseShellArgs>? ReverseShell { get; set; }

        [Input("runtimeMode")]
        public Input<int>? RuntimeMode { get; set; }

        [Input("runtimeType")]
        public Input<string>? RuntimeType { get; set; }

        /// <summary>
        /// Logical expression of how to compute the dependency of the scope variables.
        /// </summary>
        [Input("scopeExpression")]
        public Input<string>? ScopeExpression { get; set; }

        [Input("scopeVariables")]
        private InputList<Inputs.ContainerRuntimePolicyScopeVariableArgs>? _scopeVariables;

        /// <summary>
        /// List of scope attributes.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyScopeVariableArgs> ScopeVariables
        {
            get => _scopeVariables ?? (_scopeVariables = new InputList<Inputs.ContainerRuntimePolicyScopeVariableArgs>());
            set => _scopeVariables = value;
        }

        [Input("scopes")]
        private InputList<Inputs.ContainerRuntimePolicyScopeArgs>? _scopes;

        /// <summary>
        /// Scope configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyScopeArgs> Scopes
        {
            get => _scopes ?? (_scopes = new InputList<Inputs.ContainerRuntimePolicyScopeArgs>());
            set => _scopes = value;
        }

        [Input("systemIntegrityProtection")]
        public Input<Inputs.ContainerRuntimePolicySystemIntegrityProtectionArgs>? SystemIntegrityProtection { get; set; }

        [Input("tripwire")]
        public Input<Inputs.ContainerRuntimePolicyTripwireArgs>? Tripwire { get; set; }

        [Input("type")]
        public Input<string>? Type { get; set; }

        [Input("updated")]
        public Input<string>? Updated { get; set; }

        [Input("version")]
        public Input<string>? Version { get; set; }

        [Input("vpatchVersion")]
        public Input<string>? VpatchVersion { get; set; }

        [Input("whitelistedOsUsers")]
        public Input<Inputs.ContainerRuntimePolicyWhitelistedOsUsersArgs>? WhitelistedOsUsers { get; set; }

        public ContainerRuntimePolicyArgs()
        {
        }
        public static new ContainerRuntimePolicyArgs Empty => new ContainerRuntimePolicyArgs();
    }

    public sealed class ContainerRuntimePolicyState : global::Pulumi.ResourceArgs
    {
        [Input("allowedExecutables")]
        private InputList<Inputs.ContainerRuntimePolicyAllowedExecutableGetArgs>? _allowedExecutables;

        /// <summary>
        /// Allowed executables configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyAllowedExecutableGetArgs> AllowedExecutables
        {
            get => _allowedExecutables ?? (_allowedExecutables = new InputList<Inputs.ContainerRuntimePolicyAllowedExecutableGetArgs>());
            set => _allowedExecutables = value;
        }

        [Input("allowedRegistries")]
        private InputList<Inputs.ContainerRuntimePolicyAllowedRegistryGetArgs>? _allowedRegistries;

        /// <summary>
        /// List of allowed registries.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyAllowedRegistryGetArgs> AllowedRegistries
        {
            get => _allowedRegistries ?? (_allowedRegistries = new InputList<Inputs.ContainerRuntimePolicyAllowedRegistryGetArgs>());
            set => _allowedRegistries = value;
        }

        [Input("applicationScopes")]
        private InputList<string>? _applicationScopes;

        /// <summary>
        /// Indicates the application scope of the service.
        /// </summary>
        public InputList<string> ApplicationScopes
        {
            get => _applicationScopes ?? (_applicationScopes = new InputList<string>());
            set => _applicationScopes = value;
        }

        /// <summary>
        /// If true, all network activity will be audited.
        /// </summary>
        [Input("auditAllNetworkActivity")]
        public Input<bool>? AuditAllNetworkActivity { get; set; }

        /// <summary>
        /// If true, all process activity will be audited.
        /// </summary>
        [Input("auditAllProcessesActivity")]
        public Input<bool>? AuditAllProcessesActivity { get; set; }

        /// <summary>
        /// Detects brute force login attempts
        /// </summary>
        [Input("auditBruteForceLogin")]
        public Input<bool>? AuditBruteForceLogin { get; set; }

        /// <summary>
        /// If true, full command arguments will be audited.
        /// </summary>
        [Input("auditFullCommandArguments")]
        public Input<bool>? AuditFullCommandArguments { get; set; }

        [Input("auditing")]
        public Input<Inputs.ContainerRuntimePolicyAuditingGetArgs>? Auditing { get; set; }

        /// <summary>
        /// Username of the account that created the service.
        /// </summary>
        [Input("author")]
        public Input<string>? Author { get; set; }

        [Input("blacklistedOsUsers")]
        public Input<Inputs.ContainerRuntimePolicyBlacklistedOsUsersGetArgs>? BlacklistedOsUsers { get; set; }

        /// <summary>
        /// If true, prevent containers from running with access to host network.
        /// </summary>
        [Input("blockAccessHostNetwork")]
        public Input<bool>? BlockAccessHostNetwork { get; set; }

        /// <summary>
        /// If true, prevent containers from running with adding capabilities with `--cap-add` privilege.
        /// </summary>
        [Input("blockAddingCapabilities")]
        public Input<bool>? BlockAddingCapabilities { get; set; }

        /// <summary>
        /// If true, exec into a container is prevented.
        /// </summary>
        [Input("blockContainerExec")]
        public Input<bool>? BlockContainerExec { get; set; }

        /// <summary>
        /// Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
        /// </summary>
        [Input("blockCryptocurrencyMining")]
        public Input<bool>? BlockCryptocurrencyMining { get; set; }

        [Input("blockDisallowedImages")]
        public Input<bool>? BlockDisallowedImages { get; set; }

        /// <summary>
        /// Detect and prevent running in-memory execution
        /// </summary>
        [Input("blockFilelessExec")]
        public Input<bool>? BlockFilelessExec { get; set; }

        /// <summary>
        /// If true, prevent containers from running with the capability to bind in port lower than 1024.
        /// </summary>
        [Input("blockLowPortBinding")]
        public Input<bool>? BlockLowPortBinding { get; set; }

        /// <summary>
        /// If true, running containers in non-compliant pods is prevented.
        /// </summary>
        [Input("blockNonCompliantWorkloads")]
        public Input<bool>? BlockNonCompliantWorkloads { get; set; }

        /// <summary>
        /// If true, running non-kubernetes containers is prevented.
        /// </summary>
        [Input("blockNonK8sContainers")]
        public Input<bool>? BlockNonK8sContainers { get; set; }

        /// <summary>
        /// If true, prevent containers from running with privileged container capability.
        /// </summary>
        [Input("blockPrivilegedContainers")]
        public Input<bool>? BlockPrivilegedContainers { get; set; }

        /// <summary>
        /// If true, prevent containers from running with root user.
        /// </summary>
        [Input("blockRootUser")]
        public Input<bool>? BlockRootUser { get; set; }

        /// <summary>
        /// If true, prevent containers from running with the privilege to use the IPC namespace.
        /// </summary>
        [Input("blockUseIpcNamespace")]
        public Input<bool>? BlockUseIpcNamespace { get; set; }

        /// <summary>
        /// If true, prevent containers from running with the privilege to use the PID namespace.
        /// </summary>
        [Input("blockUsePidNamespace")]
        public Input<bool>? BlockUsePidNamespace { get; set; }

        /// <summary>
        /// If true, prevent containers from running with the privilege to use the user namespace.
        /// </summary>
        [Input("blockUseUserNamespace")]
        public Input<bool>? BlockUseUserNamespace { get; set; }

        /// <summary>
        /// If true, prevent containers from running with the privilege to use the UTS namespace.
        /// </summary>
        [Input("blockUseUtsNamespace")]
        public Input<bool>? BlockUseUtsNamespace { get; set; }

        [Input("blockedCapabilities")]
        private InputList<string>? _blockedCapabilities;

        /// <summary>
        /// If true, prevents containers from using specific Unix capabilities.
        /// </summary>
        public InputList<string> BlockedCapabilities
        {
            get => _blockedCapabilities ?? (_blockedCapabilities = new InputList<string>());
            set => _blockedCapabilities = value;
        }

        [Input("blockedExecutables")]
        private InputList<string>? _blockedExecutables;

        /// <summary>
        /// List of executables that are prevented from running in containers.
        /// </summary>
        public InputList<string> BlockedExecutables
        {
            get => _blockedExecutables ?? (_blockedExecutables = new InputList<string>());
            set => _blockedExecutables = value;
        }

        [Input("blockedFiles")]
        private InputList<string>? _blockedFiles;

        /// <summary>
        /// List of files that are prevented from being read, modified and executed in the containers.
        /// </summary>
        public InputList<string> BlockedFiles
        {
            get => _blockedFiles ?? (_blockedFiles = new InputList<string>());
            set => _blockedFiles = value;
        }

        [Input("blockedInboundPorts")]
        private InputList<string>? _blockedInboundPorts;

        /// <summary>
        /// List of blocked inbound ports.
        /// </summary>
        public InputList<string> BlockedInboundPorts
        {
            get => _blockedInboundPorts ?? (_blockedInboundPorts = new InputList<string>());
            set => _blockedInboundPorts = value;
        }

        [Input("blockedOutboundPorts")]
        private InputList<string>? _blockedOutboundPorts;

        /// <summary>
        /// List of blocked outbound ports.
        /// </summary>
        public InputList<string> BlockedOutboundPorts
        {
            get => _blockedOutboundPorts ?? (_blockedOutboundPorts = new InputList<string>());
            set => _blockedOutboundPorts = value;
        }

        [Input("blockedPackages")]
        private InputList<string>? _blockedPackages;

        /// <summary>
        /// Prevent containers from reading, writing, or executing all files in the list of packages.
        /// </summary>
        public InputList<string> BlockedPackages
        {
            get => _blockedPackages ?? (_blockedPackages = new InputList<string>());
            set => _blockedPackages = value;
        }

        [Input("blockedVolumes")]
        private InputList<string>? _blockedVolumes;

        /// <summary>
        /// List of volumes that are prevented from being mounted in the containers.
        /// </summary>
        public InputList<string> BlockedVolumes
        {
            get => _blockedVolumes ?? (_blockedVolumes = new InputList<string>());
            set => _blockedVolumes = value;
        }

        [Input("bypassScopes")]
        private InputList<Inputs.ContainerRuntimePolicyBypassScopeGetArgs>? _bypassScopes;

        /// <summary>
        /// Bypass scope configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyBypassScopeGetArgs> BypassScopes
        {
            get => _bypassScopes ?? (_bypassScopes = new InputList<Inputs.ContainerRuntimePolicyBypassScopeGetArgs>());
            set => _bypassScopes = value;
        }

        [Input("containerExec")]
        public Input<Inputs.ContainerRuntimePolicyContainerExecGetArgs>? ContainerExec { get; set; }

        [Input("containerExecAllowedProcesses")]
        private InputList<string>? _containerExecAllowedProcesses;

        /// <summary>
        /// List of processes that will be allowed.
        /// </summary>
        public InputList<string> ContainerExecAllowedProcesses
        {
            get => _containerExecAllowedProcesses ?? (_containerExecAllowedProcesses = new InputList<string>());
            set => _containerExecAllowedProcesses = value;
        }

        [Input("created")]
        public Input<string>? Created { get; set; }

        [Input("cve")]
        public Input<string>? Cve { get; set; }

        [Input("defaultSecurityProfile")]
        public Input<string>? DefaultSecurityProfile { get; set; }

        /// <summary>
        /// The description of the container runtime policy
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("digest")]
        public Input<string>? Digest { get; set; }

        [Input("driftPreventions")]
        private InputList<Inputs.ContainerRuntimePolicyDriftPreventionGetArgs>? _driftPreventions;

        /// <summary>
        /// Drift prevention configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyDriftPreventionGetArgs> DriftPreventions
        {
            get => _driftPreventions ?? (_driftPreventions = new InputList<Inputs.ContainerRuntimePolicyDriftPreventionGetArgs>());
            set => _driftPreventions = value;
        }

        [Input("enableCryptoMiningDns")]
        public Input<bool>? EnableCryptoMiningDns { get; set; }

        /// <summary>
        /// If true, fork bombs are prevented in the containers.
        /// </summary>
        [Input("enableForkGuard")]
        public Input<bool>? EnableForkGuard { get; set; }

        [Input("enableIpReputation")]
        public Input<bool>? EnableIpReputation { get; set; }

        [Input("enablePortScanProtection")]
        public Input<bool>? EnablePortScanProtection { get; set; }

        /// <summary>
        /// Whether allowed executables configuration is enabled.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Indicates that policy should effect container execution (not just for audit).
        /// </summary>
        [Input("enforce")]
        public Input<bool>? Enforce { get; set; }

        /// <summary>
        /// Indicates the number of days after which the runtime policy will be changed to enforce mode.
        /// </summary>
        [Input("enforceAfterDays")]
        public Input<int>? EnforceAfterDays { get; set; }

        [Input("enforceSchedulerAddedOn")]
        public Input<int>? EnforceSchedulerAddedOn { get; set; }

        [Input("excludeApplicationScopes")]
        private InputList<string>? _excludeApplicationScopes;

        /// <summary>
        /// List of excluded application scopes.
        /// </summary>
        public InputList<string> ExcludeApplicationScopes
        {
            get => _excludeApplicationScopes ?? (_excludeApplicationScopes = new InputList<string>());
            set => _excludeApplicationScopes = value;
        }

        [Input("executableBlacklists")]
        private InputList<Inputs.ContainerRuntimePolicyExecutableBlacklistGetArgs>? _executableBlacklists;

        /// <summary>
        /// Executable blacklist configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyExecutableBlacklistGetArgs> ExecutableBlacklists
        {
            get => _executableBlacklists ?? (_executableBlacklists = new InputList<Inputs.ContainerRuntimePolicyExecutableBlacklistGetArgs>());
            set => _executableBlacklists = value;
        }

        [Input("failedKubernetesChecks")]
        public Input<Inputs.ContainerRuntimePolicyFailedKubernetesChecksGetArgs>? FailedKubernetesChecks { get; set; }

        [Input("fileBlock")]
        public Input<Inputs.ContainerRuntimePolicyFileBlockGetArgs>? FileBlock { get; set; }

        /// <summary>
        /// Configuration for file integrity monitoring.
        /// </summary>
        [Input("fileIntegrityMonitoring")]
        public Input<Inputs.ContainerRuntimePolicyFileIntegrityMonitoringGetArgs>? FileIntegrityMonitoring { get; set; }

        /// <summary>
        /// Process limit for the fork guard.
        /// </summary>
        [Input("forkGuardProcessLimit")]
        public Input<int>? ForkGuardProcessLimit { get; set; }

        [Input("imageName")]
        public Input<string>? ImageName { get; set; }

        [Input("isAuditChecked")]
        public Input<bool>? IsAuditChecked { get; set; }

        [Input("isAutoGenerated")]
        public Input<bool>? IsAutoGenerated { get; set; }

        [Input("isOotbPolicy")]
        public Input<bool>? IsOotbPolicy { get; set; }

        [Input("lastupdate")]
        public Input<int>? Lastupdate { get; set; }

        [Input("limitContainerPrivileges")]
        private InputList<Inputs.ContainerRuntimePolicyLimitContainerPrivilegeGetArgs>? _limitContainerPrivileges;

        /// <summary>
        /// Container privileges configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyLimitContainerPrivilegeGetArgs> LimitContainerPrivileges
        {
            get => _limitContainerPrivileges ?? (_limitContainerPrivileges = new InputList<Inputs.ContainerRuntimePolicyLimitContainerPrivilegeGetArgs>());
            set => _limitContainerPrivileges = value;
        }

        /// <summary>
        /// If true, prevents the container from obtaining new privileges at runtime. (only enabled in enforce mode)
        /// </summary>
        [Input("limitNewPrivileges")]
        public Input<bool>? LimitNewPrivileges { get; set; }

        [Input("linuxCapabilities")]
        public Input<Inputs.ContainerRuntimePolicyLinuxCapabilitiesGetArgs>? LinuxCapabilities { get; set; }

        /// <summary>
        /// Configuration for Real-Time Malware Protection.
        /// </summary>
        [Input("malwareScanOptions")]
        public Input<Inputs.ContainerRuntimePolicyMalwareScanOptionsGetArgs>? MalwareScanOptions { get; set; }

        /// <summary>
        /// If true, system time changes will be monitored.
        /// </summary>
        [Input("monitorSystemTimeChanges")]
        public Input<bool>? MonitorSystemTimeChanges { get; set; }

        /// <summary>
        /// Name assigned to the attribute.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("noNewPrivileges")]
        public Input<bool>? NoNewPrivileges { get; set; }

        [Input("onlyRegisteredImages")]
        public Input<bool>? OnlyRegisteredImages { get; set; }

        [Input("packageBlock")]
        public Input<Inputs.ContainerRuntimePolicyPackageBlockGetArgs>? PackageBlock { get; set; }

        [Input("permission")]
        public Input<string>? Permission { get; set; }

        [Input("portBlock")]
        public Input<Inputs.ContainerRuntimePolicyPortBlockGetArgs>? PortBlock { get; set; }

        [Input("readonlyFiles")]
        public Input<Inputs.ContainerRuntimePolicyReadonlyFilesGetArgs>? ReadonlyFiles { get; set; }

        [Input("readonlyRegistry")]
        public Input<Inputs.ContainerRuntimePolicyReadonlyRegistryGetArgs>? ReadonlyRegistry { get; set; }

        [Input("registry")]
        public Input<string>? Registry { get; set; }

        [Input("registryAccessMonitoring")]
        public Input<Inputs.ContainerRuntimePolicyRegistryAccessMonitoringGetArgs>? RegistryAccessMonitoring { get; set; }

        [Input("repoName")]
        public Input<string>? RepoName { get; set; }

        [Input("resourceName")]
        public Input<string>? ResourceName { get; set; }

        [Input("resourceType")]
        public Input<string>? ResourceType { get; set; }

        [Input("restrictedVolumes")]
        private InputList<Inputs.ContainerRuntimePolicyRestrictedVolumeGetArgs>? _restrictedVolumes;

        /// <summary>
        /// Restricted volumes configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyRestrictedVolumeGetArgs> RestrictedVolumes
        {
            get => _restrictedVolumes ?? (_restrictedVolumes = new InputList<Inputs.ContainerRuntimePolicyRestrictedVolumeGetArgs>());
            set => _restrictedVolumes = value;
        }

        [Input("reverseShell")]
        public Input<Inputs.ContainerRuntimePolicyReverseShellGetArgs>? ReverseShell { get; set; }

        [Input("runtimeMode")]
        public Input<int>? RuntimeMode { get; set; }

        [Input("runtimeType")]
        public Input<string>? RuntimeType { get; set; }

        /// <summary>
        /// Logical expression of how to compute the dependency of the scope variables.
        /// </summary>
        [Input("scopeExpression")]
        public Input<string>? ScopeExpression { get; set; }

        [Input("scopeVariables")]
        private InputList<Inputs.ContainerRuntimePolicyScopeVariableGetArgs>? _scopeVariables;

        /// <summary>
        /// List of scope attributes.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyScopeVariableGetArgs> ScopeVariables
        {
            get => _scopeVariables ?? (_scopeVariables = new InputList<Inputs.ContainerRuntimePolicyScopeVariableGetArgs>());
            set => _scopeVariables = value;
        }

        [Input("scopes")]
        private InputList<Inputs.ContainerRuntimePolicyScopeGetArgs>? _scopes;

        /// <summary>
        /// Scope configuration.
        /// </summary>
        public InputList<Inputs.ContainerRuntimePolicyScopeGetArgs> Scopes
        {
            get => _scopes ?? (_scopes = new InputList<Inputs.ContainerRuntimePolicyScopeGetArgs>());
            set => _scopes = value;
        }

        [Input("systemIntegrityProtection")]
        public Input<Inputs.ContainerRuntimePolicySystemIntegrityProtectionGetArgs>? SystemIntegrityProtection { get; set; }

        [Input("tripwire")]
        public Input<Inputs.ContainerRuntimePolicyTripwireGetArgs>? Tripwire { get; set; }

        [Input("type")]
        public Input<string>? Type { get; set; }

        [Input("updated")]
        public Input<string>? Updated { get; set; }

        [Input("version")]
        public Input<string>? Version { get; set; }

        [Input("vpatchVersion")]
        public Input<string>? VpatchVersion { get; set; }

        [Input("whitelistedOsUsers")]
        public Input<Inputs.ContainerRuntimePolicyWhitelistedOsUsersGetArgs>? WhitelistedOsUsers { get; set; }

        public ContainerRuntimePolicyState()
        {
        }
        public static new ContainerRuntimePolicyState Empty => new ContainerRuntimePolicyState();
    }
}
