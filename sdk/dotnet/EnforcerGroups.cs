// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Pulumiverse.Aquasec
{
    /// <summary>
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using Pulumi;
    /// using Aquasec = Pulumiverse.Aquasec;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @group = new Aquasec.EnforcerGroups("group", new()
    ///     {
    ///         AntivirusProtection = true,
    ///         ContainerActivityProtection = true,
    ///         ContainerAntivirusProtection = true,
    ///         Enforce = true,
    ///         Forensics = true,
    ///         GroupId = "tf-test-enforcer",
    ///         HostAssurance = true,
    ///         HostForensics = true,
    ///         HostNetworkProtection = true,
    ///         HostProtection = true,
    ///         ImageAssurance = true,
    ///         NetworkProtection = true,
    ///         Orchestrators = new[]
    ///         {
    ///             null,
    ///         },
    ///         RiskExplorerAutoDiscovery = true,
    ///         SyncHostImages = true,
    ///         Type = "agent",
    ///     });
    /// 
    ///     var group_kubeEnforcer = new Aquasec.EnforcerGroups("group-kubeEnforcer", new()
    ///     {
    ///         AdmissionControl = true,
    ///         AutoCopySecrets = true,
    ///         AutoDiscoverConfigureRegistries = true,
    ///         AutoDiscoveryEnabled = true,
    ///         AutoScanDiscoveredImagesRunningContainers = true,
    ///         BlockAdmissionControl = true,
    ///         Enforce = true,
    ///         GroupId = "tf-test-kube_enforcer",
    ///         KubeBenchImageName = "registry.aquasec.com/kube-bench:v0.6.5",
    ///         MicroEnforcerSecretsName = "aqua-registry",
    ///         Orchestrators = new[]
    ///         {
    ///             new Aquasec.Inputs.EnforcerGroupsOrchestratorArgs
    ///             {
    ///                 Namespace = "aqua",
    ///                 Type = "kubernetes",
    ///             },
    ///         },
    ///         Type = "kube_enforcer",
    ///     });
    /// 
    /// });
    /// ```
    /// </summary>
    [AquasecResourceType("aquasec:index/enforcerGroups:EnforcerGroups")]
    public partial class EnforcerGroups : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Selecting this option will allow the KubeEnforcer to block the deployment of container images that have failed any of these Container Runtime Policy controls:\
        /// 			* Block Non-Compliant Images\
        /// 			* Block Non-Compliant Workloads\
        /// 			* Block Unregistered Images\
        /// 			This functionality can work only when the KubeEnforcer is deployed in Enforce mode.
        /// </summary>
        [Output("admissionControl")]
        public Output<bool?> AdmissionControl { get; private set; } = null!;

        /// <summary>
        /// Allow kube enforcer audit.
        /// </summary>
        [Output("allowKubeEnforcerAudit")]
        public Output<bool?> AllowKubeEnforcerAudit { get; private set; } = null!;

        /// <summary>
        /// List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
        /// </summary>
        [Output("allowedApplications")]
        public Output<ImmutableArray<string>> AllowedApplications { get; private set; } = null!;

        /// <summary>
        /// List of label names to allow on the hosts.
        /// </summary>
        [Output("allowedLabels")]
        public Output<ImmutableArray<string>> AllowedLabels { get; private set; } = null!;

        /// <summary>
        /// List of registry names to allow on the hosts.
        /// </summary>
        [Output("allowedRegistries")]
        public Output<ImmutableArray<string>> AllowedRegistries { get; private set; } = null!;

        /// <summary>
        /// This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Host Runtime policies.
        /// </summary>
        [Output("antivirusProtection")]
        public Output<bool?> AntivirusProtection { get; private set; } = null!;

        /// <summary>
        /// Aqua server version
        /// </summary>
        [Output("aquaVersion")]
        public Output<string> AquaVersion { get; private set; } = null!;

        /// <summary>
        /// Agent will send extra audit messages to the server for success operations from inside the container (runtime).
        /// </summary>
        [Output("auditAll")]
        public Output<bool?> AuditAll { get; private set; } = null!;

        /// <summary>
        /// This option is applicable only if `Enable Pod Enforcer injection` is selected. Select this option if you want Aqua Enterprise to copy the secrets defined above to the Pod Enforcer namespace and container. Otherwise, you can choose to copy these secrets by other means.
        /// </summary>
        [Output("autoCopySecrets")]
        public Output<bool> AutoCopySecrets { get; private set; } = null!;

        /// <summary>
        /// This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will add previously unknown image registries from the cluster to Aqua.
        /// </summary>
        [Output("autoDiscoverConfigureRegistries")]
        public Output<bool?> AutoDiscoverConfigureRegistries { get; private set; } = null!;

        /// <summary>
        /// When this option is selected, the KubeEnforcer will discover workloads on its cluster.
        /// </summary>
        [Output("autoDiscoveryEnabled")]
        public Output<bool?> AutoDiscoveryEnabled { get; private set; } = null!;

        /// <summary>
        /// This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will automatically register images running as workloads (and scan the discovered images for security issues).
        /// </summary>
        [Output("autoScanDiscoveredImagesRunningContainers")]
        public Output<bool?> AutoScanDiscoveredImagesRunningContainers { get; private set; } = null!;

        /// <summary>
        /// Select Enabled to detect suspicious activity in your containers and display potential security threats in the Incidents and Audit pages.
        /// </summary>
        [Output("behavioralEngine")]
        public Output<bool?> BehavioralEngine { get; private set; } = null!;

        /// <summary>
        /// This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
        /// </summary>
        [Output("blockAdmissionControl")]
        public Output<bool?> BlockAdmissionControl { get; private set; } = null!;

        /// <summary>
        /// The installation command.
        /// </summary>
        [Output("commands")]
        public Output<ImmutableArray<Outputs.EnforcerGroupsCommand>> Commands { get; private set; } = null!;

        /// <summary>
        /// Number of connected enforcers in the enforcer group.
        /// </summary>
        [Output("connectedCount")]
        public Output<int> ConnectedCount { get; private set; } = null!;

        /// <summary>
        /// Set `True` to apply Container Runtime Policies, Image Profiles, and Firewall Policies to containers.
        /// </summary>
        [Output("containerActivityProtection")]
        public Output<bool?> ContainerActivityProtection { get; private set; } = null!;

        /// <summary>
        /// This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Container Runtime policies.
        /// </summary>
        [Output("containerAntivirusProtection")]
        public Output<bool?> ContainerAntivirusProtection { get; private set; } = null!;

        /// <summary>
        /// A description of the Aqua Enforcer group.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// Number of disconnected enforcers in the enforcer group.
        /// </summary>
        [Output("disconnectedCount")]
        public Output<int> DisconnectedCount { get; private set; } = null!;

        /// <summary>
        /// Whether to enable enforce mode on the Enforcers, defaults to False.
        /// </summary>
        [Output("enforce")]
        public Output<bool?> Enforce { get; private set; } = null!;

        /// <summary>
        /// The specific Aqua Enforcer product image (with image tag) to be deployed.
        /// </summary>
        [Output("enforcerImageName")]
        public Output<string> EnforcerImageName { get; private set; } = null!;

        /// <summary>
        /// Select Enabled to send activity logs in your containers to the Aqua Server for forensics purposes.
        /// </summary>
        [Output("forensics")]
        public Output<bool?> Forensics { get; private set; } = null!;

        /// <summary>
        /// Gateway Address
        /// </summary>
        [Output("gatewayAddress")]
        public Output<string> GatewayAddress { get; private set; } = null!;

        /// <summary>
        /// Gateway Name
        /// </summary>
        [Output("gatewayName")]
        public Output<string> GatewayName { get; private set; } = null!;

        /// <summary>
        /// List of Aqua gateway IDs for the Enforcers.
        /// </summary>
        [Output("gateways")]
        public Output<ImmutableArray<string>> Gateways { get; private set; } = null!;

        /// <summary>
        /// The ID of the Enforcer group.
        /// </summary>
        [Output("groupId")]
        public Output<string> GroupId { get; private set; } = null!;

        /// <summary>
        /// Number of high vulnerabilities in the enforcers that in this enforcer group.
        /// </summary>
        [Output("highVulns")]
        public Output<int> HighVulns { get; private set; } = null!;

        /// <summary>
        /// Set `True` to enable host scanning and respective Host Assurance controls.
        /// </summary>
        [Output("hostAssurance")]
        public Output<bool?> HostAssurance { get; private set; } = null!;

        /// <summary>
        /// Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
        /// </summary>
        [Output("hostBehavioralEngine")]
        public Output<bool?> HostBehavioralEngine { get; private set; } = null!;

        /// <summary>
        /// Select Enabled to send activity logs in your host to the Aqua Server for forensics purposes.
        /// </summary>
        [Output("hostForensics")]
        public Output<bool?> HostForensics { get; private set; } = null!;

        /// <summary>
        /// Set `True` to apply Firewall Policies to hosts, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information
        /// </summary>
        [Output("hostNetworkProtection")]
        public Output<bool?> HostNetworkProtection { get; private set; } = null!;

        /// <summary>
        /// The OS type for the host
        /// </summary>
        [Output("hostOs")]
        public Output<string> HostOs { get; private set; } = null!;

        /// <summary>
        /// Set `True` to enable all Host Runtime Policy controls except for `OS Users and Groups Allowed` and `OS Users and Groups Blocked`.
        /// </summary>
        [Output("hostProtection")]
        public Output<bool?> HostProtection { get; private set; } = null!;

        /// <summary>
        /// Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
        /// </summary>
        [Output("hostUserProtection")]
        public Output<bool?> HostUserProtection { get; private set; } = null!;

        /// <summary>
        /// The hostname
        /// </summary>
        [Output("hostname")]
        public Output<string> Hostname { get; private set; } = null!;

        /// <summary>
        /// Number of enforcers in the enforcer group.
        /// </summary>
        [Output("hostsCount")]
        public Output<int> HostsCount { get; private set; } = null!;

        /// <summary>
        /// Set `True` to enable selected controls: Container Runtime Policy (`Block Non-Compliant Images`, `Block Unregistered Images`, and `Registries Allowed`) and Default Image Assurance Policy (`Images Blocked`).
        /// </summary>
        [Output("imageAssurance")]
        public Output<bool?> ImageAssurance { get; private set; } = null!;

        /// <summary>
        /// Enforcer install command
        /// </summary>
        [Output("installCommand")]
        public Output<string> InstallCommand { get; private set; } = null!;

        /// <summary>
        /// See https://docs.aquasec.com/docs/securing-kubernetes-applications#section-configuration-hardening, The KubeEnforcer can deploy the Aqua Security kube-bench open-source product to perform Kubernetes CIS benchmark testing of nodes.
        /// 			This field specifies the path and file name of the kube-bench product image for the KubeEnforcer to deploy; it will be filled in automatically. You can optionally enter a different value.
        /// </summary>
        [Output("kubeBenchImageName")]
        public Output<string> KubeBenchImageName { get; private set; } = null!;

        /// <summary>
        /// The last date and time the batch token was updated in UNIX time.
        /// </summary>
        [Output("lastUpdate")]
        public Output<int> LastUpdate { get; private set; } = null!;

        /// <summary>
        /// Name for the batch install record.
        /// </summary>
        [Output("logicalName")]
        public Output<string> LogicalName { get; private set; } = null!;

        /// <summary>
        /// Number of low vulnerabilities in the enforcers that in this enforcer group.
        /// </summary>
        [Output("lowVulns")]
        public Output<int> LowVulns { get; private set; } = null!;

        /// <summary>
        /// Number of medium vulnerabilities in the enforcers that in this enforcer group.
        /// </summary>
        [Output("medVulns")]
        public Output<int> MedVulns { get; private set; } = null!;

        /// <summary>
        /// This option is applicable only if `Enable Pod Enforcer injection` is selected.
        /// </summary>
        [Output("microEnforcerCertsSecretsName")]
        public Output<string?> MicroEnforcerCertsSecretsName { get; private set; } = null!;

        /// <summary>
        /// This option is applicable only if `Enable Pod Enforcer injection` is selected. This field specifies the path and file name of the KubeEnforcer product image to be deployed; it will be filled in automatically. You can optionally enter a different value.
        /// </summary>
        [Output("microEnforcerImageName")]
        public Output<string> MicroEnforcerImageName { get; private set; } = null!;

        /// <summary>
        /// This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
        /// </summary>
        [Output("microEnforcerInjection")]
        public Output<bool?> MicroEnforcerInjection { get; private set; } = null!;

        /// <summary>
        /// You can specify the name of the secret (in the Aqua namespace) that Aqua copies into the Pod Enforcer namespace and kube-bench, allowing them access to the Pod Enforcer and kube-bench product images, respectively.
        /// </summary>
        [Output("microEnforcerSecretsName")]
        public Output<string> MicroEnforcerSecretsName { get; private set; } = null!;

        /// <summary>
        /// Number of negligible vulnerabilities in the enforcers that in this enforcer group.
        /// </summary>
        [Output("negVulns")]
        public Output<int> NegVulns { get; private set; } = null!;

        /// <summary>
        /// Send true to apply Firewall Policies to containers, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information.
        /// </summary>
        [Output("networkProtection")]
        public Output<bool?> NetworkProtection { get; private set; } = null!;

        /// <summary>
        /// The orchestrator for which you are creating the Enforcer group.
        /// </summary>
        [Output("orchestrators")]
        public Output<ImmutableArray<Outputs.EnforcerGroupsOrchestrator>> Orchestrators { get; private set; } = null!;

        /// <summary>
        /// pas deployment link
        /// </summary>
        [Output("pasDeploymentLink")]
        public Output<string> PasDeploymentLink { get; private set; } = null!;

        /// <summary>
        /// Permission Action
        /// </summary>
        [Output("permission")]
        public Output<string?> Permission { get; private set; } = null!;

        /// <summary>
        /// Set `True` to allow Enforcers to be discovered in the Risk Explorer.
        /// </summary>
        [Output("riskExplorerAutoDiscovery")]
        public Output<bool?> RiskExplorerAutoDiscovery { get; private set; } = null!;

        /// <summary>
        /// Function Runtime Policy that will applay on the nano enforcer.
        /// </summary>
        [Output("runtimePolicyName")]
        public Output<string> RuntimePolicyName { get; private set; } = null!;

        /// <summary>
        /// The container runtime environment.
        /// </summary>
        [Output("runtimeType")]
        public Output<string> RuntimeType { get; private set; } = null!;

        /// <summary>
        /// Set `True` to configure Enforcers to discover local host images. Discovered images will be listed under Images &gt; Host Images, as well as under Infrastructure (in the Images tab for applicable hosts).
        /// </summary>
        [Output("syncHostImages")]
        public Output<bool?> SyncHostImages { get; private set; } = null!;

        /// <summary>
        /// Set `True` will allow profiling and monitoring system calls made by running containers.
        /// </summary>
        [Output("syscallEnabled")]
        public Output<bool?> SyscallEnabled { get; private set; } = null!;

        /// <summary>
        /// The batch install token.
        /// </summary>
        [Output("token")]
        public Output<string> Token { get; private set; } = null!;

        /// <summary>
        /// Enforcer Type.
        /// </summary>
        [Output("type")]
        public Output<string> Type { get; private set; } = null!;

        /// <summary>
        /// Set `True` to apply User Access Control Policies to containers. Note that Aqua Enforcers must be deployed with the AQUA*RUNC*INTERCEPTION environment variable set to 0 in order to use User Access Control Policies.
        /// </summary>
        [Output("userAccessControl")]
        public Output<bool?> UserAccessControl { get; private set; } = null!;


        /// <summary>
        /// Create a EnforcerGroups resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public EnforcerGroups(string name, EnforcerGroupsArgs args, CustomResourceOptions? options = null)
            : base("aquasec:index/enforcerGroups:EnforcerGroups", name, args ?? new EnforcerGroupsArgs(), MakeResourceOptions(options, ""))
        {
        }

        private EnforcerGroups(string name, Input<string> id, EnforcerGroupsState? state = null, CustomResourceOptions? options = null)
            : base("aquasec:index/enforcerGroups:EnforcerGroups", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/pulumiverse/pulumi-aquasec",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing EnforcerGroups resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static EnforcerGroups Get(string name, Input<string> id, EnforcerGroupsState? state = null, CustomResourceOptions? options = null)
        {
            return new EnforcerGroups(name, id, state, options);
        }
    }

    public sealed class EnforcerGroupsArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Selecting this option will allow the KubeEnforcer to block the deployment of container images that have failed any of these Container Runtime Policy controls:\
        /// 			* Block Non-Compliant Images\
        /// 			* Block Non-Compliant Workloads\
        /// 			* Block Unregistered Images\
        /// 			This functionality can work only when the KubeEnforcer is deployed in Enforce mode.
        /// </summary>
        [Input("admissionControl")]
        public Input<bool>? AdmissionControl { get; set; }

        /// <summary>
        /// Allow kube enforcer audit.
        /// </summary>
        [Input("allowKubeEnforcerAudit")]
        public Input<bool>? AllowKubeEnforcerAudit { get; set; }

        [Input("allowedApplications")]
        private InputList<string>? _allowedApplications;

        /// <summary>
        /// List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
        /// </summary>
        public InputList<string> AllowedApplications
        {
            get => _allowedApplications ?? (_allowedApplications = new InputList<string>());
            set => _allowedApplications = value;
        }

        [Input("allowedLabels")]
        private InputList<string>? _allowedLabels;

        /// <summary>
        /// List of label names to allow on the hosts.
        /// </summary>
        public InputList<string> AllowedLabels
        {
            get => _allowedLabels ?? (_allowedLabels = new InputList<string>());
            set => _allowedLabels = value;
        }

        [Input("allowedRegistries")]
        private InputList<string>? _allowedRegistries;

        /// <summary>
        /// List of registry names to allow on the hosts.
        /// </summary>
        public InputList<string> AllowedRegistries
        {
            get => _allowedRegistries ?? (_allowedRegistries = new InputList<string>());
            set => _allowedRegistries = value;
        }

        /// <summary>
        /// This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Host Runtime policies.
        /// </summary>
        [Input("antivirusProtection")]
        public Input<bool>? AntivirusProtection { get; set; }

        /// <summary>
        /// Agent will send extra audit messages to the server for success operations from inside the container (runtime).
        /// </summary>
        [Input("auditAll")]
        public Input<bool>? AuditAll { get; set; }

        /// <summary>
        /// This option is applicable only if `Enable Pod Enforcer injection` is selected. Select this option if you want Aqua Enterprise to copy the secrets defined above to the Pod Enforcer namespace and container. Otherwise, you can choose to copy these secrets by other means.
        /// </summary>
        [Input("autoCopySecrets")]
        public Input<bool>? AutoCopySecrets { get; set; }

        /// <summary>
        /// This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will add previously unknown image registries from the cluster to Aqua.
        /// </summary>
        [Input("autoDiscoverConfigureRegistries")]
        public Input<bool>? AutoDiscoverConfigureRegistries { get; set; }

        /// <summary>
        /// When this option is selected, the KubeEnforcer will discover workloads on its cluster.
        /// </summary>
        [Input("autoDiscoveryEnabled")]
        public Input<bool>? AutoDiscoveryEnabled { get; set; }

        /// <summary>
        /// This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will automatically register images running as workloads (and scan the discovered images for security issues).
        /// </summary>
        [Input("autoScanDiscoveredImagesRunningContainers")]
        public Input<bool>? AutoScanDiscoveredImagesRunningContainers { get; set; }

        /// <summary>
        /// Select Enabled to detect suspicious activity in your containers and display potential security threats in the Incidents and Audit pages.
        /// </summary>
        [Input("behavioralEngine")]
        public Input<bool>? BehavioralEngine { get; set; }

        /// <summary>
        /// This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
        /// </summary>
        [Input("blockAdmissionControl")]
        public Input<bool>? BlockAdmissionControl { get; set; }

        /// <summary>
        /// Set `True` to apply Container Runtime Policies, Image Profiles, and Firewall Policies to containers.
        /// </summary>
        [Input("containerActivityProtection")]
        public Input<bool>? ContainerActivityProtection { get; set; }

        /// <summary>
        /// This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Container Runtime policies.
        /// </summary>
        [Input("containerAntivirusProtection")]
        public Input<bool>? ContainerAntivirusProtection { get; set; }

        /// <summary>
        /// A description of the Aqua Enforcer group.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Whether to enable enforce mode on the Enforcers, defaults to False.
        /// </summary>
        [Input("enforce")]
        public Input<bool>? Enforce { get; set; }

        /// <summary>
        /// Select Enabled to send activity logs in your containers to the Aqua Server for forensics purposes.
        /// </summary>
        [Input("forensics")]
        public Input<bool>? Forensics { get; set; }

        [Input("gateways")]
        private InputList<string>? _gateways;

        /// <summary>
        /// List of Aqua gateway IDs for the Enforcers.
        /// </summary>
        public InputList<string> Gateways
        {
            get => _gateways ?? (_gateways = new InputList<string>());
            set => _gateways = value;
        }

        /// <summary>
        /// The ID of the Enforcer group.
        /// </summary>
        [Input("groupId", required: true)]
        public Input<string> GroupId { get; set; } = null!;

        /// <summary>
        /// Set `True` to enable host scanning and respective Host Assurance controls.
        /// </summary>
        [Input("hostAssurance")]
        public Input<bool>? HostAssurance { get; set; }

        /// <summary>
        /// Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
        /// </summary>
        [Input("hostBehavioralEngine")]
        public Input<bool>? HostBehavioralEngine { get; set; }

        /// <summary>
        /// Select Enabled to send activity logs in your host to the Aqua Server for forensics purposes.
        /// </summary>
        [Input("hostForensics")]
        public Input<bool>? HostForensics { get; set; }

        /// <summary>
        /// Set `True` to apply Firewall Policies to hosts, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information
        /// </summary>
        [Input("hostNetworkProtection")]
        public Input<bool>? HostNetworkProtection { get; set; }

        /// <summary>
        /// The OS type for the host
        /// </summary>
        [Input("hostOs")]
        public Input<string>? HostOs { get; set; }

        /// <summary>
        /// Set `True` to enable all Host Runtime Policy controls except for `OS Users and Groups Allowed` and `OS Users and Groups Blocked`.
        /// </summary>
        [Input("hostProtection")]
        public Input<bool>? HostProtection { get; set; }

        /// <summary>
        /// Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
        /// </summary>
        [Input("hostUserProtection")]
        public Input<bool>? HostUserProtection { get; set; }

        /// <summary>
        /// Set `True` to enable selected controls: Container Runtime Policy (`Block Non-Compliant Images`, `Block Unregistered Images`, and `Registries Allowed`) and Default Image Assurance Policy (`Images Blocked`).
        /// </summary>
        [Input("imageAssurance")]
        public Input<bool>? ImageAssurance { get; set; }

        /// <summary>
        /// See https://docs.aquasec.com/docs/securing-kubernetes-applications#section-configuration-hardening, The KubeEnforcer can deploy the Aqua Security kube-bench open-source product to perform Kubernetes CIS benchmark testing of nodes.
        /// 			This field specifies the path and file name of the kube-bench product image for the KubeEnforcer to deploy; it will be filled in automatically. You can optionally enter a different value.
        /// </summary>
        [Input("kubeBenchImageName")]
        public Input<string>? KubeBenchImageName { get; set; }

        /// <summary>
        /// Name for the batch install record.
        /// </summary>
        [Input("logicalName")]
        public Input<string>? LogicalName { get; set; }

        /// <summary>
        /// This option is applicable only if `Enable Pod Enforcer injection` is selected.
        /// </summary>
        [Input("microEnforcerCertsSecretsName")]
        public Input<string>? MicroEnforcerCertsSecretsName { get; set; }

        /// <summary>
        /// This option is applicable only if `Enable Pod Enforcer injection` is selected. This field specifies the path and file name of the KubeEnforcer product image to be deployed; it will be filled in automatically. You can optionally enter a different value.
        /// </summary>
        [Input("microEnforcerImageName")]
        public Input<string>? MicroEnforcerImageName { get; set; }

        /// <summary>
        /// This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
        /// </summary>
        [Input("microEnforcerInjection")]
        public Input<bool>? MicroEnforcerInjection { get; set; }

        /// <summary>
        /// You can specify the name of the secret (in the Aqua namespace) that Aqua copies into the Pod Enforcer namespace and kube-bench, allowing them access to the Pod Enforcer and kube-bench product images, respectively.
        /// </summary>
        [Input("microEnforcerSecretsName")]
        public Input<string>? MicroEnforcerSecretsName { get; set; }

        /// <summary>
        /// Send true to apply Firewall Policies to containers, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information.
        /// </summary>
        [Input("networkProtection")]
        public Input<bool>? NetworkProtection { get; set; }

        [Input("orchestrators", required: true)]
        private InputList<Inputs.EnforcerGroupsOrchestratorArgs>? _orchestrators;

        /// <summary>
        /// The orchestrator for which you are creating the Enforcer group.
        /// </summary>
        public InputList<Inputs.EnforcerGroupsOrchestratorArgs> Orchestrators
        {
            get => _orchestrators ?? (_orchestrators = new InputList<Inputs.EnforcerGroupsOrchestratorArgs>());
            set => _orchestrators = value;
        }

        /// <summary>
        /// Permission Action
        /// </summary>
        [Input("permission")]
        public Input<string>? Permission { get; set; }

        /// <summary>
        /// Set `True` to allow Enforcers to be discovered in the Risk Explorer.
        /// </summary>
        [Input("riskExplorerAutoDiscovery")]
        public Input<bool>? RiskExplorerAutoDiscovery { get; set; }

        /// <summary>
        /// The container runtime environment.
        /// </summary>
        [Input("runtimeType")]
        public Input<string>? RuntimeType { get; set; }

        /// <summary>
        /// Set `True` to configure Enforcers to discover local host images. Discovered images will be listed under Images &gt; Host Images, as well as under Infrastructure (in the Images tab for applicable hosts).
        /// </summary>
        [Input("syncHostImages")]
        public Input<bool>? SyncHostImages { get; set; }

        /// <summary>
        /// Set `True` will allow profiling and monitoring system calls made by running containers.
        /// </summary>
        [Input("syscallEnabled")]
        public Input<bool>? SyscallEnabled { get; set; }

        /// <summary>
        /// Enforcer Type.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Set `True` to apply User Access Control Policies to containers. Note that Aqua Enforcers must be deployed with the AQUA*RUNC*INTERCEPTION environment variable set to 0 in order to use User Access Control Policies.
        /// </summary>
        [Input("userAccessControl")]
        public Input<bool>? UserAccessControl { get; set; }

        public EnforcerGroupsArgs()
        {
        }
        public static new EnforcerGroupsArgs Empty => new EnforcerGroupsArgs();
    }

    public sealed class EnforcerGroupsState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Selecting this option will allow the KubeEnforcer to block the deployment of container images that have failed any of these Container Runtime Policy controls:\
        /// 			* Block Non-Compliant Images\
        /// 			* Block Non-Compliant Workloads\
        /// 			* Block Unregistered Images\
        /// 			This functionality can work only when the KubeEnforcer is deployed in Enforce mode.
        /// </summary>
        [Input("admissionControl")]
        public Input<bool>? AdmissionControl { get; set; }

        /// <summary>
        /// Allow kube enforcer audit.
        /// </summary>
        [Input("allowKubeEnforcerAudit")]
        public Input<bool>? AllowKubeEnforcerAudit { get; set; }

        [Input("allowedApplications")]
        private InputList<string>? _allowedApplications;

        /// <summary>
        /// List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
        /// </summary>
        public InputList<string> AllowedApplications
        {
            get => _allowedApplications ?? (_allowedApplications = new InputList<string>());
            set => _allowedApplications = value;
        }

        [Input("allowedLabels")]
        private InputList<string>? _allowedLabels;

        /// <summary>
        /// List of label names to allow on the hosts.
        /// </summary>
        public InputList<string> AllowedLabels
        {
            get => _allowedLabels ?? (_allowedLabels = new InputList<string>());
            set => _allowedLabels = value;
        }

        [Input("allowedRegistries")]
        private InputList<string>? _allowedRegistries;

        /// <summary>
        /// List of registry names to allow on the hosts.
        /// </summary>
        public InputList<string> AllowedRegistries
        {
            get => _allowedRegistries ?? (_allowedRegistries = new InputList<string>());
            set => _allowedRegistries = value;
        }

        /// <summary>
        /// This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Host Runtime policies.
        /// </summary>
        [Input("antivirusProtection")]
        public Input<bool>? AntivirusProtection { get; set; }

        /// <summary>
        /// Aqua server version
        /// </summary>
        [Input("aquaVersion")]
        public Input<string>? AquaVersion { get; set; }

        /// <summary>
        /// Agent will send extra audit messages to the server for success operations from inside the container (runtime).
        /// </summary>
        [Input("auditAll")]
        public Input<bool>? AuditAll { get; set; }

        /// <summary>
        /// This option is applicable only if `Enable Pod Enforcer injection` is selected. Select this option if you want Aqua Enterprise to copy the secrets defined above to the Pod Enforcer namespace and container. Otherwise, you can choose to copy these secrets by other means.
        /// </summary>
        [Input("autoCopySecrets")]
        public Input<bool>? AutoCopySecrets { get; set; }

        /// <summary>
        /// This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will add previously unknown image registries from the cluster to Aqua.
        /// </summary>
        [Input("autoDiscoverConfigureRegistries")]
        public Input<bool>? AutoDiscoverConfigureRegistries { get; set; }

        /// <summary>
        /// When this option is selected, the KubeEnforcer will discover workloads on its cluster.
        /// </summary>
        [Input("autoDiscoveryEnabled")]
        public Input<bool>? AutoDiscoveryEnabled { get; set; }

        /// <summary>
        /// This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will automatically register images running as workloads (and scan the discovered images for security issues).
        /// </summary>
        [Input("autoScanDiscoveredImagesRunningContainers")]
        public Input<bool>? AutoScanDiscoveredImagesRunningContainers { get; set; }

        /// <summary>
        /// Select Enabled to detect suspicious activity in your containers and display potential security threats in the Incidents and Audit pages.
        /// </summary>
        [Input("behavioralEngine")]
        public Input<bool>? BehavioralEngine { get; set; }

        /// <summary>
        /// This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
        /// </summary>
        [Input("blockAdmissionControl")]
        public Input<bool>? BlockAdmissionControl { get; set; }

        [Input("commands")]
        private InputList<Inputs.EnforcerGroupsCommandGetArgs>? _commands;

        /// <summary>
        /// The installation command.
        /// </summary>
        public InputList<Inputs.EnforcerGroupsCommandGetArgs> Commands
        {
            get => _commands ?? (_commands = new InputList<Inputs.EnforcerGroupsCommandGetArgs>());
            set => _commands = value;
        }

        /// <summary>
        /// Number of connected enforcers in the enforcer group.
        /// </summary>
        [Input("connectedCount")]
        public Input<int>? ConnectedCount { get; set; }

        /// <summary>
        /// Set `True` to apply Container Runtime Policies, Image Profiles, and Firewall Policies to containers.
        /// </summary>
        [Input("containerActivityProtection")]
        public Input<bool>? ContainerActivityProtection { get; set; }

        /// <summary>
        /// This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Container Runtime policies.
        /// </summary>
        [Input("containerAntivirusProtection")]
        public Input<bool>? ContainerAntivirusProtection { get; set; }

        /// <summary>
        /// A description of the Aqua Enforcer group.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Number of disconnected enforcers in the enforcer group.
        /// </summary>
        [Input("disconnectedCount")]
        public Input<int>? DisconnectedCount { get; set; }

        /// <summary>
        /// Whether to enable enforce mode on the Enforcers, defaults to False.
        /// </summary>
        [Input("enforce")]
        public Input<bool>? Enforce { get; set; }

        /// <summary>
        /// The specific Aqua Enforcer product image (with image tag) to be deployed.
        /// </summary>
        [Input("enforcerImageName")]
        public Input<string>? EnforcerImageName { get; set; }

        /// <summary>
        /// Select Enabled to send activity logs in your containers to the Aqua Server for forensics purposes.
        /// </summary>
        [Input("forensics")]
        public Input<bool>? Forensics { get; set; }

        /// <summary>
        /// Gateway Address
        /// </summary>
        [Input("gatewayAddress")]
        public Input<string>? GatewayAddress { get; set; }

        /// <summary>
        /// Gateway Name
        /// </summary>
        [Input("gatewayName")]
        public Input<string>? GatewayName { get; set; }

        [Input("gateways")]
        private InputList<string>? _gateways;

        /// <summary>
        /// List of Aqua gateway IDs for the Enforcers.
        /// </summary>
        public InputList<string> Gateways
        {
            get => _gateways ?? (_gateways = new InputList<string>());
            set => _gateways = value;
        }

        /// <summary>
        /// The ID of the Enforcer group.
        /// </summary>
        [Input("groupId")]
        public Input<string>? GroupId { get; set; }

        /// <summary>
        /// Number of high vulnerabilities in the enforcers that in this enforcer group.
        /// </summary>
        [Input("highVulns")]
        public Input<int>? HighVulns { get; set; }

        /// <summary>
        /// Set `True` to enable host scanning and respective Host Assurance controls.
        /// </summary>
        [Input("hostAssurance")]
        public Input<bool>? HostAssurance { get; set; }

        /// <summary>
        /// Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
        /// </summary>
        [Input("hostBehavioralEngine")]
        public Input<bool>? HostBehavioralEngine { get; set; }

        /// <summary>
        /// Select Enabled to send activity logs in your host to the Aqua Server for forensics purposes.
        /// </summary>
        [Input("hostForensics")]
        public Input<bool>? HostForensics { get; set; }

        /// <summary>
        /// Set `True` to apply Firewall Policies to hosts, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information
        /// </summary>
        [Input("hostNetworkProtection")]
        public Input<bool>? HostNetworkProtection { get; set; }

        /// <summary>
        /// The OS type for the host
        /// </summary>
        [Input("hostOs")]
        public Input<string>? HostOs { get; set; }

        /// <summary>
        /// Set `True` to enable all Host Runtime Policy controls except for `OS Users and Groups Allowed` and `OS Users and Groups Blocked`.
        /// </summary>
        [Input("hostProtection")]
        public Input<bool>? HostProtection { get; set; }

        /// <summary>
        /// Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
        /// </summary>
        [Input("hostUserProtection")]
        public Input<bool>? HostUserProtection { get; set; }

        /// <summary>
        /// The hostname
        /// </summary>
        [Input("hostname")]
        public Input<string>? Hostname { get; set; }

        /// <summary>
        /// Number of enforcers in the enforcer group.
        /// </summary>
        [Input("hostsCount")]
        public Input<int>? HostsCount { get; set; }

        /// <summary>
        /// Set `True` to enable selected controls: Container Runtime Policy (`Block Non-Compliant Images`, `Block Unregistered Images`, and `Registries Allowed`) and Default Image Assurance Policy (`Images Blocked`).
        /// </summary>
        [Input("imageAssurance")]
        public Input<bool>? ImageAssurance { get; set; }

        /// <summary>
        /// Enforcer install command
        /// </summary>
        [Input("installCommand")]
        public Input<string>? InstallCommand { get; set; }

        /// <summary>
        /// See https://docs.aquasec.com/docs/securing-kubernetes-applications#section-configuration-hardening, The KubeEnforcer can deploy the Aqua Security kube-bench open-source product to perform Kubernetes CIS benchmark testing of nodes.
        /// 			This field specifies the path and file name of the kube-bench product image for the KubeEnforcer to deploy; it will be filled in automatically. You can optionally enter a different value.
        /// </summary>
        [Input("kubeBenchImageName")]
        public Input<string>? KubeBenchImageName { get; set; }

        /// <summary>
        /// The last date and time the batch token was updated in UNIX time.
        /// </summary>
        [Input("lastUpdate")]
        public Input<int>? LastUpdate { get; set; }

        /// <summary>
        /// Name for the batch install record.
        /// </summary>
        [Input("logicalName")]
        public Input<string>? LogicalName { get; set; }

        /// <summary>
        /// Number of low vulnerabilities in the enforcers that in this enforcer group.
        /// </summary>
        [Input("lowVulns")]
        public Input<int>? LowVulns { get; set; }

        /// <summary>
        /// Number of medium vulnerabilities in the enforcers that in this enforcer group.
        /// </summary>
        [Input("medVulns")]
        public Input<int>? MedVulns { get; set; }

        /// <summary>
        /// This option is applicable only if `Enable Pod Enforcer injection` is selected.
        /// </summary>
        [Input("microEnforcerCertsSecretsName")]
        public Input<string>? MicroEnforcerCertsSecretsName { get; set; }

        /// <summary>
        /// This option is applicable only if `Enable Pod Enforcer injection` is selected. This field specifies the path and file name of the KubeEnforcer product image to be deployed; it will be filled in automatically. You can optionally enter a different value.
        /// </summary>
        [Input("microEnforcerImageName")]
        public Input<string>? MicroEnforcerImageName { get; set; }

        /// <summary>
        /// This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
        /// </summary>
        [Input("microEnforcerInjection")]
        public Input<bool>? MicroEnforcerInjection { get; set; }

        /// <summary>
        /// You can specify the name of the secret (in the Aqua namespace) that Aqua copies into the Pod Enforcer namespace and kube-bench, allowing them access to the Pod Enforcer and kube-bench product images, respectively.
        /// </summary>
        [Input("microEnforcerSecretsName")]
        public Input<string>? MicroEnforcerSecretsName { get; set; }

        /// <summary>
        /// Number of negligible vulnerabilities in the enforcers that in this enforcer group.
        /// </summary>
        [Input("negVulns")]
        public Input<int>? NegVulns { get; set; }

        /// <summary>
        /// Send true to apply Firewall Policies to containers, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information.
        /// </summary>
        [Input("networkProtection")]
        public Input<bool>? NetworkProtection { get; set; }

        [Input("orchestrators")]
        private InputList<Inputs.EnforcerGroupsOrchestratorGetArgs>? _orchestrators;

        /// <summary>
        /// The orchestrator for which you are creating the Enforcer group.
        /// </summary>
        public InputList<Inputs.EnforcerGroupsOrchestratorGetArgs> Orchestrators
        {
            get => _orchestrators ?? (_orchestrators = new InputList<Inputs.EnforcerGroupsOrchestratorGetArgs>());
            set => _orchestrators = value;
        }

        /// <summary>
        /// pas deployment link
        /// </summary>
        [Input("pasDeploymentLink")]
        public Input<string>? PasDeploymentLink { get; set; }

        /// <summary>
        /// Permission Action
        /// </summary>
        [Input("permission")]
        public Input<string>? Permission { get; set; }

        /// <summary>
        /// Set `True` to allow Enforcers to be discovered in the Risk Explorer.
        /// </summary>
        [Input("riskExplorerAutoDiscovery")]
        public Input<bool>? RiskExplorerAutoDiscovery { get; set; }

        /// <summary>
        /// Function Runtime Policy that will applay on the nano enforcer.
        /// </summary>
        [Input("runtimePolicyName")]
        public Input<string>? RuntimePolicyName { get; set; }

        /// <summary>
        /// The container runtime environment.
        /// </summary>
        [Input("runtimeType")]
        public Input<string>? RuntimeType { get; set; }

        /// <summary>
        /// Set `True` to configure Enforcers to discover local host images. Discovered images will be listed under Images &gt; Host Images, as well as under Infrastructure (in the Images tab for applicable hosts).
        /// </summary>
        [Input("syncHostImages")]
        public Input<bool>? SyncHostImages { get; set; }

        /// <summary>
        /// Set `True` will allow profiling and monitoring system calls made by running containers.
        /// </summary>
        [Input("syscallEnabled")]
        public Input<bool>? SyscallEnabled { get; set; }

        /// <summary>
        /// The batch install token.
        /// </summary>
        [Input("token")]
        public Input<string>? Token { get; set; }

        /// <summary>
        /// Enforcer Type.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        /// <summary>
        /// Set `True` to apply User Access Control Policies to containers. Note that Aqua Enforcers must be deployed with the AQUA*RUNC*INTERCEPTION environment variable set to 0 in order to use User Access Control Policies.
        /// </summary>
        [Input("userAccessControl")]
        public Input<bool>? UserAccessControl { get; set; }

        public EnforcerGroupsState()
        {
        }
        public static new EnforcerGroupsState Empty => new EnforcerGroupsState();
    }
}
