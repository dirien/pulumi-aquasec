// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Pulumiverse.Aquasec
{
    /// <summary>
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using Pulumi;
    /// using Aquasec = Pulumiverse.Aquasec;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var hostRuntimePolicy = new Aquasec.HostRuntimePolicy("hostRuntimePolicy", new()
    ///     {
    ///         AuditAllOsUserActivity = true,
    ///         AuditBruteForceLogin = true,
    ///         AuditFullCommandArguments = true,
    ///         AuditHostFailedLoginEvents = true,
    ///         AuditHostSuccessfulLoginEvents = true,
    ///         AuditUserAccountManagement = true,
    ///         BlockCryptocurrencyMining = true,
    ///         BlockedFiles = new[]
    ///         {
    ///             "blocked",
    ///         },
    ///         Description = "host_runtime_policy",
    ///         EnableIpReputationSecurity = true,
    ///         Enabled = true,
    ///         Enforce = false,
    ///         FileIntegrityMonitoring = new Aquasec.Inputs.HostRuntimePolicyFileIntegrityMonitoringArgs
    ///         {
    ///             ExcludedPaths = new[]
    ///             {
    ///                 "expaths",
    ///             },
    ///             ExcludedProcesses = new[]
    ///             {
    ///                 "exprocess",
    ///             },
    ///             ExcludedUsers = new[]
    ///             {
    ///                 "expuser",
    ///             },
    ///             MonitorAttributes = true,
    ///             MonitorCreate = true,
    ///             MonitorDelete = true,
    ///             MonitorModify = true,
    ///             MonitorRead = true,
    ///             MonitoredPaths = new[]
    ///             {
    ///                 "paths",
    ///             },
    ///             MonitoredProcesses = new[]
    ///             {
    ///                 "process",
    ///             },
    ///             MonitoredUsers = new[]
    ///             {
    ///                 "user",
    ///             },
    ///         },
    ///         MonitorSystemLogIntegrity = true,
    ///         MonitorSystemTimeChanges = true,
    ///         MonitorWindowsServices = true,
    ///         OsGroupsAlloweds = new[]
    ///         {
    ///             "group1",
    ///         },
    ///         OsGroupsBlockeds = new[]
    ///         {
    ///             "group2",
    ///         },
    ///         OsUsersAlloweds = new[]
    ///         {
    ///             "user1",
    ///         },
    ///         OsUsersBlockeds = new[]
    ///         {
    ///             "user2",
    ///         },
    ///         PackageBlocks = new[]
    ///         {
    ///             "package1",
    ///         },
    ///         PortScanningDetection = true,
    ///         WindowsRegistryMonitoring = new Aquasec.Inputs.HostRuntimePolicyWindowsRegistryMonitoringArgs
    ///         {
    ///             ExcludedPaths = new[]
    ///             {
    ///                 "expaths",
    ///             },
    ///             ExcludedProcesses = new[]
    ///             {
    ///                 "exprocess",
    ///             },
    ///             ExcludedUsers = new[]
    ///             {
    ///                 "expuser",
    ///             },
    ///             MonitorAttributes = true,
    ///             MonitorCreate = true,
    ///             MonitorDelete = true,
    ///             MonitorModify = true,
    ///             MonitorRead = true,
    ///             MonitoredPaths = new[]
    ///             {
    ///                 "paths",
    ///             },
    ///             MonitoredProcesses = new[]
    ///             {
    ///                 "process",
    ///             },
    ///             MonitoredUsers = new[]
    ///             {
    ///                 "user",
    ///             },
    ///         },
    ///         WindowsRegistryProtection = new Aquasec.Inputs.HostRuntimePolicyWindowsRegistryProtectionArgs
    ///         {
    ///             ExcludedPaths = new[]
    ///             {
    ///                 "expaths",
    ///             },
    ///             ExcludedProcesses = new[]
    ///             {
    ///                 "exprocess",
    ///             },
    ///             ExcludedUsers = new[]
    ///             {
    ///                 "expuser",
    ///             },
    ///             ProtectedPaths = new[]
    ///             {
    ///                 "paths",
    ///             },
    ///             ProtectedProcesses = new[]
    ///             {
    ///                 "process",
    ///             },
    ///             ProtectedUsers = new[]
    ///             {
    ///                 "user",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// </summary>
    [AquasecResourceType("aquasec:index/hostRuntimePolicy:HostRuntimePolicy")]
    public partial class HostRuntimePolicy : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Indicates the application scope of the service.
        /// </summary>
        [Output("applicationScopes")]
        public Output<ImmutableArray<string>> ApplicationScopes { get; private set; } = null!;

        /// <summary>
        /// If true, all process activity will be audited.
        /// </summary>
        [Output("auditAllOsUserActivity")]
        public Output<bool?> AuditAllOsUserActivity { get; private set; } = null!;

        /// <summary>
        /// Detects brute force login attempts
        /// </summary>
        [Output("auditBruteForceLogin")]
        public Output<bool?> AuditBruteForceLogin { get; private set; } = null!;

        /// <summary>
        /// If true, full command arguments will be audited.
        /// </summary>
        [Output("auditFullCommandArguments")]
        public Output<bool?> AuditFullCommandArguments { get; private set; } = null!;

        /// <summary>
        /// If true, host failed logins will be audited.
        /// </summary>
        [Output("auditHostFailedLoginEvents")]
        public Output<bool?> AuditHostFailedLoginEvents { get; private set; } = null!;

        /// <summary>
        /// If true, host successful logins will be audited.
        /// </summary>
        [Output("auditHostSuccessfulLoginEvents")]
        public Output<bool?> AuditHostSuccessfulLoginEvents { get; private set; } = null!;

        /// <summary>
        /// If true, account management will be audited.
        /// </summary>
        [Output("auditUserAccountManagement")]
        public Output<bool?> AuditUserAccountManagement { get; private set; } = null!;

        /// <summary>
        /// Username of the account that created the service.
        /// </summary>
        [Output("author")]
        public Output<string> Author { get; private set; } = null!;

        /// <summary>
        /// Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
        /// </summary>
        [Output("blockCryptocurrencyMining")]
        public Output<bool?> BlockCryptocurrencyMining { get; private set; } = null!;

        /// <summary>
        /// List of files that are prevented from being read, modified and executed in the containers.
        /// </summary>
        [Output("blockedFiles")]
        public Output<ImmutableArray<string>> BlockedFiles { get; private set; } = null!;

        /// <summary>
        /// The description of the host runtime policy
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// If true, detect and prevent communication from containers to IP addresses known to have a bad reputation.
        /// </summary>
        [Output("enableIpReputationSecurity")]
        public Output<bool?> EnableIpReputationSecurity { get; private set; } = null!;

        /// <summary>
        /// Indicates if the runtime policy is enabled or not.
        /// </summary>
        [Output("enabled")]
        public Output<bool?> Enabled { get; private set; } = null!;

        /// <summary>
        /// Indicates that policy should effect container execution (not just for audit).
        /// </summary>
        [Output("enforce")]
        public Output<bool?> Enforce { get; private set; } = null!;

        /// <summary>
        /// Indicates the number of days after which the runtime policy will be changed to enforce mode.
        /// </summary>
        [Output("enforceAfterDays")]
        public Output<int?> EnforceAfterDays { get; private set; } = null!;

        /// <summary>
        /// Configuration for file integrity monitoring.
        /// </summary>
        [Output("fileIntegrityMonitoring")]
        public Output<Outputs.HostRuntimePolicyFileIntegrityMonitoring?> FileIntegrityMonitoring { get; private set; } = null!;

        /// <summary>
        /// If true, system log will be monitored.
        /// </summary>
        [Output("monitorSystemLogIntegrity")]
        public Output<bool?> MonitorSystemLogIntegrity { get; private set; } = null!;

        /// <summary>
        /// If true, system time changes will be monitored.
        /// </summary>
        [Output("monitorSystemTimeChanges")]
        public Output<bool?> MonitorSystemTimeChanges { get; private set; } = null!;

        /// <summary>
        /// If true, windows service operations will be monitored.
        /// </summary>
        [Output("monitorWindowsServices")]
        public Output<bool?> MonitorWindowsServices { get; private set; } = null!;

        /// <summary>
        /// Name of the host runtime policy
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// List of OS (Linux or Windows) groups that are allowed to authenticate to the host, and block authentication requests from all others. Groups can be either Linux groups or Windows AD groups.
        /// </summary>
        [Output("osGroupsAlloweds")]
        public Output<ImmutableArray<string>> OsGroupsAlloweds { get; private set; } = null!;

        /// <summary>
        /// List of OS (Linux or Windows) groups that are not allowed to authenticate to the host, and block authentication requests from all others. Groups can be either Linux groups or Windows AD groups.
        /// </summary>
        [Output("osGroupsBlockeds")]
        public Output<ImmutableArray<string>> OsGroupsBlockeds { get; private set; } = null!;

        /// <summary>
        /// List of OS (Linux or Windows) users that are allowed to authenticate to the host, and block authentication requests from all others.
        /// </summary>
        [Output("osUsersAlloweds")]
        public Output<ImmutableArray<string>> OsUsersAlloweds { get; private set; } = null!;

        /// <summary>
        /// List of OS (Linux or Windows) users that are not allowed to authenticate to the host, and block authentication requests from all others.
        /// </summary>
        [Output("osUsersBlockeds")]
        public Output<ImmutableArray<string>> OsUsersBlockeds { get; private set; } = null!;

        /// <summary>
        /// List of packages that are not allowed read, write or execute all files that under the packages.
        /// </summary>
        [Output("packageBlocks")]
        public Output<ImmutableArray<string>> PackageBlocks { get; private set; } = null!;

        /// <summary>
        /// If true, port scanning behaviors will be audited.
        /// </summary>
        [Output("portScanningDetection")]
        public Output<bool?> PortScanningDetection { get; private set; } = null!;

        /// <summary>
        /// Logical expression of how to compute the dependency of the scope variables.
        /// </summary>
        [Output("scopeExpression")]
        public Output<string> ScopeExpression { get; private set; } = null!;

        /// <summary>
        /// List of scope attributes.
        /// </summary>
        [Output("scopeVariables")]
        public Output<ImmutableArray<Outputs.HostRuntimePolicyScopeVariable>> ScopeVariables { get; private set; } = null!;

        /// <summary>
        /// Configuration for windows registry monitoring.
        /// </summary>
        [Output("windowsRegistryMonitoring")]
        public Output<Outputs.HostRuntimePolicyWindowsRegistryMonitoring?> WindowsRegistryMonitoring { get; private set; } = null!;

        /// <summary>
        /// Configuration for windows registry protection.
        /// </summary>
        [Output("windowsRegistryProtection")]
        public Output<Outputs.HostRuntimePolicyWindowsRegistryProtection?> WindowsRegistryProtection { get; private set; } = null!;


        /// <summary>
        /// Create a HostRuntimePolicy resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public HostRuntimePolicy(string name, HostRuntimePolicyArgs? args = null, CustomResourceOptions? options = null)
            : base("aquasec:index/hostRuntimePolicy:HostRuntimePolicy", name, args ?? new HostRuntimePolicyArgs(), MakeResourceOptions(options, ""))
        {
        }

        private HostRuntimePolicy(string name, Input<string> id, HostRuntimePolicyState? state = null, CustomResourceOptions? options = null)
            : base("aquasec:index/hostRuntimePolicy:HostRuntimePolicy", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/pulumiverse/pulumi-aquasec",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing HostRuntimePolicy resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static HostRuntimePolicy Get(string name, Input<string> id, HostRuntimePolicyState? state = null, CustomResourceOptions? options = null)
        {
            return new HostRuntimePolicy(name, id, state, options);
        }
    }

    public sealed class HostRuntimePolicyArgs : global::Pulumi.ResourceArgs
    {
        [Input("applicationScopes")]
        private InputList<string>? _applicationScopes;

        /// <summary>
        /// Indicates the application scope of the service.
        /// </summary>
        public InputList<string> ApplicationScopes
        {
            get => _applicationScopes ?? (_applicationScopes = new InputList<string>());
            set => _applicationScopes = value;
        }

        /// <summary>
        /// If true, all process activity will be audited.
        /// </summary>
        [Input("auditAllOsUserActivity")]
        public Input<bool>? AuditAllOsUserActivity { get; set; }

        /// <summary>
        /// Detects brute force login attempts
        /// </summary>
        [Input("auditBruteForceLogin")]
        public Input<bool>? AuditBruteForceLogin { get; set; }

        /// <summary>
        /// If true, full command arguments will be audited.
        /// </summary>
        [Input("auditFullCommandArguments")]
        public Input<bool>? AuditFullCommandArguments { get; set; }

        /// <summary>
        /// If true, host failed logins will be audited.
        /// </summary>
        [Input("auditHostFailedLoginEvents")]
        public Input<bool>? AuditHostFailedLoginEvents { get; set; }

        /// <summary>
        /// If true, host successful logins will be audited.
        /// </summary>
        [Input("auditHostSuccessfulLoginEvents")]
        public Input<bool>? AuditHostSuccessfulLoginEvents { get; set; }

        /// <summary>
        /// If true, account management will be audited.
        /// </summary>
        [Input("auditUserAccountManagement")]
        public Input<bool>? AuditUserAccountManagement { get; set; }

        /// <summary>
        /// Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
        /// </summary>
        [Input("blockCryptocurrencyMining")]
        public Input<bool>? BlockCryptocurrencyMining { get; set; }

        [Input("blockedFiles")]
        private InputList<string>? _blockedFiles;

        /// <summary>
        /// List of files that are prevented from being read, modified and executed in the containers.
        /// </summary>
        public InputList<string> BlockedFiles
        {
            get => _blockedFiles ?? (_blockedFiles = new InputList<string>());
            set => _blockedFiles = value;
        }

        /// <summary>
        /// The description of the host runtime policy
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// If true, detect and prevent communication from containers to IP addresses known to have a bad reputation.
        /// </summary>
        [Input("enableIpReputationSecurity")]
        public Input<bool>? EnableIpReputationSecurity { get; set; }

        /// <summary>
        /// Indicates if the runtime policy is enabled or not.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Indicates that policy should effect container execution (not just for audit).
        /// </summary>
        [Input("enforce")]
        public Input<bool>? Enforce { get; set; }

        /// <summary>
        /// Indicates the number of days after which the runtime policy will be changed to enforce mode.
        /// </summary>
        [Input("enforceAfterDays")]
        public Input<int>? EnforceAfterDays { get; set; }

        /// <summary>
        /// Configuration for file integrity monitoring.
        /// </summary>
        [Input("fileIntegrityMonitoring")]
        public Input<Inputs.HostRuntimePolicyFileIntegrityMonitoringArgs>? FileIntegrityMonitoring { get; set; }

        /// <summary>
        /// If true, system log will be monitored.
        /// </summary>
        [Input("monitorSystemLogIntegrity")]
        public Input<bool>? MonitorSystemLogIntegrity { get; set; }

        /// <summary>
        /// If true, system time changes will be monitored.
        /// </summary>
        [Input("monitorSystemTimeChanges")]
        public Input<bool>? MonitorSystemTimeChanges { get; set; }

        /// <summary>
        /// If true, windows service operations will be monitored.
        /// </summary>
        [Input("monitorWindowsServices")]
        public Input<bool>? MonitorWindowsServices { get; set; }

        /// <summary>
        /// Name of the host runtime policy
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("osGroupsAlloweds")]
        private InputList<string>? _osGroupsAlloweds;

        /// <summary>
        /// List of OS (Linux or Windows) groups that are allowed to authenticate to the host, and block authentication requests from all others. Groups can be either Linux groups or Windows AD groups.
        /// </summary>
        public InputList<string> OsGroupsAlloweds
        {
            get => _osGroupsAlloweds ?? (_osGroupsAlloweds = new InputList<string>());
            set => _osGroupsAlloweds = value;
        }

        [Input("osGroupsBlockeds")]
        private InputList<string>? _osGroupsBlockeds;

        /// <summary>
        /// List of OS (Linux or Windows) groups that are not allowed to authenticate to the host, and block authentication requests from all others. Groups can be either Linux groups or Windows AD groups.
        /// </summary>
        public InputList<string> OsGroupsBlockeds
        {
            get => _osGroupsBlockeds ?? (_osGroupsBlockeds = new InputList<string>());
            set => _osGroupsBlockeds = value;
        }

        [Input("osUsersAlloweds")]
        private InputList<string>? _osUsersAlloweds;

        /// <summary>
        /// List of OS (Linux or Windows) users that are allowed to authenticate to the host, and block authentication requests from all others.
        /// </summary>
        public InputList<string> OsUsersAlloweds
        {
            get => _osUsersAlloweds ?? (_osUsersAlloweds = new InputList<string>());
            set => _osUsersAlloweds = value;
        }

        [Input("osUsersBlockeds")]
        private InputList<string>? _osUsersBlockeds;

        /// <summary>
        /// List of OS (Linux or Windows) users that are not allowed to authenticate to the host, and block authentication requests from all others.
        /// </summary>
        public InputList<string> OsUsersBlockeds
        {
            get => _osUsersBlockeds ?? (_osUsersBlockeds = new InputList<string>());
            set => _osUsersBlockeds = value;
        }

        [Input("packageBlocks")]
        private InputList<string>? _packageBlocks;

        /// <summary>
        /// List of packages that are not allowed read, write or execute all files that under the packages.
        /// </summary>
        public InputList<string> PackageBlocks
        {
            get => _packageBlocks ?? (_packageBlocks = new InputList<string>());
            set => _packageBlocks = value;
        }

        /// <summary>
        /// If true, port scanning behaviors will be audited.
        /// </summary>
        [Input("portScanningDetection")]
        public Input<bool>? PortScanningDetection { get; set; }

        /// <summary>
        /// Logical expression of how to compute the dependency of the scope variables.
        /// </summary>
        [Input("scopeExpression")]
        public Input<string>? ScopeExpression { get; set; }

        [Input("scopeVariables")]
        private InputList<Inputs.HostRuntimePolicyScopeVariableArgs>? _scopeVariables;

        /// <summary>
        /// List of scope attributes.
        /// </summary>
        public InputList<Inputs.HostRuntimePolicyScopeVariableArgs> ScopeVariables
        {
            get => _scopeVariables ?? (_scopeVariables = new InputList<Inputs.HostRuntimePolicyScopeVariableArgs>());
            set => _scopeVariables = value;
        }

        /// <summary>
        /// Configuration for windows registry monitoring.
        /// </summary>
        [Input("windowsRegistryMonitoring")]
        public Input<Inputs.HostRuntimePolicyWindowsRegistryMonitoringArgs>? WindowsRegistryMonitoring { get; set; }

        /// <summary>
        /// Configuration for windows registry protection.
        /// </summary>
        [Input("windowsRegistryProtection")]
        public Input<Inputs.HostRuntimePolicyWindowsRegistryProtectionArgs>? WindowsRegistryProtection { get; set; }

        public HostRuntimePolicyArgs()
        {
        }
        public static new HostRuntimePolicyArgs Empty => new HostRuntimePolicyArgs();
    }

    public sealed class HostRuntimePolicyState : global::Pulumi.ResourceArgs
    {
        [Input("applicationScopes")]
        private InputList<string>? _applicationScopes;

        /// <summary>
        /// Indicates the application scope of the service.
        /// </summary>
        public InputList<string> ApplicationScopes
        {
            get => _applicationScopes ?? (_applicationScopes = new InputList<string>());
            set => _applicationScopes = value;
        }

        /// <summary>
        /// If true, all process activity will be audited.
        /// </summary>
        [Input("auditAllOsUserActivity")]
        public Input<bool>? AuditAllOsUserActivity { get; set; }

        /// <summary>
        /// Detects brute force login attempts
        /// </summary>
        [Input("auditBruteForceLogin")]
        public Input<bool>? AuditBruteForceLogin { get; set; }

        /// <summary>
        /// If true, full command arguments will be audited.
        /// </summary>
        [Input("auditFullCommandArguments")]
        public Input<bool>? AuditFullCommandArguments { get; set; }

        /// <summary>
        /// If true, host failed logins will be audited.
        /// </summary>
        [Input("auditHostFailedLoginEvents")]
        public Input<bool>? AuditHostFailedLoginEvents { get; set; }

        /// <summary>
        /// If true, host successful logins will be audited.
        /// </summary>
        [Input("auditHostSuccessfulLoginEvents")]
        public Input<bool>? AuditHostSuccessfulLoginEvents { get; set; }

        /// <summary>
        /// If true, account management will be audited.
        /// </summary>
        [Input("auditUserAccountManagement")]
        public Input<bool>? AuditUserAccountManagement { get; set; }

        /// <summary>
        /// Username of the account that created the service.
        /// </summary>
        [Input("author")]
        public Input<string>? Author { get; set; }

        /// <summary>
        /// Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
        /// </summary>
        [Input("blockCryptocurrencyMining")]
        public Input<bool>? BlockCryptocurrencyMining { get; set; }

        [Input("blockedFiles")]
        private InputList<string>? _blockedFiles;

        /// <summary>
        /// List of files that are prevented from being read, modified and executed in the containers.
        /// </summary>
        public InputList<string> BlockedFiles
        {
            get => _blockedFiles ?? (_blockedFiles = new InputList<string>());
            set => _blockedFiles = value;
        }

        /// <summary>
        /// The description of the host runtime policy
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// If true, detect and prevent communication from containers to IP addresses known to have a bad reputation.
        /// </summary>
        [Input("enableIpReputationSecurity")]
        public Input<bool>? EnableIpReputationSecurity { get; set; }

        /// <summary>
        /// Indicates if the runtime policy is enabled or not.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Indicates that policy should effect container execution (not just for audit).
        /// </summary>
        [Input("enforce")]
        public Input<bool>? Enforce { get; set; }

        /// <summary>
        /// Indicates the number of days after which the runtime policy will be changed to enforce mode.
        /// </summary>
        [Input("enforceAfterDays")]
        public Input<int>? EnforceAfterDays { get; set; }

        /// <summary>
        /// Configuration for file integrity monitoring.
        /// </summary>
        [Input("fileIntegrityMonitoring")]
        public Input<Inputs.HostRuntimePolicyFileIntegrityMonitoringGetArgs>? FileIntegrityMonitoring { get; set; }

        /// <summary>
        /// If true, system log will be monitored.
        /// </summary>
        [Input("monitorSystemLogIntegrity")]
        public Input<bool>? MonitorSystemLogIntegrity { get; set; }

        /// <summary>
        /// If true, system time changes will be monitored.
        /// </summary>
        [Input("monitorSystemTimeChanges")]
        public Input<bool>? MonitorSystemTimeChanges { get; set; }

        /// <summary>
        /// If true, windows service operations will be monitored.
        /// </summary>
        [Input("monitorWindowsServices")]
        public Input<bool>? MonitorWindowsServices { get; set; }

        /// <summary>
        /// Name of the host runtime policy
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("osGroupsAlloweds")]
        private InputList<string>? _osGroupsAlloweds;

        /// <summary>
        /// List of OS (Linux or Windows) groups that are allowed to authenticate to the host, and block authentication requests from all others. Groups can be either Linux groups or Windows AD groups.
        /// </summary>
        public InputList<string> OsGroupsAlloweds
        {
            get => _osGroupsAlloweds ?? (_osGroupsAlloweds = new InputList<string>());
            set => _osGroupsAlloweds = value;
        }

        [Input("osGroupsBlockeds")]
        private InputList<string>? _osGroupsBlockeds;

        /// <summary>
        /// List of OS (Linux or Windows) groups that are not allowed to authenticate to the host, and block authentication requests from all others. Groups can be either Linux groups or Windows AD groups.
        /// </summary>
        public InputList<string> OsGroupsBlockeds
        {
            get => _osGroupsBlockeds ?? (_osGroupsBlockeds = new InputList<string>());
            set => _osGroupsBlockeds = value;
        }

        [Input("osUsersAlloweds")]
        private InputList<string>? _osUsersAlloweds;

        /// <summary>
        /// List of OS (Linux or Windows) users that are allowed to authenticate to the host, and block authentication requests from all others.
        /// </summary>
        public InputList<string> OsUsersAlloweds
        {
            get => _osUsersAlloweds ?? (_osUsersAlloweds = new InputList<string>());
            set => _osUsersAlloweds = value;
        }

        [Input("osUsersBlockeds")]
        private InputList<string>? _osUsersBlockeds;

        /// <summary>
        /// List of OS (Linux or Windows) users that are not allowed to authenticate to the host, and block authentication requests from all others.
        /// </summary>
        public InputList<string> OsUsersBlockeds
        {
            get => _osUsersBlockeds ?? (_osUsersBlockeds = new InputList<string>());
            set => _osUsersBlockeds = value;
        }

        [Input("packageBlocks")]
        private InputList<string>? _packageBlocks;

        /// <summary>
        /// List of packages that are not allowed read, write or execute all files that under the packages.
        /// </summary>
        public InputList<string> PackageBlocks
        {
            get => _packageBlocks ?? (_packageBlocks = new InputList<string>());
            set => _packageBlocks = value;
        }

        /// <summary>
        /// If true, port scanning behaviors will be audited.
        /// </summary>
        [Input("portScanningDetection")]
        public Input<bool>? PortScanningDetection { get; set; }

        /// <summary>
        /// Logical expression of how to compute the dependency of the scope variables.
        /// </summary>
        [Input("scopeExpression")]
        public Input<string>? ScopeExpression { get; set; }

        [Input("scopeVariables")]
        private InputList<Inputs.HostRuntimePolicyScopeVariableGetArgs>? _scopeVariables;

        /// <summary>
        /// List of scope attributes.
        /// </summary>
        public InputList<Inputs.HostRuntimePolicyScopeVariableGetArgs> ScopeVariables
        {
            get => _scopeVariables ?? (_scopeVariables = new InputList<Inputs.HostRuntimePolicyScopeVariableGetArgs>());
            set => _scopeVariables = value;
        }

        /// <summary>
        /// Configuration for windows registry monitoring.
        /// </summary>
        [Input("windowsRegistryMonitoring")]
        public Input<Inputs.HostRuntimePolicyWindowsRegistryMonitoringGetArgs>? WindowsRegistryMonitoring { get; set; }

        /// <summary>
        /// Configuration for windows registry protection.
        /// </summary>
        [Input("windowsRegistryProtection")]
        public Input<Inputs.HostRuntimePolicyWindowsRegistryProtectionGetArgs>? WindowsRegistryProtection { get; set; }

        public HostRuntimePolicyState()
        {
        }
        public static new HostRuntimePolicyState Empty => new HostRuntimePolicyState();
    }
}
