// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumiverse.aquasec;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumiverse.aquasec.inputs.ContainerRuntimePolicyFileIntegrityMonitoringArgs;
import com.pulumiverse.aquasec.inputs.ContainerRuntimePolicyMalwareScanOptionsArgs;
import com.pulumiverse.aquasec.inputs.ContainerRuntimePolicyScopeVariableArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ContainerRuntimePolicyArgs extends com.pulumi.resources.ResourceArgs {

    public static final ContainerRuntimePolicyArgs Empty = new ContainerRuntimePolicyArgs();

    /**
     * List of executables that are allowed for the user.
     * 
     */
    @Import(name="allowedExecutables")
    private @Nullable Output<List<String>> allowedExecutables;

    /**
     * @return List of executables that are allowed for the user.
     * 
     */
    public Optional<Output<List<String>>> allowedExecutables() {
        return Optional.ofNullable(this.allowedExecutables);
    }

    /**
     * List of registries that allowed for running containers.
     * 
     */
    @Import(name="allowedRegistries")
    private @Nullable Output<List<String>> allowedRegistries;

    /**
     * @return List of registries that allowed for running containers.
     * 
     */
    public Optional<Output<List<String>>> allowedRegistries() {
        return Optional.ofNullable(this.allowedRegistries);
    }

    /**
     * Indicates the application scope of the service.
     * 
     */
    @Import(name="applicationScopes")
    private @Nullable Output<List<String>> applicationScopes;

    /**
     * @return Indicates the application scope of the service.
     * 
     */
    public Optional<Output<List<String>>> applicationScopes() {
        return Optional.ofNullable(this.applicationScopes);
    }

    /**
     * If true, all network activity will be audited.
     * 
     */
    @Import(name="auditAllNetworkActivity")
    private @Nullable Output<Boolean> auditAllNetworkActivity;

    /**
     * @return If true, all network activity will be audited.
     * 
     */
    public Optional<Output<Boolean>> auditAllNetworkActivity() {
        return Optional.ofNullable(this.auditAllNetworkActivity);
    }

    /**
     * If true, all process activity will be audited.
     * 
     */
    @Import(name="auditAllProcessesActivity")
    private @Nullable Output<Boolean> auditAllProcessesActivity;

    /**
     * @return If true, all process activity will be audited.
     * 
     */
    public Optional<Output<Boolean>> auditAllProcessesActivity() {
        return Optional.ofNullable(this.auditAllProcessesActivity);
    }

    /**
     * If true, full command arguments will be audited.
     * 
     */
    @Import(name="auditFullCommandArguments")
    private @Nullable Output<Boolean> auditFullCommandArguments;

    /**
     * @return If true, full command arguments will be audited.
     * 
     */
    public Optional<Output<Boolean>> auditFullCommandArguments() {
        return Optional.ofNullable(this.auditFullCommandArguments);
    }

    /**
     * If true, prevent containers from running with access to host network.
     * 
     */
    @Import(name="blockAccessHostNetwork")
    private @Nullable Output<Boolean> blockAccessHostNetwork;

    /**
     * @return If true, prevent containers from running with access to host network.
     * 
     */
    public Optional<Output<Boolean>> blockAccessHostNetwork() {
        return Optional.ofNullable(this.blockAccessHostNetwork);
    }

    /**
     * If true, prevent containers from running with adding capabilities with `--cap-add` privilege.
     * 
     */
    @Import(name="blockAddingCapabilities")
    private @Nullable Output<Boolean> blockAddingCapabilities;

    /**
     * @return If true, prevent containers from running with adding capabilities with `--cap-add` privilege.
     * 
     */
    public Optional<Output<Boolean>> blockAddingCapabilities() {
        return Optional.ofNullable(this.blockAddingCapabilities);
    }

    /**
     * If true, exec into a container is prevented.
     * 
     */
    @Import(name="blockContainerExec")
    private @Nullable Output<Boolean> blockContainerExec;

    /**
     * @return If true, exec into a container is prevented.
     * 
     */
    public Optional<Output<Boolean>> blockContainerExec() {
        return Optional.ofNullable(this.blockContainerExec);
    }

    /**
     * Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
     * 
     */
    @Import(name="blockCryptocurrencyMining")
    private @Nullable Output<Boolean> blockCryptocurrencyMining;

    /**
     * @return Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
     * 
     */
    public Optional<Output<Boolean>> blockCryptocurrencyMining() {
        return Optional.ofNullable(this.blockCryptocurrencyMining);
    }

    /**
     * Detect and prevent running in-memory execution
     * 
     */
    @Import(name="blockFilelessExec")
    private @Nullable Output<Boolean> blockFilelessExec;

    /**
     * @return Detect and prevent running in-memory execution
     * 
     */
    public Optional<Output<Boolean>> blockFilelessExec() {
        return Optional.ofNullable(this.blockFilelessExec);
    }

    /**
     * If true, prevent containers from running with the capability to bind in port lower than 1024.
     * 
     */
    @Import(name="blockLowPortBinding")
    private @Nullable Output<Boolean> blockLowPortBinding;

    /**
     * @return If true, prevent containers from running with the capability to bind in port lower than 1024.
     * 
     */
    public Optional<Output<Boolean>> blockLowPortBinding() {
        return Optional.ofNullable(this.blockLowPortBinding);
    }

    /**
     * If true, running non-compliant image in the container is prevented.
     * 
     */
    @Import(name="blockNonCompliantImages")
    private @Nullable Output<Boolean> blockNonCompliantImages;

    /**
     * @return If true, running non-compliant image in the container is prevented.
     * 
     */
    public Optional<Output<Boolean>> blockNonCompliantImages() {
        return Optional.ofNullable(this.blockNonCompliantImages);
    }

    /**
     * If true, running containers in non-compliant pods is prevented.
     * 
     */
    @Import(name="blockNonCompliantWorkloads")
    private @Nullable Output<Boolean> blockNonCompliantWorkloads;

    /**
     * @return If true, running containers in non-compliant pods is prevented.
     * 
     */
    public Optional<Output<Boolean>> blockNonCompliantWorkloads() {
        return Optional.ofNullable(this.blockNonCompliantWorkloads);
    }

    /**
     * If true, running non-kubernetes containers is prevented.
     * 
     */
    @Import(name="blockNonK8sContainers")
    private @Nullable Output<Boolean> blockNonK8sContainers;

    /**
     * @return If true, running non-kubernetes containers is prevented.
     * 
     */
    public Optional<Output<Boolean>> blockNonK8sContainers() {
        return Optional.ofNullable(this.blockNonK8sContainers);
    }

    /**
     * If true, prevent containers from running with privileged container capability.
     * 
     */
    @Import(name="blockPrivilegedContainers")
    private @Nullable Output<Boolean> blockPrivilegedContainers;

    /**
     * @return If true, prevent containers from running with privileged container capability.
     * 
     */
    public Optional<Output<Boolean>> blockPrivilegedContainers() {
        return Optional.ofNullable(this.blockPrivilegedContainers);
    }

    /**
     * If true, reverse shell is prevented.
     * 
     */
    @Import(name="blockReverseShell")
    private @Nullable Output<Boolean> blockReverseShell;

    /**
     * @return If true, reverse shell is prevented.
     * 
     */
    public Optional<Output<Boolean>> blockReverseShell() {
        return Optional.ofNullable(this.blockReverseShell);
    }

    /**
     * If true, prevent containers from running with root user.
     * 
     */
    @Import(name="blockRootUser")
    private @Nullable Output<Boolean> blockRootUser;

    /**
     * @return If true, prevent containers from running with root user.
     * 
     */
    public Optional<Output<Boolean>> blockRootUser() {
        return Optional.ofNullable(this.blockRootUser);
    }

    /**
     * If true, running images in the container that are not registered in Aqua is prevented.
     * 
     */
    @Import(name="blockUnregisteredImages")
    private @Nullable Output<Boolean> blockUnregisteredImages;

    /**
     * @return If true, running images in the container that are not registered in Aqua is prevented.
     * 
     */
    public Optional<Output<Boolean>> blockUnregisteredImages() {
        return Optional.ofNullable(this.blockUnregisteredImages);
    }

    /**
     * If true, prevent containers from running with the privilege to use the IPC namespace.
     * 
     */
    @Import(name="blockUseIpcNamespace")
    private @Nullable Output<Boolean> blockUseIpcNamespace;

    /**
     * @return If true, prevent containers from running with the privilege to use the IPC namespace.
     * 
     */
    public Optional<Output<Boolean>> blockUseIpcNamespace() {
        return Optional.ofNullable(this.blockUseIpcNamespace);
    }

    /**
     * If true, prevent containers from running with the privilege to use the PID namespace.
     * 
     */
    @Import(name="blockUsePidNamespace")
    private @Nullable Output<Boolean> blockUsePidNamespace;

    /**
     * @return If true, prevent containers from running with the privilege to use the PID namespace.
     * 
     */
    public Optional<Output<Boolean>> blockUsePidNamespace() {
        return Optional.ofNullable(this.blockUsePidNamespace);
    }

    /**
     * If true, prevent containers from running with the privilege to use the user namespace.
     * 
     */
    @Import(name="blockUseUserNamespace")
    private @Nullable Output<Boolean> blockUseUserNamespace;

    /**
     * @return If true, prevent containers from running with the privilege to use the user namespace.
     * 
     */
    public Optional<Output<Boolean>> blockUseUserNamespace() {
        return Optional.ofNullable(this.blockUseUserNamespace);
    }

    /**
     * If true, prevent containers from running with the privilege to use the UTS namespace.
     * 
     */
    @Import(name="blockUseUtsNamespace")
    private @Nullable Output<Boolean> blockUseUtsNamespace;

    /**
     * @return If true, prevent containers from running with the privilege to use the UTS namespace.
     * 
     */
    public Optional<Output<Boolean>> blockUseUtsNamespace() {
        return Optional.ofNullable(this.blockUseUtsNamespace);
    }

    /**
     * If true, prevents containers from using specific Unix capabilities.
     * 
     */
    @Import(name="blockedCapabilities")
    private @Nullable Output<List<String>> blockedCapabilities;

    /**
     * @return If true, prevents containers from using specific Unix capabilities.
     * 
     */
    public Optional<Output<List<String>>> blockedCapabilities() {
        return Optional.ofNullable(this.blockedCapabilities);
    }

    /**
     * List of executables that are prevented from running in containers.
     * 
     */
    @Import(name="blockedExecutables")
    private @Nullable Output<List<String>> blockedExecutables;

    /**
     * @return List of executables that are prevented from running in containers.
     * 
     */
    public Optional<Output<List<String>>> blockedExecutables() {
        return Optional.ofNullable(this.blockedExecutables);
    }

    /**
     * List of files that are prevented from being read, modified and executed in the containers.
     * 
     */
    @Import(name="blockedFiles")
    private @Nullable Output<List<String>> blockedFiles;

    /**
     * @return List of files that are prevented from being read, modified and executed in the containers.
     * 
     */
    public Optional<Output<List<String>>> blockedFiles() {
        return Optional.ofNullable(this.blockedFiles);
    }

    /**
     * List of blocked inbound ports.
     * 
     */
    @Import(name="blockedInboundPorts")
    private @Nullable Output<List<String>> blockedInboundPorts;

    /**
     * @return List of blocked inbound ports.
     * 
     */
    public Optional<Output<List<String>>> blockedInboundPorts() {
        return Optional.ofNullable(this.blockedInboundPorts);
    }

    /**
     * List of blocked outbound ports.
     * 
     */
    @Import(name="blockedOutboundPorts")
    private @Nullable Output<List<String>> blockedOutboundPorts;

    /**
     * @return List of blocked outbound ports.
     * 
     */
    public Optional<Output<List<String>>> blockedOutboundPorts() {
        return Optional.ofNullable(this.blockedOutboundPorts);
    }

    /**
     * Prevent containers from reading, writing, or executing all files in the list of packages.
     * 
     */
    @Import(name="blockedPackages")
    private @Nullable Output<List<String>> blockedPackages;

    /**
     * @return Prevent containers from reading, writing, or executing all files in the list of packages.
     * 
     */
    public Optional<Output<List<String>>> blockedPackages() {
        return Optional.ofNullable(this.blockedPackages);
    }

    /**
     * List of volumes that are prevented from being mounted in the containers.
     * 
     */
    @Import(name="blockedVolumes")
    private @Nullable Output<List<String>> blockedVolumes;

    /**
     * @return List of volumes that are prevented from being mounted in the containers.
     * 
     */
    public Optional<Output<List<String>>> blockedVolumes() {
        return Optional.ofNullable(this.blockedVolumes);
    }

    /**
     * List of processes that will be allowed.
     * 
     */
    @Import(name="containerExecAllowedProcesses")
    private @Nullable Output<List<String>> containerExecAllowedProcesses;

    /**
     * @return List of processes that will be allowed.
     * 
     */
    public Optional<Output<List<String>>> containerExecAllowedProcesses() {
        return Optional.ofNullable(this.containerExecAllowedProcesses);
    }

    /**
     * The description of the container runtime policy
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return The description of the container runtime policy
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * If true, executables that are not in the original image is prevented from running.
     * 
     */
    @Import(name="enableDriftPrevention")
    private @Nullable Output<Boolean> enableDriftPrevention;

    /**
     * @return If true, executables that are not in the original image is prevented from running.
     * 
     */
    public Optional<Output<Boolean>> enableDriftPrevention() {
        return Optional.ofNullable(this.enableDriftPrevention);
    }

    /**
     * If true, fork bombs are prevented in the containers.
     * 
     */
    @Import(name="enableForkGuard")
    private @Nullable Output<Boolean> enableForkGuard;

    /**
     * @return If true, fork bombs are prevented in the containers.
     * 
     */
    public Optional<Output<Boolean>> enableForkGuard() {
        return Optional.ofNullable(this.enableForkGuard);
    }

    /**
     * If true, detect and prevent communication from containers to IP addresses known to have a bad reputation.
     * 
     */
    @Import(name="enableIpReputationSecurity")
    private @Nullable Output<Boolean> enableIpReputationSecurity;

    /**
     * @return If true, detect and prevent communication from containers to IP addresses known to have a bad reputation.
     * 
     */
    public Optional<Output<Boolean>> enableIpReputationSecurity() {
        return Optional.ofNullable(this.enableIpReputationSecurity);
    }

    /**
     * If true, detects port scanning behavior in the container.
     * 
     */
    @Import(name="enablePortScanDetection")
    private @Nullable Output<Boolean> enablePortScanDetection;

    /**
     * @return If true, detects port scanning behavior in the container.
     * 
     */
    public Optional<Output<Boolean>> enablePortScanDetection() {
        return Optional.ofNullable(this.enablePortScanDetection);
    }

    /**
     * Indicates if the runtime policy is enabled or not.
     * 
     */
    @Import(name="enabled")
    private @Nullable Output<Boolean> enabled;

    /**
     * @return Indicates if the runtime policy is enabled or not.
     * 
     */
    public Optional<Output<Boolean>> enabled() {
        return Optional.ofNullable(this.enabled);
    }

    /**
     * Indicates that policy should effect container execution (not just for audit).
     * 
     */
    @Import(name="enforce")
    private @Nullable Output<Boolean> enforce;

    /**
     * @return Indicates that policy should effect container execution (not just for audit).
     * 
     */
    public Optional<Output<Boolean>> enforce() {
        return Optional.ofNullable(this.enforce);
    }

    /**
     * Indicates the number of days after which the runtime policy will be changed to enforce mode.
     * 
     */
    @Import(name="enforceAfterDays")
    private @Nullable Output<Integer> enforceAfterDays;

    /**
     * @return Indicates the number of days after which the runtime policy will be changed to enforce mode.
     * 
     */
    public Optional<Output<Integer>> enforceAfterDays() {
        return Optional.ofNullable(this.enforceAfterDays);
    }

    /**
     * List of files and directories to be excluded from the read-only list.
     * 
     */
    @Import(name="exceptionalReadonlyFilesAndDirectories")
    private @Nullable Output<List<String>> exceptionalReadonlyFilesAndDirectories;

    /**
     * @return List of files and directories to be excluded from the read-only list.
     * 
     */
    public Optional<Output<List<String>>> exceptionalReadonlyFilesAndDirectories() {
        return Optional.ofNullable(this.exceptionalReadonlyFilesAndDirectories);
    }

    /**
     * Specify processes that will be allowed
     * 
     */
    @Import(name="execLockdownWhiteLists")
    private @Nullable Output<List<String>> execLockdownWhiteLists;

    /**
     * @return Specify processes that will be allowed
     * 
     */
    public Optional<Output<List<String>>> execLockdownWhiteLists() {
        return Optional.ofNullable(this.execLockdownWhiteLists);
    }

    /**
     * Configuration for file integrity monitoring.
     * 
     */
    @Import(name="fileIntegrityMonitoring")
    private @Nullable Output<ContainerRuntimePolicyFileIntegrityMonitoringArgs> fileIntegrityMonitoring;

    /**
     * @return Configuration for file integrity monitoring.
     * 
     */
    public Optional<Output<ContainerRuntimePolicyFileIntegrityMonitoringArgs>> fileIntegrityMonitoring() {
        return Optional.ofNullable(this.fileIntegrityMonitoring);
    }

    /**
     * Process limit for the fork guard.
     * 
     */
    @Import(name="forkGuardProcessLimit")
    private @Nullable Output<Integer> forkGuardProcessLimit;

    /**
     * @return Process limit for the fork guard.
     * 
     */
    public Optional<Output<Integer>> forkGuardProcessLimit() {
        return Optional.ofNullable(this.forkGuardProcessLimit);
    }

    /**
     * If true, prevents the container from obtaining new privileges at runtime. (only enabled in enforce mode)
     * 
     */
    @Import(name="limitNewPrivileges")
    private @Nullable Output<Boolean> limitNewPrivileges;

    /**
     * @return If true, prevents the container from obtaining new privileges at runtime. (only enabled in enforce mode)
     * 
     */
    public Optional<Output<Boolean>> limitNewPrivileges() {
        return Optional.ofNullable(this.limitNewPrivileges);
    }

    /**
     * Configuration for Real-Time Malware Protection.
     * 
     */
    @Import(name="malwareScanOptions")
    private @Nullable Output<ContainerRuntimePolicyMalwareScanOptionsArgs> malwareScanOptions;

    /**
     * @return Configuration for Real-Time Malware Protection.
     * 
     */
    public Optional<Output<ContainerRuntimePolicyMalwareScanOptionsArgs>> malwareScanOptions() {
        return Optional.ofNullable(this.malwareScanOptions);
    }

    /**
     * If true, system time changes will be monitored.
     * 
     */
    @Import(name="monitorSystemTimeChanges")
    private @Nullable Output<Boolean> monitorSystemTimeChanges;

    /**
     * @return If true, system time changes will be monitored.
     * 
     */
    public Optional<Output<Boolean>> monitorSystemTimeChanges() {
        return Optional.ofNullable(this.monitorSystemTimeChanges);
    }

    /**
     * Name of the container runtime policy
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Name of the container runtime policy
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * List of files and directories to be restricted as read-only
     * 
     */
    @Import(name="readonlyFilesAndDirectories")
    private @Nullable Output<List<String>> readonlyFilesAndDirectories;

    /**
     * @return List of files and directories to be restricted as read-only
     * 
     */
    public Optional<Output<List<String>>> readonlyFilesAndDirectories() {
        return Optional.ofNullable(this.readonlyFilesAndDirectories);
    }

    /**
     * List of IPs/ CIDRs that will be allowed
     * 
     */
    @Import(name="reverseShellAllowedIps")
    private @Nullable Output<List<String>> reverseShellAllowedIps;

    /**
     * @return List of IPs/ CIDRs that will be allowed
     * 
     */
    public Optional<Output<List<String>>> reverseShellAllowedIps() {
        return Optional.ofNullable(this.reverseShellAllowedIps);
    }

    /**
     * List of processes that will be allowed
     * 
     */
    @Import(name="reverseShellAllowedProcesses")
    private @Nullable Output<List<String>> reverseShellAllowedProcesses;

    /**
     * @return List of processes that will be allowed
     * 
     */
    public Optional<Output<List<String>>> reverseShellAllowedProcesses() {
        return Optional.ofNullable(this.reverseShellAllowedProcesses);
    }

    /**
     * Logical expression of how to compute the dependency of the scope variables.
     * 
     */
    @Import(name="scopeExpression")
    private @Nullable Output<String> scopeExpression;

    /**
     * @return Logical expression of how to compute the dependency of the scope variables.
     * 
     */
    public Optional<Output<String>> scopeExpression() {
        return Optional.ofNullable(this.scopeExpression);
    }

    /**
     * List of scope attributes.
     * 
     */
    @Import(name="scopeVariables")
    private @Nullable Output<List<ContainerRuntimePolicyScopeVariableArgs>> scopeVariables;

    /**
     * @return List of scope attributes.
     * 
     */
    public Optional<Output<List<ContainerRuntimePolicyScopeVariableArgs>>> scopeVariables() {
        return Optional.ofNullable(this.scopeVariables);
    }

    private ContainerRuntimePolicyArgs() {}

    private ContainerRuntimePolicyArgs(ContainerRuntimePolicyArgs $) {
        this.allowedExecutables = $.allowedExecutables;
        this.allowedRegistries = $.allowedRegistries;
        this.applicationScopes = $.applicationScopes;
        this.auditAllNetworkActivity = $.auditAllNetworkActivity;
        this.auditAllProcessesActivity = $.auditAllProcessesActivity;
        this.auditFullCommandArguments = $.auditFullCommandArguments;
        this.blockAccessHostNetwork = $.blockAccessHostNetwork;
        this.blockAddingCapabilities = $.blockAddingCapabilities;
        this.blockContainerExec = $.blockContainerExec;
        this.blockCryptocurrencyMining = $.blockCryptocurrencyMining;
        this.blockFilelessExec = $.blockFilelessExec;
        this.blockLowPortBinding = $.blockLowPortBinding;
        this.blockNonCompliantImages = $.blockNonCompliantImages;
        this.blockNonCompliantWorkloads = $.blockNonCompliantWorkloads;
        this.blockNonK8sContainers = $.blockNonK8sContainers;
        this.blockPrivilegedContainers = $.blockPrivilegedContainers;
        this.blockReverseShell = $.blockReverseShell;
        this.blockRootUser = $.blockRootUser;
        this.blockUnregisteredImages = $.blockUnregisteredImages;
        this.blockUseIpcNamespace = $.blockUseIpcNamespace;
        this.blockUsePidNamespace = $.blockUsePidNamespace;
        this.blockUseUserNamespace = $.blockUseUserNamespace;
        this.blockUseUtsNamespace = $.blockUseUtsNamespace;
        this.blockedCapabilities = $.blockedCapabilities;
        this.blockedExecutables = $.blockedExecutables;
        this.blockedFiles = $.blockedFiles;
        this.blockedInboundPorts = $.blockedInboundPorts;
        this.blockedOutboundPorts = $.blockedOutboundPorts;
        this.blockedPackages = $.blockedPackages;
        this.blockedVolumes = $.blockedVolumes;
        this.containerExecAllowedProcesses = $.containerExecAllowedProcesses;
        this.description = $.description;
        this.enableDriftPrevention = $.enableDriftPrevention;
        this.enableForkGuard = $.enableForkGuard;
        this.enableIpReputationSecurity = $.enableIpReputationSecurity;
        this.enablePortScanDetection = $.enablePortScanDetection;
        this.enabled = $.enabled;
        this.enforce = $.enforce;
        this.enforceAfterDays = $.enforceAfterDays;
        this.exceptionalReadonlyFilesAndDirectories = $.exceptionalReadonlyFilesAndDirectories;
        this.execLockdownWhiteLists = $.execLockdownWhiteLists;
        this.fileIntegrityMonitoring = $.fileIntegrityMonitoring;
        this.forkGuardProcessLimit = $.forkGuardProcessLimit;
        this.limitNewPrivileges = $.limitNewPrivileges;
        this.malwareScanOptions = $.malwareScanOptions;
        this.monitorSystemTimeChanges = $.monitorSystemTimeChanges;
        this.name = $.name;
        this.readonlyFilesAndDirectories = $.readonlyFilesAndDirectories;
        this.reverseShellAllowedIps = $.reverseShellAllowedIps;
        this.reverseShellAllowedProcesses = $.reverseShellAllowedProcesses;
        this.scopeExpression = $.scopeExpression;
        this.scopeVariables = $.scopeVariables;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ContainerRuntimePolicyArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ContainerRuntimePolicyArgs $;

        public Builder() {
            $ = new ContainerRuntimePolicyArgs();
        }

        public Builder(ContainerRuntimePolicyArgs defaults) {
            $ = new ContainerRuntimePolicyArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowedExecutables List of executables that are allowed for the user.
         * 
         * @return builder
         * 
         */
        public Builder allowedExecutables(@Nullable Output<List<String>> allowedExecutables) {
            $.allowedExecutables = allowedExecutables;
            return this;
        }

        /**
         * @param allowedExecutables List of executables that are allowed for the user.
         * 
         * @return builder
         * 
         */
        public Builder allowedExecutables(List<String> allowedExecutables) {
            return allowedExecutables(Output.of(allowedExecutables));
        }

        /**
         * @param allowedExecutables List of executables that are allowed for the user.
         * 
         * @return builder
         * 
         */
        public Builder allowedExecutables(String... allowedExecutables) {
            return allowedExecutables(List.of(allowedExecutables));
        }

        /**
         * @param allowedRegistries List of registries that allowed for running containers.
         * 
         * @return builder
         * 
         */
        public Builder allowedRegistries(@Nullable Output<List<String>> allowedRegistries) {
            $.allowedRegistries = allowedRegistries;
            return this;
        }

        /**
         * @param allowedRegistries List of registries that allowed for running containers.
         * 
         * @return builder
         * 
         */
        public Builder allowedRegistries(List<String> allowedRegistries) {
            return allowedRegistries(Output.of(allowedRegistries));
        }

        /**
         * @param allowedRegistries List of registries that allowed for running containers.
         * 
         * @return builder
         * 
         */
        public Builder allowedRegistries(String... allowedRegistries) {
            return allowedRegistries(List.of(allowedRegistries));
        }

        /**
         * @param applicationScopes Indicates the application scope of the service.
         * 
         * @return builder
         * 
         */
        public Builder applicationScopes(@Nullable Output<List<String>> applicationScopes) {
            $.applicationScopes = applicationScopes;
            return this;
        }

        /**
         * @param applicationScopes Indicates the application scope of the service.
         * 
         * @return builder
         * 
         */
        public Builder applicationScopes(List<String> applicationScopes) {
            return applicationScopes(Output.of(applicationScopes));
        }

        /**
         * @param applicationScopes Indicates the application scope of the service.
         * 
         * @return builder
         * 
         */
        public Builder applicationScopes(String... applicationScopes) {
            return applicationScopes(List.of(applicationScopes));
        }

        /**
         * @param auditAllNetworkActivity If true, all network activity will be audited.
         * 
         * @return builder
         * 
         */
        public Builder auditAllNetworkActivity(@Nullable Output<Boolean> auditAllNetworkActivity) {
            $.auditAllNetworkActivity = auditAllNetworkActivity;
            return this;
        }

        /**
         * @param auditAllNetworkActivity If true, all network activity will be audited.
         * 
         * @return builder
         * 
         */
        public Builder auditAllNetworkActivity(Boolean auditAllNetworkActivity) {
            return auditAllNetworkActivity(Output.of(auditAllNetworkActivity));
        }

        /**
         * @param auditAllProcessesActivity If true, all process activity will be audited.
         * 
         * @return builder
         * 
         */
        public Builder auditAllProcessesActivity(@Nullable Output<Boolean> auditAllProcessesActivity) {
            $.auditAllProcessesActivity = auditAllProcessesActivity;
            return this;
        }

        /**
         * @param auditAllProcessesActivity If true, all process activity will be audited.
         * 
         * @return builder
         * 
         */
        public Builder auditAllProcessesActivity(Boolean auditAllProcessesActivity) {
            return auditAllProcessesActivity(Output.of(auditAllProcessesActivity));
        }

        /**
         * @param auditFullCommandArguments If true, full command arguments will be audited.
         * 
         * @return builder
         * 
         */
        public Builder auditFullCommandArguments(@Nullable Output<Boolean> auditFullCommandArguments) {
            $.auditFullCommandArguments = auditFullCommandArguments;
            return this;
        }

        /**
         * @param auditFullCommandArguments If true, full command arguments will be audited.
         * 
         * @return builder
         * 
         */
        public Builder auditFullCommandArguments(Boolean auditFullCommandArguments) {
            return auditFullCommandArguments(Output.of(auditFullCommandArguments));
        }

        /**
         * @param blockAccessHostNetwork If true, prevent containers from running with access to host network.
         * 
         * @return builder
         * 
         */
        public Builder blockAccessHostNetwork(@Nullable Output<Boolean> blockAccessHostNetwork) {
            $.blockAccessHostNetwork = blockAccessHostNetwork;
            return this;
        }

        /**
         * @param blockAccessHostNetwork If true, prevent containers from running with access to host network.
         * 
         * @return builder
         * 
         */
        public Builder blockAccessHostNetwork(Boolean blockAccessHostNetwork) {
            return blockAccessHostNetwork(Output.of(blockAccessHostNetwork));
        }

        /**
         * @param blockAddingCapabilities If true, prevent containers from running with adding capabilities with `--cap-add` privilege.
         * 
         * @return builder
         * 
         */
        public Builder blockAddingCapabilities(@Nullable Output<Boolean> blockAddingCapabilities) {
            $.blockAddingCapabilities = blockAddingCapabilities;
            return this;
        }

        /**
         * @param blockAddingCapabilities If true, prevent containers from running with adding capabilities with `--cap-add` privilege.
         * 
         * @return builder
         * 
         */
        public Builder blockAddingCapabilities(Boolean blockAddingCapabilities) {
            return blockAddingCapabilities(Output.of(blockAddingCapabilities));
        }

        /**
         * @param blockContainerExec If true, exec into a container is prevented.
         * 
         * @return builder
         * 
         */
        public Builder blockContainerExec(@Nullable Output<Boolean> blockContainerExec) {
            $.blockContainerExec = blockContainerExec;
            return this;
        }

        /**
         * @param blockContainerExec If true, exec into a container is prevented.
         * 
         * @return builder
         * 
         */
        public Builder blockContainerExec(Boolean blockContainerExec) {
            return blockContainerExec(Output.of(blockContainerExec));
        }

        /**
         * @param blockCryptocurrencyMining Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
         * 
         * @return builder
         * 
         */
        public Builder blockCryptocurrencyMining(@Nullable Output<Boolean> blockCryptocurrencyMining) {
            $.blockCryptocurrencyMining = blockCryptocurrencyMining;
            return this;
        }

        /**
         * @param blockCryptocurrencyMining Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
         * 
         * @return builder
         * 
         */
        public Builder blockCryptocurrencyMining(Boolean blockCryptocurrencyMining) {
            return blockCryptocurrencyMining(Output.of(blockCryptocurrencyMining));
        }

        /**
         * @param blockFilelessExec Detect and prevent running in-memory execution
         * 
         * @return builder
         * 
         */
        public Builder blockFilelessExec(@Nullable Output<Boolean> blockFilelessExec) {
            $.blockFilelessExec = blockFilelessExec;
            return this;
        }

        /**
         * @param blockFilelessExec Detect and prevent running in-memory execution
         * 
         * @return builder
         * 
         */
        public Builder blockFilelessExec(Boolean blockFilelessExec) {
            return blockFilelessExec(Output.of(blockFilelessExec));
        }

        /**
         * @param blockLowPortBinding If true, prevent containers from running with the capability to bind in port lower than 1024.
         * 
         * @return builder
         * 
         */
        public Builder blockLowPortBinding(@Nullable Output<Boolean> blockLowPortBinding) {
            $.blockLowPortBinding = blockLowPortBinding;
            return this;
        }

        /**
         * @param blockLowPortBinding If true, prevent containers from running with the capability to bind in port lower than 1024.
         * 
         * @return builder
         * 
         */
        public Builder blockLowPortBinding(Boolean blockLowPortBinding) {
            return blockLowPortBinding(Output.of(blockLowPortBinding));
        }

        /**
         * @param blockNonCompliantImages If true, running non-compliant image in the container is prevented.
         * 
         * @return builder
         * 
         */
        public Builder blockNonCompliantImages(@Nullable Output<Boolean> blockNonCompliantImages) {
            $.blockNonCompliantImages = blockNonCompliantImages;
            return this;
        }

        /**
         * @param blockNonCompliantImages If true, running non-compliant image in the container is prevented.
         * 
         * @return builder
         * 
         */
        public Builder blockNonCompliantImages(Boolean blockNonCompliantImages) {
            return blockNonCompliantImages(Output.of(blockNonCompliantImages));
        }

        /**
         * @param blockNonCompliantWorkloads If true, running containers in non-compliant pods is prevented.
         * 
         * @return builder
         * 
         */
        public Builder blockNonCompliantWorkloads(@Nullable Output<Boolean> blockNonCompliantWorkloads) {
            $.blockNonCompliantWorkloads = blockNonCompliantWorkloads;
            return this;
        }

        /**
         * @param blockNonCompliantWorkloads If true, running containers in non-compliant pods is prevented.
         * 
         * @return builder
         * 
         */
        public Builder blockNonCompliantWorkloads(Boolean blockNonCompliantWorkloads) {
            return blockNonCompliantWorkloads(Output.of(blockNonCompliantWorkloads));
        }

        /**
         * @param blockNonK8sContainers If true, running non-kubernetes containers is prevented.
         * 
         * @return builder
         * 
         */
        public Builder blockNonK8sContainers(@Nullable Output<Boolean> blockNonK8sContainers) {
            $.blockNonK8sContainers = blockNonK8sContainers;
            return this;
        }

        /**
         * @param blockNonK8sContainers If true, running non-kubernetes containers is prevented.
         * 
         * @return builder
         * 
         */
        public Builder blockNonK8sContainers(Boolean blockNonK8sContainers) {
            return blockNonK8sContainers(Output.of(blockNonK8sContainers));
        }

        /**
         * @param blockPrivilegedContainers If true, prevent containers from running with privileged container capability.
         * 
         * @return builder
         * 
         */
        public Builder blockPrivilegedContainers(@Nullable Output<Boolean> blockPrivilegedContainers) {
            $.blockPrivilegedContainers = blockPrivilegedContainers;
            return this;
        }

        /**
         * @param blockPrivilegedContainers If true, prevent containers from running with privileged container capability.
         * 
         * @return builder
         * 
         */
        public Builder blockPrivilegedContainers(Boolean blockPrivilegedContainers) {
            return blockPrivilegedContainers(Output.of(blockPrivilegedContainers));
        }

        /**
         * @param blockReverseShell If true, reverse shell is prevented.
         * 
         * @return builder
         * 
         */
        public Builder blockReverseShell(@Nullable Output<Boolean> blockReverseShell) {
            $.blockReverseShell = blockReverseShell;
            return this;
        }

        /**
         * @param blockReverseShell If true, reverse shell is prevented.
         * 
         * @return builder
         * 
         */
        public Builder blockReverseShell(Boolean blockReverseShell) {
            return blockReverseShell(Output.of(blockReverseShell));
        }

        /**
         * @param blockRootUser If true, prevent containers from running with root user.
         * 
         * @return builder
         * 
         */
        public Builder blockRootUser(@Nullable Output<Boolean> blockRootUser) {
            $.blockRootUser = blockRootUser;
            return this;
        }

        /**
         * @param blockRootUser If true, prevent containers from running with root user.
         * 
         * @return builder
         * 
         */
        public Builder blockRootUser(Boolean blockRootUser) {
            return blockRootUser(Output.of(blockRootUser));
        }

        /**
         * @param blockUnregisteredImages If true, running images in the container that are not registered in Aqua is prevented.
         * 
         * @return builder
         * 
         */
        public Builder blockUnregisteredImages(@Nullable Output<Boolean> blockUnregisteredImages) {
            $.blockUnregisteredImages = blockUnregisteredImages;
            return this;
        }

        /**
         * @param blockUnregisteredImages If true, running images in the container that are not registered in Aqua is prevented.
         * 
         * @return builder
         * 
         */
        public Builder blockUnregisteredImages(Boolean blockUnregisteredImages) {
            return blockUnregisteredImages(Output.of(blockUnregisteredImages));
        }

        /**
         * @param blockUseIpcNamespace If true, prevent containers from running with the privilege to use the IPC namespace.
         * 
         * @return builder
         * 
         */
        public Builder blockUseIpcNamespace(@Nullable Output<Boolean> blockUseIpcNamespace) {
            $.blockUseIpcNamespace = blockUseIpcNamespace;
            return this;
        }

        /**
         * @param blockUseIpcNamespace If true, prevent containers from running with the privilege to use the IPC namespace.
         * 
         * @return builder
         * 
         */
        public Builder blockUseIpcNamespace(Boolean blockUseIpcNamespace) {
            return blockUseIpcNamespace(Output.of(blockUseIpcNamespace));
        }

        /**
         * @param blockUsePidNamespace If true, prevent containers from running with the privilege to use the PID namespace.
         * 
         * @return builder
         * 
         */
        public Builder blockUsePidNamespace(@Nullable Output<Boolean> blockUsePidNamespace) {
            $.blockUsePidNamespace = blockUsePidNamespace;
            return this;
        }

        /**
         * @param blockUsePidNamespace If true, prevent containers from running with the privilege to use the PID namespace.
         * 
         * @return builder
         * 
         */
        public Builder blockUsePidNamespace(Boolean blockUsePidNamespace) {
            return blockUsePidNamespace(Output.of(blockUsePidNamespace));
        }

        /**
         * @param blockUseUserNamespace If true, prevent containers from running with the privilege to use the user namespace.
         * 
         * @return builder
         * 
         */
        public Builder blockUseUserNamespace(@Nullable Output<Boolean> blockUseUserNamespace) {
            $.blockUseUserNamespace = blockUseUserNamespace;
            return this;
        }

        /**
         * @param blockUseUserNamespace If true, prevent containers from running with the privilege to use the user namespace.
         * 
         * @return builder
         * 
         */
        public Builder blockUseUserNamespace(Boolean blockUseUserNamespace) {
            return blockUseUserNamespace(Output.of(blockUseUserNamespace));
        }

        /**
         * @param blockUseUtsNamespace If true, prevent containers from running with the privilege to use the UTS namespace.
         * 
         * @return builder
         * 
         */
        public Builder blockUseUtsNamespace(@Nullable Output<Boolean> blockUseUtsNamespace) {
            $.blockUseUtsNamespace = blockUseUtsNamespace;
            return this;
        }

        /**
         * @param blockUseUtsNamespace If true, prevent containers from running with the privilege to use the UTS namespace.
         * 
         * @return builder
         * 
         */
        public Builder blockUseUtsNamespace(Boolean blockUseUtsNamespace) {
            return blockUseUtsNamespace(Output.of(blockUseUtsNamespace));
        }

        /**
         * @param blockedCapabilities If true, prevents containers from using specific Unix capabilities.
         * 
         * @return builder
         * 
         */
        public Builder blockedCapabilities(@Nullable Output<List<String>> blockedCapabilities) {
            $.blockedCapabilities = blockedCapabilities;
            return this;
        }

        /**
         * @param blockedCapabilities If true, prevents containers from using specific Unix capabilities.
         * 
         * @return builder
         * 
         */
        public Builder blockedCapabilities(List<String> blockedCapabilities) {
            return blockedCapabilities(Output.of(blockedCapabilities));
        }

        /**
         * @param blockedCapabilities If true, prevents containers from using specific Unix capabilities.
         * 
         * @return builder
         * 
         */
        public Builder blockedCapabilities(String... blockedCapabilities) {
            return blockedCapabilities(List.of(blockedCapabilities));
        }

        /**
         * @param blockedExecutables List of executables that are prevented from running in containers.
         * 
         * @return builder
         * 
         */
        public Builder blockedExecutables(@Nullable Output<List<String>> blockedExecutables) {
            $.blockedExecutables = blockedExecutables;
            return this;
        }

        /**
         * @param blockedExecutables List of executables that are prevented from running in containers.
         * 
         * @return builder
         * 
         */
        public Builder blockedExecutables(List<String> blockedExecutables) {
            return blockedExecutables(Output.of(blockedExecutables));
        }

        /**
         * @param blockedExecutables List of executables that are prevented from running in containers.
         * 
         * @return builder
         * 
         */
        public Builder blockedExecutables(String... blockedExecutables) {
            return blockedExecutables(List.of(blockedExecutables));
        }

        /**
         * @param blockedFiles List of files that are prevented from being read, modified and executed in the containers.
         * 
         * @return builder
         * 
         */
        public Builder blockedFiles(@Nullable Output<List<String>> blockedFiles) {
            $.blockedFiles = blockedFiles;
            return this;
        }

        /**
         * @param blockedFiles List of files that are prevented from being read, modified and executed in the containers.
         * 
         * @return builder
         * 
         */
        public Builder blockedFiles(List<String> blockedFiles) {
            return blockedFiles(Output.of(blockedFiles));
        }

        /**
         * @param blockedFiles List of files that are prevented from being read, modified and executed in the containers.
         * 
         * @return builder
         * 
         */
        public Builder blockedFiles(String... blockedFiles) {
            return blockedFiles(List.of(blockedFiles));
        }

        /**
         * @param blockedInboundPorts List of blocked inbound ports.
         * 
         * @return builder
         * 
         */
        public Builder blockedInboundPorts(@Nullable Output<List<String>> blockedInboundPorts) {
            $.blockedInboundPorts = blockedInboundPorts;
            return this;
        }

        /**
         * @param blockedInboundPorts List of blocked inbound ports.
         * 
         * @return builder
         * 
         */
        public Builder blockedInboundPorts(List<String> blockedInboundPorts) {
            return blockedInboundPorts(Output.of(blockedInboundPorts));
        }

        /**
         * @param blockedInboundPorts List of blocked inbound ports.
         * 
         * @return builder
         * 
         */
        public Builder blockedInboundPorts(String... blockedInboundPorts) {
            return blockedInboundPorts(List.of(blockedInboundPorts));
        }

        /**
         * @param blockedOutboundPorts List of blocked outbound ports.
         * 
         * @return builder
         * 
         */
        public Builder blockedOutboundPorts(@Nullable Output<List<String>> blockedOutboundPorts) {
            $.blockedOutboundPorts = blockedOutboundPorts;
            return this;
        }

        /**
         * @param blockedOutboundPorts List of blocked outbound ports.
         * 
         * @return builder
         * 
         */
        public Builder blockedOutboundPorts(List<String> blockedOutboundPorts) {
            return blockedOutboundPorts(Output.of(blockedOutboundPorts));
        }

        /**
         * @param blockedOutboundPorts List of blocked outbound ports.
         * 
         * @return builder
         * 
         */
        public Builder blockedOutboundPorts(String... blockedOutboundPorts) {
            return blockedOutboundPorts(List.of(blockedOutboundPorts));
        }

        /**
         * @param blockedPackages Prevent containers from reading, writing, or executing all files in the list of packages.
         * 
         * @return builder
         * 
         */
        public Builder blockedPackages(@Nullable Output<List<String>> blockedPackages) {
            $.blockedPackages = blockedPackages;
            return this;
        }

        /**
         * @param blockedPackages Prevent containers from reading, writing, or executing all files in the list of packages.
         * 
         * @return builder
         * 
         */
        public Builder blockedPackages(List<String> blockedPackages) {
            return blockedPackages(Output.of(blockedPackages));
        }

        /**
         * @param blockedPackages Prevent containers from reading, writing, or executing all files in the list of packages.
         * 
         * @return builder
         * 
         */
        public Builder blockedPackages(String... blockedPackages) {
            return blockedPackages(List.of(blockedPackages));
        }

        /**
         * @param blockedVolumes List of volumes that are prevented from being mounted in the containers.
         * 
         * @return builder
         * 
         */
        public Builder blockedVolumes(@Nullable Output<List<String>> blockedVolumes) {
            $.blockedVolumes = blockedVolumes;
            return this;
        }

        /**
         * @param blockedVolumes List of volumes that are prevented from being mounted in the containers.
         * 
         * @return builder
         * 
         */
        public Builder blockedVolumes(List<String> blockedVolumes) {
            return blockedVolumes(Output.of(blockedVolumes));
        }

        /**
         * @param blockedVolumes List of volumes that are prevented from being mounted in the containers.
         * 
         * @return builder
         * 
         */
        public Builder blockedVolumes(String... blockedVolumes) {
            return blockedVolumes(List.of(blockedVolumes));
        }

        /**
         * @param containerExecAllowedProcesses List of processes that will be allowed.
         * 
         * @return builder
         * 
         */
        public Builder containerExecAllowedProcesses(@Nullable Output<List<String>> containerExecAllowedProcesses) {
            $.containerExecAllowedProcesses = containerExecAllowedProcesses;
            return this;
        }

        /**
         * @param containerExecAllowedProcesses List of processes that will be allowed.
         * 
         * @return builder
         * 
         */
        public Builder containerExecAllowedProcesses(List<String> containerExecAllowedProcesses) {
            return containerExecAllowedProcesses(Output.of(containerExecAllowedProcesses));
        }

        /**
         * @param containerExecAllowedProcesses List of processes that will be allowed.
         * 
         * @return builder
         * 
         */
        public Builder containerExecAllowedProcesses(String... containerExecAllowedProcesses) {
            return containerExecAllowedProcesses(List.of(containerExecAllowedProcesses));
        }

        /**
         * @param description The description of the container runtime policy
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description The description of the container runtime policy
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param enableDriftPrevention If true, executables that are not in the original image is prevented from running.
         * 
         * @return builder
         * 
         */
        public Builder enableDriftPrevention(@Nullable Output<Boolean> enableDriftPrevention) {
            $.enableDriftPrevention = enableDriftPrevention;
            return this;
        }

        /**
         * @param enableDriftPrevention If true, executables that are not in the original image is prevented from running.
         * 
         * @return builder
         * 
         */
        public Builder enableDriftPrevention(Boolean enableDriftPrevention) {
            return enableDriftPrevention(Output.of(enableDriftPrevention));
        }

        /**
         * @param enableForkGuard If true, fork bombs are prevented in the containers.
         * 
         * @return builder
         * 
         */
        public Builder enableForkGuard(@Nullable Output<Boolean> enableForkGuard) {
            $.enableForkGuard = enableForkGuard;
            return this;
        }

        /**
         * @param enableForkGuard If true, fork bombs are prevented in the containers.
         * 
         * @return builder
         * 
         */
        public Builder enableForkGuard(Boolean enableForkGuard) {
            return enableForkGuard(Output.of(enableForkGuard));
        }

        /**
         * @param enableIpReputationSecurity If true, detect and prevent communication from containers to IP addresses known to have a bad reputation.
         * 
         * @return builder
         * 
         */
        public Builder enableIpReputationSecurity(@Nullable Output<Boolean> enableIpReputationSecurity) {
            $.enableIpReputationSecurity = enableIpReputationSecurity;
            return this;
        }

        /**
         * @param enableIpReputationSecurity If true, detect and prevent communication from containers to IP addresses known to have a bad reputation.
         * 
         * @return builder
         * 
         */
        public Builder enableIpReputationSecurity(Boolean enableIpReputationSecurity) {
            return enableIpReputationSecurity(Output.of(enableIpReputationSecurity));
        }

        /**
         * @param enablePortScanDetection If true, detects port scanning behavior in the container.
         * 
         * @return builder
         * 
         */
        public Builder enablePortScanDetection(@Nullable Output<Boolean> enablePortScanDetection) {
            $.enablePortScanDetection = enablePortScanDetection;
            return this;
        }

        /**
         * @param enablePortScanDetection If true, detects port scanning behavior in the container.
         * 
         * @return builder
         * 
         */
        public Builder enablePortScanDetection(Boolean enablePortScanDetection) {
            return enablePortScanDetection(Output.of(enablePortScanDetection));
        }

        /**
         * @param enabled Indicates if the runtime policy is enabled or not.
         * 
         * @return builder
         * 
         */
        public Builder enabled(@Nullable Output<Boolean> enabled) {
            $.enabled = enabled;
            return this;
        }

        /**
         * @param enabled Indicates if the runtime policy is enabled or not.
         * 
         * @return builder
         * 
         */
        public Builder enabled(Boolean enabled) {
            return enabled(Output.of(enabled));
        }

        /**
         * @param enforce Indicates that policy should effect container execution (not just for audit).
         * 
         * @return builder
         * 
         */
        public Builder enforce(@Nullable Output<Boolean> enforce) {
            $.enforce = enforce;
            return this;
        }

        /**
         * @param enforce Indicates that policy should effect container execution (not just for audit).
         * 
         * @return builder
         * 
         */
        public Builder enforce(Boolean enforce) {
            return enforce(Output.of(enforce));
        }

        /**
         * @param enforceAfterDays Indicates the number of days after which the runtime policy will be changed to enforce mode.
         * 
         * @return builder
         * 
         */
        public Builder enforceAfterDays(@Nullable Output<Integer> enforceAfterDays) {
            $.enforceAfterDays = enforceAfterDays;
            return this;
        }

        /**
         * @param enforceAfterDays Indicates the number of days after which the runtime policy will be changed to enforce mode.
         * 
         * @return builder
         * 
         */
        public Builder enforceAfterDays(Integer enforceAfterDays) {
            return enforceAfterDays(Output.of(enforceAfterDays));
        }

        /**
         * @param exceptionalReadonlyFilesAndDirectories List of files and directories to be excluded from the read-only list.
         * 
         * @return builder
         * 
         */
        public Builder exceptionalReadonlyFilesAndDirectories(@Nullable Output<List<String>> exceptionalReadonlyFilesAndDirectories) {
            $.exceptionalReadonlyFilesAndDirectories = exceptionalReadonlyFilesAndDirectories;
            return this;
        }

        /**
         * @param exceptionalReadonlyFilesAndDirectories List of files and directories to be excluded from the read-only list.
         * 
         * @return builder
         * 
         */
        public Builder exceptionalReadonlyFilesAndDirectories(List<String> exceptionalReadonlyFilesAndDirectories) {
            return exceptionalReadonlyFilesAndDirectories(Output.of(exceptionalReadonlyFilesAndDirectories));
        }

        /**
         * @param exceptionalReadonlyFilesAndDirectories List of files and directories to be excluded from the read-only list.
         * 
         * @return builder
         * 
         */
        public Builder exceptionalReadonlyFilesAndDirectories(String... exceptionalReadonlyFilesAndDirectories) {
            return exceptionalReadonlyFilesAndDirectories(List.of(exceptionalReadonlyFilesAndDirectories));
        }

        /**
         * @param execLockdownWhiteLists Specify processes that will be allowed
         * 
         * @return builder
         * 
         */
        public Builder execLockdownWhiteLists(@Nullable Output<List<String>> execLockdownWhiteLists) {
            $.execLockdownWhiteLists = execLockdownWhiteLists;
            return this;
        }

        /**
         * @param execLockdownWhiteLists Specify processes that will be allowed
         * 
         * @return builder
         * 
         */
        public Builder execLockdownWhiteLists(List<String> execLockdownWhiteLists) {
            return execLockdownWhiteLists(Output.of(execLockdownWhiteLists));
        }

        /**
         * @param execLockdownWhiteLists Specify processes that will be allowed
         * 
         * @return builder
         * 
         */
        public Builder execLockdownWhiteLists(String... execLockdownWhiteLists) {
            return execLockdownWhiteLists(List.of(execLockdownWhiteLists));
        }

        /**
         * @param fileIntegrityMonitoring Configuration for file integrity monitoring.
         * 
         * @return builder
         * 
         */
        public Builder fileIntegrityMonitoring(@Nullable Output<ContainerRuntimePolicyFileIntegrityMonitoringArgs> fileIntegrityMonitoring) {
            $.fileIntegrityMonitoring = fileIntegrityMonitoring;
            return this;
        }

        /**
         * @param fileIntegrityMonitoring Configuration for file integrity monitoring.
         * 
         * @return builder
         * 
         */
        public Builder fileIntegrityMonitoring(ContainerRuntimePolicyFileIntegrityMonitoringArgs fileIntegrityMonitoring) {
            return fileIntegrityMonitoring(Output.of(fileIntegrityMonitoring));
        }

        /**
         * @param forkGuardProcessLimit Process limit for the fork guard.
         * 
         * @return builder
         * 
         */
        public Builder forkGuardProcessLimit(@Nullable Output<Integer> forkGuardProcessLimit) {
            $.forkGuardProcessLimit = forkGuardProcessLimit;
            return this;
        }

        /**
         * @param forkGuardProcessLimit Process limit for the fork guard.
         * 
         * @return builder
         * 
         */
        public Builder forkGuardProcessLimit(Integer forkGuardProcessLimit) {
            return forkGuardProcessLimit(Output.of(forkGuardProcessLimit));
        }

        /**
         * @param limitNewPrivileges If true, prevents the container from obtaining new privileges at runtime. (only enabled in enforce mode)
         * 
         * @return builder
         * 
         */
        public Builder limitNewPrivileges(@Nullable Output<Boolean> limitNewPrivileges) {
            $.limitNewPrivileges = limitNewPrivileges;
            return this;
        }

        /**
         * @param limitNewPrivileges If true, prevents the container from obtaining new privileges at runtime. (only enabled in enforce mode)
         * 
         * @return builder
         * 
         */
        public Builder limitNewPrivileges(Boolean limitNewPrivileges) {
            return limitNewPrivileges(Output.of(limitNewPrivileges));
        }

        /**
         * @param malwareScanOptions Configuration for Real-Time Malware Protection.
         * 
         * @return builder
         * 
         */
        public Builder malwareScanOptions(@Nullable Output<ContainerRuntimePolicyMalwareScanOptionsArgs> malwareScanOptions) {
            $.malwareScanOptions = malwareScanOptions;
            return this;
        }

        /**
         * @param malwareScanOptions Configuration for Real-Time Malware Protection.
         * 
         * @return builder
         * 
         */
        public Builder malwareScanOptions(ContainerRuntimePolicyMalwareScanOptionsArgs malwareScanOptions) {
            return malwareScanOptions(Output.of(malwareScanOptions));
        }

        /**
         * @param monitorSystemTimeChanges If true, system time changes will be monitored.
         * 
         * @return builder
         * 
         */
        public Builder monitorSystemTimeChanges(@Nullable Output<Boolean> monitorSystemTimeChanges) {
            $.monitorSystemTimeChanges = monitorSystemTimeChanges;
            return this;
        }

        /**
         * @param monitorSystemTimeChanges If true, system time changes will be monitored.
         * 
         * @return builder
         * 
         */
        public Builder monitorSystemTimeChanges(Boolean monitorSystemTimeChanges) {
            return monitorSystemTimeChanges(Output.of(monitorSystemTimeChanges));
        }

        /**
         * @param name Name of the container runtime policy
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Name of the container runtime policy
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param readonlyFilesAndDirectories List of files and directories to be restricted as read-only
         * 
         * @return builder
         * 
         */
        public Builder readonlyFilesAndDirectories(@Nullable Output<List<String>> readonlyFilesAndDirectories) {
            $.readonlyFilesAndDirectories = readonlyFilesAndDirectories;
            return this;
        }

        /**
         * @param readonlyFilesAndDirectories List of files and directories to be restricted as read-only
         * 
         * @return builder
         * 
         */
        public Builder readonlyFilesAndDirectories(List<String> readonlyFilesAndDirectories) {
            return readonlyFilesAndDirectories(Output.of(readonlyFilesAndDirectories));
        }

        /**
         * @param readonlyFilesAndDirectories List of files and directories to be restricted as read-only
         * 
         * @return builder
         * 
         */
        public Builder readonlyFilesAndDirectories(String... readonlyFilesAndDirectories) {
            return readonlyFilesAndDirectories(List.of(readonlyFilesAndDirectories));
        }

        /**
         * @param reverseShellAllowedIps List of IPs/ CIDRs that will be allowed
         * 
         * @return builder
         * 
         */
        public Builder reverseShellAllowedIps(@Nullable Output<List<String>> reverseShellAllowedIps) {
            $.reverseShellAllowedIps = reverseShellAllowedIps;
            return this;
        }

        /**
         * @param reverseShellAllowedIps List of IPs/ CIDRs that will be allowed
         * 
         * @return builder
         * 
         */
        public Builder reverseShellAllowedIps(List<String> reverseShellAllowedIps) {
            return reverseShellAllowedIps(Output.of(reverseShellAllowedIps));
        }

        /**
         * @param reverseShellAllowedIps List of IPs/ CIDRs that will be allowed
         * 
         * @return builder
         * 
         */
        public Builder reverseShellAllowedIps(String... reverseShellAllowedIps) {
            return reverseShellAllowedIps(List.of(reverseShellAllowedIps));
        }

        /**
         * @param reverseShellAllowedProcesses List of processes that will be allowed
         * 
         * @return builder
         * 
         */
        public Builder reverseShellAllowedProcesses(@Nullable Output<List<String>> reverseShellAllowedProcesses) {
            $.reverseShellAllowedProcesses = reverseShellAllowedProcesses;
            return this;
        }

        /**
         * @param reverseShellAllowedProcesses List of processes that will be allowed
         * 
         * @return builder
         * 
         */
        public Builder reverseShellAllowedProcesses(List<String> reverseShellAllowedProcesses) {
            return reverseShellAllowedProcesses(Output.of(reverseShellAllowedProcesses));
        }

        /**
         * @param reverseShellAllowedProcesses List of processes that will be allowed
         * 
         * @return builder
         * 
         */
        public Builder reverseShellAllowedProcesses(String... reverseShellAllowedProcesses) {
            return reverseShellAllowedProcesses(List.of(reverseShellAllowedProcesses));
        }

        /**
         * @param scopeExpression Logical expression of how to compute the dependency of the scope variables.
         * 
         * @return builder
         * 
         */
        public Builder scopeExpression(@Nullable Output<String> scopeExpression) {
            $.scopeExpression = scopeExpression;
            return this;
        }

        /**
         * @param scopeExpression Logical expression of how to compute the dependency of the scope variables.
         * 
         * @return builder
         * 
         */
        public Builder scopeExpression(String scopeExpression) {
            return scopeExpression(Output.of(scopeExpression));
        }

        /**
         * @param scopeVariables List of scope attributes.
         * 
         * @return builder
         * 
         */
        public Builder scopeVariables(@Nullable Output<List<ContainerRuntimePolicyScopeVariableArgs>> scopeVariables) {
            $.scopeVariables = scopeVariables;
            return this;
        }

        /**
         * @param scopeVariables List of scope attributes.
         * 
         * @return builder
         * 
         */
        public Builder scopeVariables(List<ContainerRuntimePolicyScopeVariableArgs> scopeVariables) {
            return scopeVariables(Output.of(scopeVariables));
        }

        /**
         * @param scopeVariables List of scope attributes.
         * 
         * @return builder
         * 
         */
        public Builder scopeVariables(ContainerRuntimePolicyScopeVariableArgs... scopeVariables) {
            return scopeVariables(List.of(scopeVariables));
        }

        public ContainerRuntimePolicyArgs build() {
            return $;
        }
    }

}
