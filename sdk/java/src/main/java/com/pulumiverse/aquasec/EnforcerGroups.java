// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumiverse.aquasec;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumiverse.aquasec.EnforcerGroupsArgs;
import com.pulumiverse.aquasec.Utilities;
import com.pulumiverse.aquasec.inputs.EnforcerGroupsState;
import com.pulumiverse.aquasec.outputs.EnforcerGroupsCommand;
import com.pulumiverse.aquasec.outputs.EnforcerGroupsOrchestrator;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * ## Example Usage
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.aquasec.EnforcerGroups;
 * import com.pulumi.aquasec.EnforcerGroupsArgs;
 * import com.pulumi.aquasec.inputs.EnforcerGroupsOrchestratorArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var group = new EnforcerGroups(&#34;group&#34;, EnforcerGroupsArgs.builder()        
 *             .antivirusProtection(true)
 *             .containerActivityProtection(true)
 *             .containerAntivirusProtection(true)
 *             .enforce(true)
 *             .forensics(true)
 *             .groupId(&#34;tf-test-enforcer&#34;)
 *             .hostAssurance(true)
 *             .hostForensics(true)
 *             .hostNetworkProtection(true)
 *             .hostProtection(true)
 *             .imageAssurance(true)
 *             .networkProtection(true)
 *             .orchestrators()
 *             .riskExplorerAutoDiscovery(true)
 *             .syncHostImages(true)
 *             .type(&#34;agent&#34;)
 *             .build());
 * 
 *         var group_kubeEnforcer = new EnforcerGroups(&#34;group-kubeEnforcer&#34;, EnforcerGroupsArgs.builder()        
 *             .admissionControl(true)
 *             .autoCopySecrets(true)
 *             .autoDiscoverConfigureRegistries(true)
 *             .autoDiscoveryEnabled(true)
 *             .autoScanDiscoveredImagesRunningContainers(true)
 *             .blockAdmissionControl(true)
 *             .enforce(true)
 *             .groupId(&#34;tf-test-kube_enforcer&#34;)
 *             .kubeBenchImageName(&#34;registry.aquasec.com/kube-bench:v0.6.5&#34;)
 *             .microEnforcerSecretsName(&#34;aqua-registry&#34;)
 *             .orchestrators(EnforcerGroupsOrchestratorArgs.builder()
 *                 .namespace(&#34;aqua&#34;)
 *                 .type(&#34;kubernetes&#34;)
 *                 .build())
 *             .type(&#34;kube_enforcer&#34;)
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 */
@ResourceType(type="aquasec:index/enforcerGroups:EnforcerGroups")
public class EnforcerGroups extends com.pulumi.resources.CustomResource {
    /**
     * Selecting this option will allow the KubeEnforcer to block the deployment of container images that have failed any of these Container Runtime Policy controls:\
     * 			* Block Non-Compliant Images\
     * 			* Block Non-Compliant Workloads\
     * 			* Block Unregistered Images\
     * 			This functionality can work only when the KubeEnforcer is deployed in Enforce mode.
     * 
     */
    @Export(name="admissionControl", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> admissionControl;

    /**
     * @return Selecting this option will allow the KubeEnforcer to block the deployment of container images that have failed any of these Container Runtime Policy controls:\
     * 			* Block Non-Compliant Images\
     * 			* Block Non-Compliant Workloads\
     * 			* Block Unregistered Images\
     * 			This functionality can work only when the KubeEnforcer is deployed in Enforce mode.
     * 
     */
    public Output<Optional<Boolean>> admissionControl() {
        return Codegen.optional(this.admissionControl);
    }
    /**
     * Allow kube enforcer audit.
     * 
     */
    @Export(name="allowKubeEnforcerAudit", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> allowKubeEnforcerAudit;

    /**
     * @return Allow kube enforcer audit.
     * 
     */
    public Output<Optional<Boolean>> allowKubeEnforcerAudit() {
        return Codegen.optional(this.allowKubeEnforcerAudit);
    }
    /**
     * List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
     * 
     */
    @Export(name="allowedApplications", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> allowedApplications;

    /**
     * @return List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
     * 
     */
    public Output<Optional<List<String>>> allowedApplications() {
        return Codegen.optional(this.allowedApplications);
    }
    /**
     * List of label names to allow on the hosts.
     * 
     */
    @Export(name="allowedLabels", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> allowedLabels;

    /**
     * @return List of label names to allow on the hosts.
     * 
     */
    public Output<Optional<List<String>>> allowedLabels() {
        return Codegen.optional(this.allowedLabels);
    }
    /**
     * List of registry names to allow on the hosts.
     * 
     */
    @Export(name="allowedRegistries", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> allowedRegistries;

    /**
     * @return List of registry names to allow on the hosts.
     * 
     */
    public Output<Optional<List<String>>> allowedRegistries() {
        return Codegen.optional(this.allowedRegistries);
    }
    /**
     * This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Host Runtime policies.
     * 
     */
    @Export(name="antivirusProtection", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> antivirusProtection;

    /**
     * @return This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Host Runtime policies.
     * 
     */
    public Output<Optional<Boolean>> antivirusProtection() {
        return Codegen.optional(this.antivirusProtection);
    }
    /**
     * Aqua server version
     * 
     */
    @Export(name="aquaVersion", type=String.class, parameters={})
    private Output<String> aquaVersion;

    /**
     * @return Aqua server version
     * 
     */
    public Output<String> aquaVersion() {
        return this.aquaVersion;
    }
    /**
     * Agent will send extra audit messages to the server for success operations from inside the container (runtime).
     * 
     */
    @Export(name="auditAll", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> auditAll;

    /**
     * @return Agent will send extra audit messages to the server for success operations from inside the container (runtime).
     * 
     */
    public Output<Optional<Boolean>> auditAll() {
        return Codegen.optional(this.auditAll);
    }
    /**
     * This option is applicable only if `Enable Pod Enforcer injection` is selected. Select this option if you want Aqua Enterprise to copy the secrets defined above to the Pod Enforcer namespace and container. Otherwise, you can choose to copy these secrets by other means.
     * 
     */
    @Export(name="autoCopySecrets", type=Boolean.class, parameters={})
    private Output<Boolean> autoCopySecrets;

    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected. Select this option if you want Aqua Enterprise to copy the secrets defined above to the Pod Enforcer namespace and container. Otherwise, you can choose to copy these secrets by other means.
     * 
     */
    public Output<Boolean> autoCopySecrets() {
        return this.autoCopySecrets;
    }
    /**
     * This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will add previously unknown image registries from the cluster to Aqua.
     * 
     */
    @Export(name="autoDiscoverConfigureRegistries", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> autoDiscoverConfigureRegistries;

    /**
     * @return This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will add previously unknown image registries from the cluster to Aqua.
     * 
     */
    public Output<Optional<Boolean>> autoDiscoverConfigureRegistries() {
        return Codegen.optional(this.autoDiscoverConfigureRegistries);
    }
    /**
     * When this option is selected, the KubeEnforcer will discover workloads on its cluster.
     * 
     */
    @Export(name="autoDiscoveryEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> autoDiscoveryEnabled;

    /**
     * @return When this option is selected, the KubeEnforcer will discover workloads on its cluster.
     * 
     */
    public Output<Optional<Boolean>> autoDiscoveryEnabled() {
        return Codegen.optional(this.autoDiscoveryEnabled);
    }
    /**
     * This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will automatically register images running as workloads (and scan the discovered images for security issues).
     * 
     */
    @Export(name="autoScanDiscoveredImagesRunningContainers", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> autoScanDiscoveredImagesRunningContainers;

    /**
     * @return This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will automatically register images running as workloads (and scan the discovered images for security issues).
     * 
     */
    public Output<Optional<Boolean>> autoScanDiscoveredImagesRunningContainers() {
        return Codegen.optional(this.autoScanDiscoveredImagesRunningContainers);
    }
    /**
     * Select Enabled to detect suspicious activity in your containers and display potential security threats in the Incidents and Audit pages.
     * 
     */
    @Export(name="behavioralEngine", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> behavioralEngine;

    /**
     * @return Select Enabled to detect suspicious activity in your containers and display potential security threats in the Incidents and Audit pages.
     * 
     */
    public Output<Optional<Boolean>> behavioralEngine() {
        return Codegen.optional(this.behavioralEngine);
    }
    /**
     * This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    @Export(name="blockAdmissionControl", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> blockAdmissionControl;

    /**
     * @return This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    public Output<Optional<Boolean>> blockAdmissionControl() {
        return Codegen.optional(this.blockAdmissionControl);
    }
    /**
     * The installation command.
     * 
     */
    @Export(name="commands", type=List.class, parameters={EnforcerGroupsCommand.class})
    private Output<List<EnforcerGroupsCommand>> commands;

    /**
     * @return The installation command.
     * 
     */
    public Output<List<EnforcerGroupsCommand>> commands() {
        return this.commands;
    }
    /**
     * Number of connected enforcers in the enforcer group.
     * 
     */
    @Export(name="connectedCount", type=Integer.class, parameters={})
    private Output<Integer> connectedCount;

    /**
     * @return Number of connected enforcers in the enforcer group.
     * 
     */
    public Output<Integer> connectedCount() {
        return this.connectedCount;
    }
    /**
     * Set `True` to apply Container Runtime Policies, Image Profiles, and Firewall Policies to containers.
     * 
     */
    @Export(name="containerActivityProtection", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> containerActivityProtection;

    /**
     * @return Set `True` to apply Container Runtime Policies, Image Profiles, and Firewall Policies to containers.
     * 
     */
    public Output<Optional<Boolean>> containerActivityProtection() {
        return Codegen.optional(this.containerActivityProtection);
    }
    /**
     * This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Container Runtime policies.
     * 
     */
    @Export(name="containerAntivirusProtection", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> containerAntivirusProtection;

    /**
     * @return This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Container Runtime policies.
     * 
     */
    public Output<Optional<Boolean>> containerAntivirusProtection() {
        return Codegen.optional(this.containerAntivirusProtection);
    }
    /**
     * A description of the Aqua Enforcer group.
     * 
     */
    @Export(name="description", type=String.class, parameters={})
    private Output</* @Nullable */ String> description;

    /**
     * @return A description of the Aqua Enforcer group.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Number of disconnected enforcers in the enforcer group.
     * 
     */
    @Export(name="disconnectedCount", type=Integer.class, parameters={})
    private Output<Integer> disconnectedCount;

    /**
     * @return Number of disconnected enforcers in the enforcer group.
     * 
     */
    public Output<Integer> disconnectedCount() {
        return this.disconnectedCount;
    }
    /**
     * Whether to enable enforce mode on the Enforcers, defaults to False.
     * 
     */
    @Export(name="enforce", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> enforce;

    /**
     * @return Whether to enable enforce mode on the Enforcers, defaults to False.
     * 
     */
    public Output<Optional<Boolean>> enforce() {
        return Codegen.optional(this.enforce);
    }
    /**
     * The specific Aqua Enforcer product image (with image tag) to be deployed.
     * 
     */
    @Export(name="enforcerImageName", type=String.class, parameters={})
    private Output<String> enforcerImageName;

    /**
     * @return The specific Aqua Enforcer product image (with image tag) to be deployed.
     * 
     */
    public Output<String> enforcerImageName() {
        return this.enforcerImageName;
    }
    /**
     * Select Enabled to send activity logs in your containers to the Aqua Server for forensics purposes.
     * 
     */
    @Export(name="forensics", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> forensics;

    /**
     * @return Select Enabled to send activity logs in your containers to the Aqua Server for forensics purposes.
     * 
     */
    public Output<Optional<Boolean>> forensics() {
        return Codegen.optional(this.forensics);
    }
    /**
     * Gateway Address
     * 
     */
    @Export(name="gatewayAddress", type=String.class, parameters={})
    private Output<String> gatewayAddress;

    /**
     * @return Gateway Address
     * 
     */
    public Output<String> gatewayAddress() {
        return this.gatewayAddress;
    }
    /**
     * Gateway Name
     * 
     */
    @Export(name="gatewayName", type=String.class, parameters={})
    private Output<String> gatewayName;

    /**
     * @return Gateway Name
     * 
     */
    public Output<String> gatewayName() {
        return this.gatewayName;
    }
    /**
     * List of Aqua gateway IDs for the Enforcers.
     * 
     */
    @Export(name="gateways", type=List.class, parameters={String.class})
    private Output<List<String>> gateways;

    /**
     * @return List of Aqua gateway IDs for the Enforcers.
     * 
     */
    public Output<List<String>> gateways() {
        return this.gateways;
    }
    /**
     * The ID of the Enforcer group.
     * 
     */
    @Export(name="groupId", type=String.class, parameters={})
    private Output<String> groupId;

    /**
     * @return The ID of the Enforcer group.
     * 
     */
    public Output<String> groupId() {
        return this.groupId;
    }
    /**
     * Number of high vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    @Export(name="highVulns", type=Integer.class, parameters={})
    private Output<Integer> highVulns;

    /**
     * @return Number of high vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Output<Integer> highVulns() {
        return this.highVulns;
    }
    /**
     * Set `True` to enable host scanning and respective Host Assurance controls.
     * 
     */
    @Export(name="hostAssurance", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> hostAssurance;

    /**
     * @return Set `True` to enable host scanning and respective Host Assurance controls.
     * 
     */
    public Output<Optional<Boolean>> hostAssurance() {
        return Codegen.optional(this.hostAssurance);
    }
    /**
     * Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    @Export(name="hostBehavioralEngine", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> hostBehavioralEngine;

    /**
     * @return Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    public Output<Optional<Boolean>> hostBehavioralEngine() {
        return Codegen.optional(this.hostBehavioralEngine);
    }
    /**
     * Select Enabled to send activity logs in your host to the Aqua Server for forensics purposes.
     * 
     */
    @Export(name="hostForensics", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> hostForensics;

    /**
     * @return Select Enabled to send activity logs in your host to the Aqua Server for forensics purposes.
     * 
     */
    public Output<Optional<Boolean>> hostForensics() {
        return Codegen.optional(this.hostForensics);
    }
    /**
     * Set `True` to apply Firewall Policies to hosts, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information
     * 
     */
    @Export(name="hostNetworkProtection", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> hostNetworkProtection;

    /**
     * @return Set `True` to apply Firewall Policies to hosts, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information
     * 
     */
    public Output<Optional<Boolean>> hostNetworkProtection() {
        return Codegen.optional(this.hostNetworkProtection);
    }
    /**
     * The OS type for the host
     * 
     */
    @Export(name="hostOs", type=String.class, parameters={})
    private Output<String> hostOs;

    /**
     * @return The OS type for the host
     * 
     */
    public Output<String> hostOs() {
        return this.hostOs;
    }
    /**
     * Set `True` to enable all Host Runtime Policy controls except for `OS Users and Groups Allowed` and `OS Users and Groups Blocked`.
     * 
     */
    @Export(name="hostProtection", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> hostProtection;

    /**
     * @return Set `True` to enable all Host Runtime Policy controls except for `OS Users and Groups Allowed` and `OS Users and Groups Blocked`.
     * 
     */
    public Output<Optional<Boolean>> hostProtection() {
        return Codegen.optional(this.hostProtection);
    }
    /**
     * Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    @Export(name="hostUserProtection", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> hostUserProtection;

    /**
     * @return Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    public Output<Optional<Boolean>> hostUserProtection() {
        return Codegen.optional(this.hostUserProtection);
    }
    /**
     * The hostname
     * 
     */
    @Export(name="hostname", type=String.class, parameters={})
    private Output<String> hostname;

    /**
     * @return The hostname
     * 
     */
    public Output<String> hostname() {
        return this.hostname;
    }
    /**
     * Number of enforcers in the enforcer group.
     * 
     */
    @Export(name="hostsCount", type=Integer.class, parameters={})
    private Output<Integer> hostsCount;

    /**
     * @return Number of enforcers in the enforcer group.
     * 
     */
    public Output<Integer> hostsCount() {
        return this.hostsCount;
    }
    /**
     * Set `True` to enable selected controls: Container Runtime Policy (`Block Non-Compliant Images`, `Block Unregistered Images`, and `Registries Allowed`) and Default Image Assurance Policy (`Images Blocked`).
     * 
     */
    @Export(name="imageAssurance", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> imageAssurance;

    /**
     * @return Set `True` to enable selected controls: Container Runtime Policy (`Block Non-Compliant Images`, `Block Unregistered Images`, and `Registries Allowed`) and Default Image Assurance Policy (`Images Blocked`).
     * 
     */
    public Output<Optional<Boolean>> imageAssurance() {
        return Codegen.optional(this.imageAssurance);
    }
    /**
     * Enforcer install command
     * 
     */
    @Export(name="installCommand", type=String.class, parameters={})
    private Output<String> installCommand;

    /**
     * @return Enforcer install command
     * 
     */
    public Output<String> installCommand() {
        return this.installCommand;
    }
    /**
     * See https://docs.aquasec.com/docs/securing-kubernetes-applications#section-configuration-hardening, The KubeEnforcer can deploy the Aqua Security kube-bench open-source product to perform Kubernetes CIS benchmark testing of nodes.
     * 			This field specifies the path and file name of the kube-bench product image for the KubeEnforcer to deploy; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    @Export(name="kubeBenchImageName", type=String.class, parameters={})
    private Output<String> kubeBenchImageName;

    /**
     * @return See https://docs.aquasec.com/docs/securing-kubernetes-applications#section-configuration-hardening, The KubeEnforcer can deploy the Aqua Security kube-bench open-source product to perform Kubernetes CIS benchmark testing of nodes.
     * 			This field specifies the path and file name of the kube-bench product image for the KubeEnforcer to deploy; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    public Output<String> kubeBenchImageName() {
        return this.kubeBenchImageName;
    }
    /**
     * The last date and time the batch token was updated in UNIX time.
     * 
     */
    @Export(name="lastUpdate", type=Integer.class, parameters={})
    private Output<Integer> lastUpdate;

    /**
     * @return The last date and time the batch token was updated in UNIX time.
     * 
     */
    public Output<Integer> lastUpdate() {
        return this.lastUpdate;
    }
    /**
     * Name for the batch install record.
     * 
     */
    @Export(name="logicalName", type=String.class, parameters={})
    private Output<String> logicalName;

    /**
     * @return Name for the batch install record.
     * 
     */
    public Output<String> logicalName() {
        return this.logicalName;
    }
    /**
     * Number of low vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    @Export(name="lowVulns", type=Integer.class, parameters={})
    private Output<Integer> lowVulns;

    /**
     * @return Number of low vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Output<Integer> lowVulns() {
        return this.lowVulns;
    }
    /**
     * Number of medium vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    @Export(name="medVulns", type=Integer.class, parameters={})
    private Output<Integer> medVulns;

    /**
     * @return Number of medium vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Output<Integer> medVulns() {
        return this.medVulns;
    }
    /**
     * This option is applicable only if `Enable Pod Enforcer injection` is selected.
     * 
     */
    @Export(name="microEnforcerCertsSecretsName", type=String.class, parameters={})
    private Output</* @Nullable */ String> microEnforcerCertsSecretsName;

    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected.
     * 
     */
    public Output<Optional<String>> microEnforcerCertsSecretsName() {
        return Codegen.optional(this.microEnforcerCertsSecretsName);
    }
    /**
     * This option is applicable only if `Enable Pod Enforcer injection` is selected. This field specifies the path and file name of the KubeEnforcer product image to be deployed; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    @Export(name="microEnforcerImageName", type=String.class, parameters={})
    private Output<String> microEnforcerImageName;

    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected. This field specifies the path and file name of the KubeEnforcer product image to be deployed; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    public Output<String> microEnforcerImageName() {
        return this.microEnforcerImageName;
    }
    /**
     * This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    @Export(name="microEnforcerInjection", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> microEnforcerInjection;

    /**
     * @return This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    public Output<Optional<Boolean>> microEnforcerInjection() {
        return Codegen.optional(this.microEnforcerInjection);
    }
    /**
     * You can specify the name of the secret (in the Aqua namespace) that Aqua copies into the Pod Enforcer namespace and kube-bench, allowing them access to the Pod Enforcer and kube-bench product images, respectively.
     * 
     */
    @Export(name="microEnforcerSecretsName", type=String.class, parameters={})
    private Output<String> microEnforcerSecretsName;

    /**
     * @return You can specify the name of the secret (in the Aqua namespace) that Aqua copies into the Pod Enforcer namespace and kube-bench, allowing them access to the Pod Enforcer and kube-bench product images, respectively.
     * 
     */
    public Output<String> microEnforcerSecretsName() {
        return this.microEnforcerSecretsName;
    }
    /**
     * Number of negligible vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    @Export(name="negVulns", type=Integer.class, parameters={})
    private Output<Integer> negVulns;

    /**
     * @return Number of negligible vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Output<Integer> negVulns() {
        return this.negVulns;
    }
    /**
     * Send true to apply Firewall Policies to containers, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information.
     * 
     */
    @Export(name="networkProtection", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> networkProtection;

    /**
     * @return Send true to apply Firewall Policies to containers, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information.
     * 
     */
    public Output<Optional<Boolean>> networkProtection() {
        return Codegen.optional(this.networkProtection);
    }
    /**
     * The orchestrator for which you are creating the Enforcer group.
     * 
     */
    @Export(name="orchestrators", type=List.class, parameters={EnforcerGroupsOrchestrator.class})
    private Output<List<EnforcerGroupsOrchestrator>> orchestrators;

    /**
     * @return The orchestrator for which you are creating the Enforcer group.
     * 
     */
    public Output<List<EnforcerGroupsOrchestrator>> orchestrators() {
        return this.orchestrators;
    }
    /**
     * pas deployment link
     * 
     */
    @Export(name="pasDeploymentLink", type=String.class, parameters={})
    private Output<String> pasDeploymentLink;

    /**
     * @return pas deployment link
     * 
     */
    public Output<String> pasDeploymentLink() {
        return this.pasDeploymentLink;
    }
    /**
     * Permission Action
     * 
     */
    @Export(name="permission", type=String.class, parameters={})
    private Output</* @Nullable */ String> permission;

    /**
     * @return Permission Action
     * 
     */
    public Output<Optional<String>> permission() {
        return Codegen.optional(this.permission);
    }
    /**
     * Set `True` to allow Enforcers to be discovered in the Risk Explorer.
     * 
     */
    @Export(name="riskExplorerAutoDiscovery", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> riskExplorerAutoDiscovery;

    /**
     * @return Set `True` to allow Enforcers to be discovered in the Risk Explorer.
     * 
     */
    public Output<Optional<Boolean>> riskExplorerAutoDiscovery() {
        return Codegen.optional(this.riskExplorerAutoDiscovery);
    }
    /**
     * Function Runtime Policy that will applay on the nano enforcer.
     * 
     */
    @Export(name="runtimePolicyName", type=String.class, parameters={})
    private Output<String> runtimePolicyName;

    /**
     * @return Function Runtime Policy that will applay on the nano enforcer.
     * 
     */
    public Output<String> runtimePolicyName() {
        return this.runtimePolicyName;
    }
    /**
     * The container runtime environment.
     * 
     */
    @Export(name="runtimeType", type=String.class, parameters={})
    private Output<String> runtimeType;

    /**
     * @return The container runtime environment.
     * 
     */
    public Output<String> runtimeType() {
        return this.runtimeType;
    }
    /**
     * Set `True` to configure Enforcers to discover local host images. Discovered images will be listed under Images &gt; Host Images, as well as under Infrastructure (in the Images tab for applicable hosts).
     * 
     */
    @Export(name="syncHostImages", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> syncHostImages;

    /**
     * @return Set `True` to configure Enforcers to discover local host images. Discovered images will be listed under Images &gt; Host Images, as well as under Infrastructure (in the Images tab for applicable hosts).
     * 
     */
    public Output<Optional<Boolean>> syncHostImages() {
        return Codegen.optional(this.syncHostImages);
    }
    /**
     * Set `True` will allow profiling and monitoring system calls made by running containers.
     * 
     */
    @Export(name="syscallEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> syscallEnabled;

    /**
     * @return Set `True` will allow profiling and monitoring system calls made by running containers.
     * 
     */
    public Output<Optional<Boolean>> syscallEnabled() {
        return Codegen.optional(this.syscallEnabled);
    }
    /**
     * The batch install token.
     * 
     */
    @Export(name="token", type=String.class, parameters={})
    private Output<String> token;

    /**
     * @return The batch install token.
     * 
     */
    public Output<String> token() {
        return this.token;
    }
    /**
     * Enforcer Type.
     * 
     */
    @Export(name="type", type=String.class, parameters={})
    private Output<String> type;

    /**
     * @return Enforcer Type.
     * 
     */
    public Output<String> type() {
        return this.type;
    }
    /**
     * Set `True` to apply User Access Control Policies to containers. Note that Aqua Enforcers must be deployed with the AQUA*RUNC*INTERCEPTION environment variable set to 0 in order to use User Access Control Policies.
     * 
     */
    @Export(name="userAccessControl", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> userAccessControl;

    /**
     * @return Set `True` to apply User Access Control Policies to containers. Note that Aqua Enforcers must be deployed with the AQUA*RUNC*INTERCEPTION environment variable set to 0 in order to use User Access Control Policies.
     * 
     */
    public Output<Optional<Boolean>> userAccessControl() {
        return Codegen.optional(this.userAccessControl);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public EnforcerGroups(String name) {
        this(name, EnforcerGroupsArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public EnforcerGroups(String name, EnforcerGroupsArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public EnforcerGroups(String name, EnforcerGroupsArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("aquasec:index/enforcerGroups:EnforcerGroups", name, args == null ? EnforcerGroupsArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private EnforcerGroups(String name, Output<String> id, @Nullable EnforcerGroupsState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("aquasec:index/enforcerGroups:EnforcerGroups", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static EnforcerGroups get(String name, Output<String> id, @Nullable EnforcerGroupsState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new EnforcerGroups(name, id, state, options);
    }
}
