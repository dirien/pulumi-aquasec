// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumiverse.aquasec;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumiverse.aquasec.inputs.FunctionRuntimePolicyScopeVariableArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class FunctionRuntimePolicyArgs extends com.pulumi.resources.ResourceArgs {

    public static final FunctionRuntimePolicyArgs Empty = new FunctionRuntimePolicyArgs();

    /**
     * Indicates the application scope of the service.
     * 
     */
    @Import(name="applicationScopes")
    private @Nullable Output<List<String>> applicationScopes;

    /**
     * @return Indicates the application scope of the service.
     * 
     */
    public Optional<Output<List<String>>> applicationScopes() {
        return Optional.ofNullable(this.applicationScopes);
    }

    /**
     * If true, prevent creation of malicious executables in functions during their runtime post invocation.
     * 
     */
    @Import(name="blockMaliciousExecutables")
    private @Nullable Output<Boolean> blockMaliciousExecutables;

    /**
     * @return If true, prevent creation of malicious executables in functions during their runtime post invocation.
     * 
     */
    public Optional<Output<Boolean>> blockMaliciousExecutables() {
        return Optional.ofNullable(this.blockMaliciousExecutables);
    }

    /**
     * List of processes that will be allowed
     * 
     */
    @Import(name="blockMaliciousExecutablesAllowedProcesses")
    private @Nullable Output<List<String>> blockMaliciousExecutablesAllowedProcesses;

    /**
     * @return List of processes that will be allowed
     * 
     */
    public Optional<Output<List<String>>> blockMaliciousExecutablesAllowedProcesses() {
        return Optional.ofNullable(this.blockMaliciousExecutablesAllowedProcesses);
    }

    /**
     * If true, prevent running of executables in functions locate in /tmp folder during their runtime post invocation.
     * 
     */
    @Import(name="blockRunningExecutablesInTmpFolder")
    private @Nullable Output<Boolean> blockRunningExecutablesInTmpFolder;

    /**
     * @return If true, prevent running of executables in functions locate in /tmp folder during their runtime post invocation.
     * 
     */
    public Optional<Output<Boolean>> blockRunningExecutablesInTmpFolder() {
        return Optional.ofNullable(this.blockRunningExecutablesInTmpFolder);
    }

    /**
     * List of executables that are prevented from running in containers.
     * 
     */
    @Import(name="blockedExecutables")
    private @Nullable Output<List<String>> blockedExecutables;

    /**
     * @return List of executables that are prevented from running in containers.
     * 
     */
    public Optional<Output<List<String>>> blockedExecutables() {
        return Optional.ofNullable(this.blockedExecutables);
    }

    /**
     * The description of the function runtime policy
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return The description of the function runtime policy
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Indicates if the runtime policy is enabled or not.
     * 
     */
    @Import(name="enabled")
    private @Nullable Output<Boolean> enabled;

    /**
     * @return Indicates if the runtime policy is enabled or not.
     * 
     */
    public Optional<Output<Boolean>> enabled() {
        return Optional.ofNullable(this.enabled);
    }

    /**
     * Indicates that policy should effect container execution (not just for audit).
     * 
     */
    @Import(name="enforce")
    private @Nullable Output<Boolean> enforce;

    /**
     * @return Indicates that policy should effect container execution (not just for audit).
     * 
     */
    public Optional<Output<Boolean>> enforce() {
        return Optional.ofNullable(this.enforce);
    }

    /**
     * Honeypot User ID (Access Key)
     * 
     */
    @Import(name="honeypotAccessKey")
    private @Nullable Output<String> honeypotAccessKey;

    /**
     * @return Honeypot User ID (Access Key)
     * 
     */
    public Optional<Output<String>> honeypotAccessKey() {
        return Optional.ofNullable(this.honeypotAccessKey);
    }

    /**
     * List of options to apply the honeypot on (Environment Vairable, Layer, File)
     * 
     */
    @Import(name="honeypotApplyOns")
    private @Nullable Output<List<String>> honeypotApplyOns;

    /**
     * @return List of options to apply the honeypot on (Environment Vairable, Layer, File)
     * 
     */
    public Optional<Output<List<String>>> honeypotApplyOns() {
        return Optional.ofNullable(this.honeypotApplyOns);
    }

    /**
     * Honeypot User Password (Secret Key)
     * 
     */
    @Import(name="honeypotSecretKey")
    private @Nullable Output<String> honeypotSecretKey;

    /**
     * @return Honeypot User Password (Secret Key)
     * 
     */
    public Optional<Output<String>> honeypotSecretKey() {
        return Optional.ofNullable(this.honeypotSecretKey);
    }

    /**
     * Serverless application name
     * 
     */
    @Import(name="honeypotServerlessAppName")
    private @Nullable Output<String> honeypotServerlessAppName;

    /**
     * @return Serverless application name
     * 
     */
    public Optional<Output<String>> honeypotServerlessAppName() {
        return Optional.ofNullable(this.honeypotServerlessAppName);
    }

    /**
     * Name of the function runtime policy
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Name of the function runtime policy
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Logical expression of how to compute the dependency of the scope variables.
     * 
     */
    @Import(name="scopeExpression")
    private @Nullable Output<String> scopeExpression;

    /**
     * @return Logical expression of how to compute the dependency of the scope variables.
     * 
     */
    public Optional<Output<String>> scopeExpression() {
        return Optional.ofNullable(this.scopeExpression);
    }

    /**
     * List of scope attributes.
     * 
     */
    @Import(name="scopeVariables")
    private @Nullable Output<List<FunctionRuntimePolicyScopeVariableArgs>> scopeVariables;

    /**
     * @return List of scope attributes.
     * 
     */
    public Optional<Output<List<FunctionRuntimePolicyScopeVariableArgs>>> scopeVariables() {
        return Optional.ofNullable(this.scopeVariables);
    }

    private FunctionRuntimePolicyArgs() {}

    private FunctionRuntimePolicyArgs(FunctionRuntimePolicyArgs $) {
        this.applicationScopes = $.applicationScopes;
        this.blockMaliciousExecutables = $.blockMaliciousExecutables;
        this.blockMaliciousExecutablesAllowedProcesses = $.blockMaliciousExecutablesAllowedProcesses;
        this.blockRunningExecutablesInTmpFolder = $.blockRunningExecutablesInTmpFolder;
        this.blockedExecutables = $.blockedExecutables;
        this.description = $.description;
        this.enabled = $.enabled;
        this.enforce = $.enforce;
        this.honeypotAccessKey = $.honeypotAccessKey;
        this.honeypotApplyOns = $.honeypotApplyOns;
        this.honeypotSecretKey = $.honeypotSecretKey;
        this.honeypotServerlessAppName = $.honeypotServerlessAppName;
        this.name = $.name;
        this.scopeExpression = $.scopeExpression;
        this.scopeVariables = $.scopeVariables;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(FunctionRuntimePolicyArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private FunctionRuntimePolicyArgs $;

        public Builder() {
            $ = new FunctionRuntimePolicyArgs();
        }

        public Builder(FunctionRuntimePolicyArgs defaults) {
            $ = new FunctionRuntimePolicyArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param applicationScopes Indicates the application scope of the service.
         * 
         * @return builder
         * 
         */
        public Builder applicationScopes(@Nullable Output<List<String>> applicationScopes) {
            $.applicationScopes = applicationScopes;
            return this;
        }

        /**
         * @param applicationScopes Indicates the application scope of the service.
         * 
         * @return builder
         * 
         */
        public Builder applicationScopes(List<String> applicationScopes) {
            return applicationScopes(Output.of(applicationScopes));
        }

        /**
         * @param applicationScopes Indicates the application scope of the service.
         * 
         * @return builder
         * 
         */
        public Builder applicationScopes(String... applicationScopes) {
            return applicationScopes(List.of(applicationScopes));
        }

        /**
         * @param blockMaliciousExecutables If true, prevent creation of malicious executables in functions during their runtime post invocation.
         * 
         * @return builder
         * 
         */
        public Builder blockMaliciousExecutables(@Nullable Output<Boolean> blockMaliciousExecutables) {
            $.blockMaliciousExecutables = blockMaliciousExecutables;
            return this;
        }

        /**
         * @param blockMaliciousExecutables If true, prevent creation of malicious executables in functions during their runtime post invocation.
         * 
         * @return builder
         * 
         */
        public Builder blockMaliciousExecutables(Boolean blockMaliciousExecutables) {
            return blockMaliciousExecutables(Output.of(blockMaliciousExecutables));
        }

        /**
         * @param blockMaliciousExecutablesAllowedProcesses List of processes that will be allowed
         * 
         * @return builder
         * 
         */
        public Builder blockMaliciousExecutablesAllowedProcesses(@Nullable Output<List<String>> blockMaliciousExecutablesAllowedProcesses) {
            $.blockMaliciousExecutablesAllowedProcesses = blockMaliciousExecutablesAllowedProcesses;
            return this;
        }

        /**
         * @param blockMaliciousExecutablesAllowedProcesses List of processes that will be allowed
         * 
         * @return builder
         * 
         */
        public Builder blockMaliciousExecutablesAllowedProcesses(List<String> blockMaliciousExecutablesAllowedProcesses) {
            return blockMaliciousExecutablesAllowedProcesses(Output.of(blockMaliciousExecutablesAllowedProcesses));
        }

        /**
         * @param blockMaliciousExecutablesAllowedProcesses List of processes that will be allowed
         * 
         * @return builder
         * 
         */
        public Builder blockMaliciousExecutablesAllowedProcesses(String... blockMaliciousExecutablesAllowedProcesses) {
            return blockMaliciousExecutablesAllowedProcesses(List.of(blockMaliciousExecutablesAllowedProcesses));
        }

        /**
         * @param blockRunningExecutablesInTmpFolder If true, prevent running of executables in functions locate in /tmp folder during their runtime post invocation.
         * 
         * @return builder
         * 
         */
        public Builder blockRunningExecutablesInTmpFolder(@Nullable Output<Boolean> blockRunningExecutablesInTmpFolder) {
            $.blockRunningExecutablesInTmpFolder = blockRunningExecutablesInTmpFolder;
            return this;
        }

        /**
         * @param blockRunningExecutablesInTmpFolder If true, prevent running of executables in functions locate in /tmp folder during their runtime post invocation.
         * 
         * @return builder
         * 
         */
        public Builder blockRunningExecutablesInTmpFolder(Boolean blockRunningExecutablesInTmpFolder) {
            return blockRunningExecutablesInTmpFolder(Output.of(blockRunningExecutablesInTmpFolder));
        }

        /**
         * @param blockedExecutables List of executables that are prevented from running in containers.
         * 
         * @return builder
         * 
         */
        public Builder blockedExecutables(@Nullable Output<List<String>> blockedExecutables) {
            $.blockedExecutables = blockedExecutables;
            return this;
        }

        /**
         * @param blockedExecutables List of executables that are prevented from running in containers.
         * 
         * @return builder
         * 
         */
        public Builder blockedExecutables(List<String> blockedExecutables) {
            return blockedExecutables(Output.of(blockedExecutables));
        }

        /**
         * @param blockedExecutables List of executables that are prevented from running in containers.
         * 
         * @return builder
         * 
         */
        public Builder blockedExecutables(String... blockedExecutables) {
            return blockedExecutables(List.of(blockedExecutables));
        }

        /**
         * @param description The description of the function runtime policy
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description The description of the function runtime policy
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param enabled Indicates if the runtime policy is enabled or not.
         * 
         * @return builder
         * 
         */
        public Builder enabled(@Nullable Output<Boolean> enabled) {
            $.enabled = enabled;
            return this;
        }

        /**
         * @param enabled Indicates if the runtime policy is enabled or not.
         * 
         * @return builder
         * 
         */
        public Builder enabled(Boolean enabled) {
            return enabled(Output.of(enabled));
        }

        /**
         * @param enforce Indicates that policy should effect container execution (not just for audit).
         * 
         * @return builder
         * 
         */
        public Builder enforce(@Nullable Output<Boolean> enforce) {
            $.enforce = enforce;
            return this;
        }

        /**
         * @param enforce Indicates that policy should effect container execution (not just for audit).
         * 
         * @return builder
         * 
         */
        public Builder enforce(Boolean enforce) {
            return enforce(Output.of(enforce));
        }

        /**
         * @param honeypotAccessKey Honeypot User ID (Access Key)
         * 
         * @return builder
         * 
         */
        public Builder honeypotAccessKey(@Nullable Output<String> honeypotAccessKey) {
            $.honeypotAccessKey = honeypotAccessKey;
            return this;
        }

        /**
         * @param honeypotAccessKey Honeypot User ID (Access Key)
         * 
         * @return builder
         * 
         */
        public Builder honeypotAccessKey(String honeypotAccessKey) {
            return honeypotAccessKey(Output.of(honeypotAccessKey));
        }

        /**
         * @param honeypotApplyOns List of options to apply the honeypot on (Environment Vairable, Layer, File)
         * 
         * @return builder
         * 
         */
        public Builder honeypotApplyOns(@Nullable Output<List<String>> honeypotApplyOns) {
            $.honeypotApplyOns = honeypotApplyOns;
            return this;
        }

        /**
         * @param honeypotApplyOns List of options to apply the honeypot on (Environment Vairable, Layer, File)
         * 
         * @return builder
         * 
         */
        public Builder honeypotApplyOns(List<String> honeypotApplyOns) {
            return honeypotApplyOns(Output.of(honeypotApplyOns));
        }

        /**
         * @param honeypotApplyOns List of options to apply the honeypot on (Environment Vairable, Layer, File)
         * 
         * @return builder
         * 
         */
        public Builder honeypotApplyOns(String... honeypotApplyOns) {
            return honeypotApplyOns(List.of(honeypotApplyOns));
        }

        /**
         * @param honeypotSecretKey Honeypot User Password (Secret Key)
         * 
         * @return builder
         * 
         */
        public Builder honeypotSecretKey(@Nullable Output<String> honeypotSecretKey) {
            $.honeypotSecretKey = honeypotSecretKey;
            return this;
        }

        /**
         * @param honeypotSecretKey Honeypot User Password (Secret Key)
         * 
         * @return builder
         * 
         */
        public Builder honeypotSecretKey(String honeypotSecretKey) {
            return honeypotSecretKey(Output.of(honeypotSecretKey));
        }

        /**
         * @param honeypotServerlessAppName Serverless application name
         * 
         * @return builder
         * 
         */
        public Builder honeypotServerlessAppName(@Nullable Output<String> honeypotServerlessAppName) {
            $.honeypotServerlessAppName = honeypotServerlessAppName;
            return this;
        }

        /**
         * @param honeypotServerlessAppName Serverless application name
         * 
         * @return builder
         * 
         */
        public Builder honeypotServerlessAppName(String honeypotServerlessAppName) {
            return honeypotServerlessAppName(Output.of(honeypotServerlessAppName));
        }

        /**
         * @param name Name of the function runtime policy
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Name of the function runtime policy
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param scopeExpression Logical expression of how to compute the dependency of the scope variables.
         * 
         * @return builder
         * 
         */
        public Builder scopeExpression(@Nullable Output<String> scopeExpression) {
            $.scopeExpression = scopeExpression;
            return this;
        }

        /**
         * @param scopeExpression Logical expression of how to compute the dependency of the scope variables.
         * 
         * @return builder
         * 
         */
        public Builder scopeExpression(String scopeExpression) {
            return scopeExpression(Output.of(scopeExpression));
        }

        /**
         * @param scopeVariables List of scope attributes.
         * 
         * @return builder
         * 
         */
        public Builder scopeVariables(@Nullable Output<List<FunctionRuntimePolicyScopeVariableArgs>> scopeVariables) {
            $.scopeVariables = scopeVariables;
            return this;
        }

        /**
         * @param scopeVariables List of scope attributes.
         * 
         * @return builder
         * 
         */
        public Builder scopeVariables(List<FunctionRuntimePolicyScopeVariableArgs> scopeVariables) {
            return scopeVariables(Output.of(scopeVariables));
        }

        /**
         * @param scopeVariables List of scope attributes.
         * 
         * @return builder
         * 
         */
        public Builder scopeVariables(FunctionRuntimePolicyScopeVariableArgs... scopeVariables) {
            return scopeVariables(List.of(scopeVariables));
        }

        public FunctionRuntimePolicyArgs build() {
            return $;
        }
    }

}
