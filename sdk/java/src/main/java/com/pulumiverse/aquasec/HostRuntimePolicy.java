// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumiverse.aquasec;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumiverse.aquasec.HostRuntimePolicyArgs;
import com.pulumiverse.aquasec.Utilities;
import com.pulumiverse.aquasec.inputs.HostRuntimePolicyState;
import com.pulumiverse.aquasec.outputs.HostRuntimePolicyFileIntegrityMonitoring;
import com.pulumiverse.aquasec.outputs.HostRuntimePolicyMalwareScanOptions;
import com.pulumiverse.aquasec.outputs.HostRuntimePolicyScopeVariable;
import com.pulumiverse.aquasec.outputs.HostRuntimePolicyWindowsRegistryMonitoring;
import com.pulumiverse.aquasec.outputs.HostRuntimePolicyWindowsRegistryProtection;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * ## Example Usage
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.aquasec.HostRuntimePolicy;
 * import com.pulumi.aquasec.HostRuntimePolicyArgs;
 * import com.pulumi.aquasec.inputs.HostRuntimePolicyFileIntegrityMonitoringArgs;
 * import com.pulumi.aquasec.inputs.HostRuntimePolicyWindowsRegistryMonitoringArgs;
 * import com.pulumi.aquasec.inputs.HostRuntimePolicyWindowsRegistryProtectionArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var hostRuntimePolicy = new HostRuntimePolicy(&#34;hostRuntimePolicy&#34;, HostRuntimePolicyArgs.builder()        
 *             .auditAllOsUserActivity(true)
 *             .auditBruteForceLogin(true)
 *             .auditFullCommandArguments(true)
 *             .auditHostFailedLoginEvents(true)
 *             .auditHostSuccessfulLoginEvents(true)
 *             .auditUserAccountManagement(true)
 *             .blockCryptocurrencyMining(true)
 *             .blockedFiles(&#34;blocked&#34;)
 *             .description(&#34;host_runtime_policy&#34;)
 *             .enableIpReputationSecurity(true)
 *             .enabled(true)
 *             .enforce(false)
 *             .fileIntegrityMonitoring(HostRuntimePolicyFileIntegrityMonitoringArgs.builder()
 *                 .excludedPaths(&#34;expaths&#34;)
 *                 .excludedProcesses(&#34;exprocess&#34;)
 *                 .excludedUsers(&#34;expuser&#34;)
 *                 .monitorAttributes(true)
 *                 .monitorCreate(true)
 *                 .monitorDelete(true)
 *                 .monitorModify(true)
 *                 .monitorRead(true)
 *                 .monitoredPaths(&#34;paths&#34;)
 *                 .monitoredProcesses(&#34;process&#34;)
 *                 .monitoredUsers(&#34;user&#34;)
 *                 .build())
 *             .monitorSystemLogIntegrity(true)
 *             .monitorSystemTimeChanges(true)
 *             .monitorWindowsServices(true)
 *             .osGroupsAlloweds(&#34;group1&#34;)
 *             .osGroupsBlockeds(&#34;group2&#34;)
 *             .osUsersAlloweds(&#34;user1&#34;)
 *             .osUsersBlockeds(&#34;user2&#34;)
 *             .packageBlocks(&#34;package1&#34;)
 *             .portScanningDetection(true)
 *             .windowsRegistryMonitoring(HostRuntimePolicyWindowsRegistryMonitoringArgs.builder()
 *                 .excludedPaths(&#34;expaths&#34;)
 *                 .excludedProcesses(&#34;exprocess&#34;)
 *                 .excludedUsers(&#34;expuser&#34;)
 *                 .monitorAttributes(true)
 *                 .monitorCreate(true)
 *                 .monitorDelete(true)
 *                 .monitorModify(true)
 *                 .monitorRead(true)
 *                 .monitoredPaths(&#34;paths&#34;)
 *                 .monitoredProcesses(&#34;process&#34;)
 *                 .monitoredUsers(&#34;user&#34;)
 *                 .build())
 *             .windowsRegistryProtection(HostRuntimePolicyWindowsRegistryProtectionArgs.builder()
 *                 .excludedPaths(&#34;expaths&#34;)
 *                 .excludedProcesses(&#34;exprocess&#34;)
 *                 .excludedUsers(&#34;expuser&#34;)
 *                 .protectedPaths(&#34;paths&#34;)
 *                 .protectedProcesses(&#34;process&#34;)
 *                 .protectedUsers(&#34;user&#34;)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 */
@ResourceType(type="aquasec:index/hostRuntimePolicy:HostRuntimePolicy")
public class HostRuntimePolicy extends com.pulumi.resources.CustomResource {
    /**
     * Indicates the application scope of the service.
     * 
     */
    @Export(name="applicationScopes", type=List.class, parameters={String.class})
    private Output<List<String>> applicationScopes;

    /**
     * @return Indicates the application scope of the service.
     * 
     */
    public Output<List<String>> applicationScopes() {
        return this.applicationScopes;
    }
    /**
     * If true, all process activity will be audited.
     * 
     */
    @Export(name="auditAllOsUserActivity", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> auditAllOsUserActivity;

    /**
     * @return If true, all process activity will be audited.
     * 
     */
    public Output<Optional<Boolean>> auditAllOsUserActivity() {
        return Codegen.optional(this.auditAllOsUserActivity);
    }
    /**
     * Detects brute force login attempts
     * 
     */
    @Export(name="auditBruteForceLogin", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> auditBruteForceLogin;

    /**
     * @return Detects brute force login attempts
     * 
     */
    public Output<Optional<Boolean>> auditBruteForceLogin() {
        return Codegen.optional(this.auditBruteForceLogin);
    }
    /**
     * If true, full command arguments will be audited.
     * 
     */
    @Export(name="auditFullCommandArguments", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> auditFullCommandArguments;

    /**
     * @return If true, full command arguments will be audited.
     * 
     */
    public Output<Optional<Boolean>> auditFullCommandArguments() {
        return Codegen.optional(this.auditFullCommandArguments);
    }
    /**
     * If true, host failed logins will be audited.
     * 
     */
    @Export(name="auditHostFailedLoginEvents", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> auditHostFailedLoginEvents;

    /**
     * @return If true, host failed logins will be audited.
     * 
     */
    public Output<Optional<Boolean>> auditHostFailedLoginEvents() {
        return Codegen.optional(this.auditHostFailedLoginEvents);
    }
    /**
     * If true, host successful logins will be audited.
     * 
     */
    @Export(name="auditHostSuccessfulLoginEvents", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> auditHostSuccessfulLoginEvents;

    /**
     * @return If true, host successful logins will be audited.
     * 
     */
    public Output<Optional<Boolean>> auditHostSuccessfulLoginEvents() {
        return Codegen.optional(this.auditHostSuccessfulLoginEvents);
    }
    /**
     * If true, account management will be audited.
     * 
     */
    @Export(name="auditUserAccountManagement", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> auditUserAccountManagement;

    /**
     * @return If true, account management will be audited.
     * 
     */
    public Output<Optional<Boolean>> auditUserAccountManagement() {
        return Codegen.optional(this.auditUserAccountManagement);
    }
    /**
     * Username of the account that created the service.
     * 
     */
    @Export(name="author", type=String.class, parameters={})
    private Output<String> author;

    /**
     * @return Username of the account that created the service.
     * 
     */
    public Output<String> author() {
        return this.author;
    }
    /**
     * Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
     * 
     */
    @Export(name="blockCryptocurrencyMining", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> blockCryptocurrencyMining;

    /**
     * @return Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
     * 
     */
    public Output<Optional<Boolean>> blockCryptocurrencyMining() {
        return Codegen.optional(this.blockCryptocurrencyMining);
    }
    /**
     * List of files that are prevented from being read, modified and executed in the containers.
     * 
     */
    @Export(name="blockedFiles", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> blockedFiles;

    /**
     * @return List of files that are prevented from being read, modified and executed in the containers.
     * 
     */
    public Output<Optional<List<String>>> blockedFiles() {
        return Codegen.optional(this.blockedFiles);
    }
    /**
     * The description of the host runtime policy
     * 
     */
    @Export(name="description", type=String.class, parameters={})
    private Output</* @Nullable */ String> description;

    /**
     * @return The description of the host runtime policy
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * If true, detect and prevent communication from containers to IP addresses known to have a bad reputation.
     * 
     */
    @Export(name="enableIpReputationSecurity", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> enableIpReputationSecurity;

    /**
     * @return If true, detect and prevent communication from containers to IP addresses known to have a bad reputation.
     * 
     */
    public Output<Optional<Boolean>> enableIpReputationSecurity() {
        return Codegen.optional(this.enableIpReputationSecurity);
    }
    /**
     * Indicates if the runtime policy is enabled or not.
     * 
     */
    @Export(name="enabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> enabled;

    /**
     * @return Indicates if the runtime policy is enabled or not.
     * 
     */
    public Output<Optional<Boolean>> enabled() {
        return Codegen.optional(this.enabled);
    }
    /**
     * Indicates that policy should effect container execution (not just for audit).
     * 
     */
    @Export(name="enforce", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> enforce;

    /**
     * @return Indicates that policy should effect container execution (not just for audit).
     * 
     */
    public Output<Optional<Boolean>> enforce() {
        return Codegen.optional(this.enforce);
    }
    /**
     * Indicates the number of days after which the runtime policy will be changed to enforce mode.
     * 
     */
    @Export(name="enforceAfterDays", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> enforceAfterDays;

    /**
     * @return Indicates the number of days after which the runtime policy will be changed to enforce mode.
     * 
     */
    public Output<Optional<Integer>> enforceAfterDays() {
        return Codegen.optional(this.enforceAfterDays);
    }
    /**
     * Configuration for file integrity monitoring.
     * 
     */
    @Export(name="fileIntegrityMonitoring", type=HostRuntimePolicyFileIntegrityMonitoring.class, parameters={})
    private Output</* @Nullable */ HostRuntimePolicyFileIntegrityMonitoring> fileIntegrityMonitoring;

    /**
     * @return Configuration for file integrity monitoring.
     * 
     */
    public Output<Optional<HostRuntimePolicyFileIntegrityMonitoring>> fileIntegrityMonitoring() {
        return Codegen.optional(this.fileIntegrityMonitoring);
    }
    /**
     * Configuration for Real-Time Malware Protection.
     * 
     */
    @Export(name="malwareScanOptions", type=HostRuntimePolicyMalwareScanOptions.class, parameters={})
    private Output</* @Nullable */ HostRuntimePolicyMalwareScanOptions> malwareScanOptions;

    /**
     * @return Configuration for Real-Time Malware Protection.
     * 
     */
    public Output<Optional<HostRuntimePolicyMalwareScanOptions>> malwareScanOptions() {
        return Codegen.optional(this.malwareScanOptions);
    }
    /**
     * If true, system log will be monitored.
     * 
     */
    @Export(name="monitorSystemLogIntegrity", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> monitorSystemLogIntegrity;

    /**
     * @return If true, system log will be monitored.
     * 
     */
    public Output<Optional<Boolean>> monitorSystemLogIntegrity() {
        return Codegen.optional(this.monitorSystemLogIntegrity);
    }
    /**
     * If true, system time changes will be monitored.
     * 
     */
    @Export(name="monitorSystemTimeChanges", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> monitorSystemTimeChanges;

    /**
     * @return If true, system time changes will be monitored.
     * 
     */
    public Output<Optional<Boolean>> monitorSystemTimeChanges() {
        return Codegen.optional(this.monitorSystemTimeChanges);
    }
    /**
     * If true, windows service operations will be monitored.
     * 
     */
    @Export(name="monitorWindowsServices", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> monitorWindowsServices;

    /**
     * @return If true, windows service operations will be monitored.
     * 
     */
    public Output<Optional<Boolean>> monitorWindowsServices() {
        return Codegen.optional(this.monitorWindowsServices);
    }
    /**
     * Name of the host runtime policy
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return Name of the host runtime policy
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * List of OS (Linux or Windows) groups that are allowed to authenticate to the host, and block authentication requests from all others. Groups can be either Linux groups or Windows AD groups.
     * 
     */
    @Export(name="osGroupsAlloweds", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> osGroupsAlloweds;

    /**
     * @return List of OS (Linux or Windows) groups that are allowed to authenticate to the host, and block authentication requests from all others. Groups can be either Linux groups or Windows AD groups.
     * 
     */
    public Output<Optional<List<String>>> osGroupsAlloweds() {
        return Codegen.optional(this.osGroupsAlloweds);
    }
    /**
     * List of OS (Linux or Windows) groups that are not allowed to authenticate to the host, and block authentication requests from all others. Groups can be either Linux groups or Windows AD groups.
     * 
     */
    @Export(name="osGroupsBlockeds", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> osGroupsBlockeds;

    /**
     * @return List of OS (Linux or Windows) groups that are not allowed to authenticate to the host, and block authentication requests from all others. Groups can be either Linux groups or Windows AD groups.
     * 
     */
    public Output<Optional<List<String>>> osGroupsBlockeds() {
        return Codegen.optional(this.osGroupsBlockeds);
    }
    /**
     * List of OS (Linux or Windows) users that are allowed to authenticate to the host, and block authentication requests from all others.
     * 
     */
    @Export(name="osUsersAlloweds", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> osUsersAlloweds;

    /**
     * @return List of OS (Linux or Windows) users that are allowed to authenticate to the host, and block authentication requests from all others.
     * 
     */
    public Output<Optional<List<String>>> osUsersAlloweds() {
        return Codegen.optional(this.osUsersAlloweds);
    }
    /**
     * List of OS (Linux or Windows) users that are not allowed to authenticate to the host, and block authentication requests from all others.
     * 
     */
    @Export(name="osUsersBlockeds", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> osUsersBlockeds;

    /**
     * @return List of OS (Linux or Windows) users that are not allowed to authenticate to the host, and block authentication requests from all others.
     * 
     */
    public Output<Optional<List<String>>> osUsersBlockeds() {
        return Codegen.optional(this.osUsersBlockeds);
    }
    /**
     * List of packages that are not allowed read, write or execute all files that under the packages.
     * 
     */
    @Export(name="packageBlocks", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> packageBlocks;

    /**
     * @return List of packages that are not allowed read, write or execute all files that under the packages.
     * 
     */
    public Output<Optional<List<String>>> packageBlocks() {
        return Codegen.optional(this.packageBlocks);
    }
    /**
     * If true, port scanning behaviors will be audited.
     * 
     */
    @Export(name="portScanningDetection", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> portScanningDetection;

    /**
     * @return If true, port scanning behaviors will be audited.
     * 
     */
    public Output<Optional<Boolean>> portScanningDetection() {
        return Codegen.optional(this.portScanningDetection);
    }
    /**
     * Logical expression of how to compute the dependency of the scope variables.
     * 
     */
    @Export(name="scopeExpression", type=String.class, parameters={})
    private Output<String> scopeExpression;

    /**
     * @return Logical expression of how to compute the dependency of the scope variables.
     * 
     */
    public Output<String> scopeExpression() {
        return this.scopeExpression;
    }
    /**
     * List of scope attributes.
     * 
     */
    @Export(name="scopeVariables", type=List.class, parameters={HostRuntimePolicyScopeVariable.class})
    private Output<List<HostRuntimePolicyScopeVariable>> scopeVariables;

    /**
     * @return List of scope attributes.
     * 
     */
    public Output<List<HostRuntimePolicyScopeVariable>> scopeVariables() {
        return this.scopeVariables;
    }
    /**
     * Configuration for windows registry monitoring.
     * 
     */
    @Export(name="windowsRegistryMonitoring", type=HostRuntimePolicyWindowsRegistryMonitoring.class, parameters={})
    private Output</* @Nullable */ HostRuntimePolicyWindowsRegistryMonitoring> windowsRegistryMonitoring;

    /**
     * @return Configuration for windows registry monitoring.
     * 
     */
    public Output<Optional<HostRuntimePolicyWindowsRegistryMonitoring>> windowsRegistryMonitoring() {
        return Codegen.optional(this.windowsRegistryMonitoring);
    }
    /**
     * Configuration for windows registry protection.
     * 
     */
    @Export(name="windowsRegistryProtection", type=HostRuntimePolicyWindowsRegistryProtection.class, parameters={})
    private Output</* @Nullable */ HostRuntimePolicyWindowsRegistryProtection> windowsRegistryProtection;

    /**
     * @return Configuration for windows registry protection.
     * 
     */
    public Output<Optional<HostRuntimePolicyWindowsRegistryProtection>> windowsRegistryProtection() {
        return Codegen.optional(this.windowsRegistryProtection);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public HostRuntimePolicy(String name) {
        this(name, HostRuntimePolicyArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public HostRuntimePolicy(String name, @Nullable HostRuntimePolicyArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public HostRuntimePolicy(String name, @Nullable HostRuntimePolicyArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("aquasec:index/hostRuntimePolicy:HostRuntimePolicy", name, args == null ? HostRuntimePolicyArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private HostRuntimePolicy(String name, Output<String> id, @Nullable HostRuntimePolicyState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("aquasec:index/hostRuntimePolicy:HostRuntimePolicy", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static HostRuntimePolicy get(String name, Output<String> id, @Nullable HostRuntimePolicyState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new HostRuntimePolicy(name, id, state, options);
    }
}
