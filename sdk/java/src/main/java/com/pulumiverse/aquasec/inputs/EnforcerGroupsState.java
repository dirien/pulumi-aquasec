// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumiverse.aquasec.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumiverse.aquasec.inputs.EnforcerGroupsCommandArgs;
import com.pulumiverse.aquasec.inputs.EnforcerGroupsOrchestratorArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class EnforcerGroupsState extends com.pulumi.resources.ResourceArgs {

    public static final EnforcerGroupsState Empty = new EnforcerGroupsState();

    /**
     * Selecting this option will allow the KubeEnforcer to block the deployment of container images that have failed any of these Container Runtime Policy controls:\
     * 			* Block Non-Compliant Images\
     * 			* Block Non-Compliant Workloads\
     * 			* Block Unregistered Images\
     * 			This functionality can work only when the KubeEnforcer is deployed in Enforce mode.
     * 
     */
    @Import(name="admissionControl")
    private @Nullable Output<Boolean> admissionControl;

    /**
     * @return Selecting this option will allow the KubeEnforcer to block the deployment of container images that have failed any of these Container Runtime Policy controls:\
     * 			* Block Non-Compliant Images\
     * 			* Block Non-Compliant Workloads\
     * 			* Block Unregistered Images\
     * 			This functionality can work only when the KubeEnforcer is deployed in Enforce mode.
     * 
     */
    public Optional<Output<Boolean>> admissionControl() {
        return Optional.ofNullable(this.admissionControl);
    }

    /**
     * Allow kube enforcer audit.
     * 
     */
    @Import(name="allowKubeEnforcerAudit")
    private @Nullable Output<Boolean> allowKubeEnforcerAudit;

    /**
     * @return Allow kube enforcer audit.
     * 
     */
    public Optional<Output<Boolean>> allowKubeEnforcerAudit() {
        return Optional.ofNullable(this.allowKubeEnforcerAudit);
    }

    /**
     * List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
     * 
     */
    @Import(name="allowedApplications")
    private @Nullable Output<List<String>> allowedApplications;

    /**
     * @return List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
     * 
     */
    public Optional<Output<List<String>>> allowedApplications() {
        return Optional.ofNullable(this.allowedApplications);
    }

    /**
     * List of label names to allow on the hosts.
     * 
     */
    @Import(name="allowedLabels")
    private @Nullable Output<List<String>> allowedLabels;

    /**
     * @return List of label names to allow on the hosts.
     * 
     */
    public Optional<Output<List<String>>> allowedLabels() {
        return Optional.ofNullable(this.allowedLabels);
    }

    /**
     * List of registry names to allow on the hosts.
     * 
     */
    @Import(name="allowedRegistries")
    private @Nullable Output<List<String>> allowedRegistries;

    /**
     * @return List of registry names to allow on the hosts.
     * 
     */
    public Optional<Output<List<String>>> allowedRegistries() {
        return Optional.ofNullable(this.allowedRegistries);
    }

    /**
     * This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Host Runtime policies.
     * 
     */
    @Import(name="antivirusProtection")
    private @Nullable Output<Boolean> antivirusProtection;

    /**
     * @return This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Host Runtime policies.
     * 
     */
    public Optional<Output<Boolean>> antivirusProtection() {
        return Optional.ofNullable(this.antivirusProtection);
    }

    /**
     * Aqua server version
     * 
     */
    @Import(name="aquaVersion")
    private @Nullable Output<String> aquaVersion;

    /**
     * @return Aqua server version
     * 
     */
    public Optional<Output<String>> aquaVersion() {
        return Optional.ofNullable(this.aquaVersion);
    }

    /**
     * Agent will send extra audit messages to the server for success operations from inside the container (runtime).
     * 
     */
    @Import(name="auditAll")
    private @Nullable Output<Boolean> auditAll;

    /**
     * @return Agent will send extra audit messages to the server for success operations from inside the container (runtime).
     * 
     */
    public Optional<Output<Boolean>> auditAll() {
        return Optional.ofNullable(this.auditAll);
    }

    /**
     * This option is applicable only if `Enable Pod Enforcer injection` is selected. Select this option if you want Aqua Enterprise to copy the secrets defined above to the Pod Enforcer namespace and container. Otherwise, you can choose to copy these secrets by other means.
     * 
     */
    @Import(name="autoCopySecrets")
    private @Nullable Output<Boolean> autoCopySecrets;

    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected. Select this option if you want Aqua Enterprise to copy the secrets defined above to the Pod Enforcer namespace and container. Otherwise, you can choose to copy these secrets by other means.
     * 
     */
    public Optional<Output<Boolean>> autoCopySecrets() {
        return Optional.ofNullable(this.autoCopySecrets);
    }

    /**
     * This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will add previously unknown image registries from the cluster to Aqua.
     * 
     */
    @Import(name="autoDiscoverConfigureRegistries")
    private @Nullable Output<Boolean> autoDiscoverConfigureRegistries;

    /**
     * @return This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will add previously unknown image registries from the cluster to Aqua.
     * 
     */
    public Optional<Output<Boolean>> autoDiscoverConfigureRegistries() {
        return Optional.ofNullable(this.autoDiscoverConfigureRegistries);
    }

    /**
     * When this option is selected, the KubeEnforcer will discover workloads on its cluster.
     * 
     */
    @Import(name="autoDiscoveryEnabled")
    private @Nullable Output<Boolean> autoDiscoveryEnabled;

    /**
     * @return When this option is selected, the KubeEnforcer will discover workloads on its cluster.
     * 
     */
    public Optional<Output<Boolean>> autoDiscoveryEnabled() {
        return Optional.ofNullable(this.autoDiscoveryEnabled);
    }

    /**
     * This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will automatically register images running as workloads (and scan the discovered images for security issues).
     * 
     */
    @Import(name="autoScanDiscoveredImagesRunningContainers")
    private @Nullable Output<Boolean> autoScanDiscoveredImagesRunningContainers;

    /**
     * @return This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will automatically register images running as workloads (and scan the discovered images for security issues).
     * 
     */
    public Optional<Output<Boolean>> autoScanDiscoveredImagesRunningContainers() {
        return Optional.ofNullable(this.autoScanDiscoveredImagesRunningContainers);
    }

    /**
     * Select Enabled to detect suspicious activity in your containers and display potential security threats in the Incidents and Audit pages.
     * 
     */
    @Import(name="behavioralEngine")
    private @Nullable Output<Boolean> behavioralEngine;

    /**
     * @return Select Enabled to detect suspicious activity in your containers and display potential security threats in the Incidents and Audit pages.
     * 
     */
    public Optional<Output<Boolean>> behavioralEngine() {
        return Optional.ofNullable(this.behavioralEngine);
    }

    /**
     * This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    @Import(name="blockAdmissionControl")
    private @Nullable Output<Boolean> blockAdmissionControl;

    /**
     * @return This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    public Optional<Output<Boolean>> blockAdmissionControl() {
        return Optional.ofNullable(this.blockAdmissionControl);
    }

    /**
     * The installation command.
     * 
     */
    @Import(name="commands")
    private @Nullable Output<List<EnforcerGroupsCommandArgs>> commands;

    /**
     * @return The installation command.
     * 
     */
    public Optional<Output<List<EnforcerGroupsCommandArgs>>> commands() {
        return Optional.ofNullable(this.commands);
    }

    /**
     * Number of connected enforcers in the enforcer group.
     * 
     */
    @Import(name="connectedCount")
    private @Nullable Output<Integer> connectedCount;

    /**
     * @return Number of connected enforcers in the enforcer group.
     * 
     */
    public Optional<Output<Integer>> connectedCount() {
        return Optional.ofNullable(this.connectedCount);
    }

    /**
     * Set `True` to apply Container Runtime Policies, Image Profiles, and Firewall Policies to containers.
     * 
     */
    @Import(name="containerActivityProtection")
    private @Nullable Output<Boolean> containerActivityProtection;

    /**
     * @return Set `True` to apply Container Runtime Policies, Image Profiles, and Firewall Policies to containers.
     * 
     */
    public Optional<Output<Boolean>> containerActivityProtection() {
        return Optional.ofNullable(this.containerActivityProtection);
    }

    /**
     * This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Container Runtime policies.
     * 
     */
    @Import(name="containerAntivirusProtection")
    private @Nullable Output<Boolean> containerAntivirusProtection;

    /**
     * @return This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Container Runtime policies.
     * 
     */
    public Optional<Output<Boolean>> containerAntivirusProtection() {
        return Optional.ofNullable(this.containerAntivirusProtection);
    }

    /**
     * A description of the Aqua Enforcer group.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return A description of the Aqua Enforcer group.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Number of disconnected enforcers in the enforcer group.
     * 
     */
    @Import(name="disconnectedCount")
    private @Nullable Output<Integer> disconnectedCount;

    /**
     * @return Number of disconnected enforcers in the enforcer group.
     * 
     */
    public Optional<Output<Integer>> disconnectedCount() {
        return Optional.ofNullable(this.disconnectedCount);
    }

    /**
     * Whether to enable enforce mode on the Enforcers, defaults to False.
     * 
     */
    @Import(name="enforce")
    private @Nullable Output<Boolean> enforce;

    /**
     * @return Whether to enable enforce mode on the Enforcers, defaults to False.
     * 
     */
    public Optional<Output<Boolean>> enforce() {
        return Optional.ofNullable(this.enforce);
    }

    /**
     * The specific Aqua Enforcer product image (with image tag) to be deployed.
     * 
     */
    @Import(name="enforcerImageName")
    private @Nullable Output<String> enforcerImageName;

    /**
     * @return The specific Aqua Enforcer product image (with image tag) to be deployed.
     * 
     */
    public Optional<Output<String>> enforcerImageName() {
        return Optional.ofNullable(this.enforcerImageName);
    }

    /**
     * Select Enabled to send activity logs in your containers to the Aqua Server for forensics purposes.
     * 
     */
    @Import(name="forensics")
    private @Nullable Output<Boolean> forensics;

    /**
     * @return Select Enabled to send activity logs in your containers to the Aqua Server for forensics purposes.
     * 
     */
    public Optional<Output<Boolean>> forensics() {
        return Optional.ofNullable(this.forensics);
    }

    /**
     * Gateway Address
     * 
     */
    @Import(name="gatewayAddress")
    private @Nullable Output<String> gatewayAddress;

    /**
     * @return Gateway Address
     * 
     */
    public Optional<Output<String>> gatewayAddress() {
        return Optional.ofNullable(this.gatewayAddress);
    }

    /**
     * Gateway Name
     * 
     */
    @Import(name="gatewayName")
    private @Nullable Output<String> gatewayName;

    /**
     * @return Gateway Name
     * 
     */
    public Optional<Output<String>> gatewayName() {
        return Optional.ofNullable(this.gatewayName);
    }

    /**
     * List of Aqua gateway IDs for the Enforcers.
     * 
     */
    @Import(name="gateways")
    private @Nullable Output<List<String>> gateways;

    /**
     * @return List of Aqua gateway IDs for the Enforcers.
     * 
     */
    public Optional<Output<List<String>>> gateways() {
        return Optional.ofNullable(this.gateways);
    }

    /**
     * The ID of the Enforcer group.
     * 
     */
    @Import(name="groupId")
    private @Nullable Output<String> groupId;

    /**
     * @return The ID of the Enforcer group.
     * 
     */
    public Optional<Output<String>> groupId() {
        return Optional.ofNullable(this.groupId);
    }

    /**
     * Number of high vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    @Import(name="highVulns")
    private @Nullable Output<Integer> highVulns;

    /**
     * @return Number of high vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Optional<Output<Integer>> highVulns() {
        return Optional.ofNullable(this.highVulns);
    }

    /**
     * Set `True` to enable host scanning and respective Host Assurance controls.
     * 
     */
    @Import(name="hostAssurance")
    private @Nullable Output<Boolean> hostAssurance;

    /**
     * @return Set `True` to enable host scanning and respective Host Assurance controls.
     * 
     */
    public Optional<Output<Boolean>> hostAssurance() {
        return Optional.ofNullable(this.hostAssurance);
    }

    /**
     * Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    @Import(name="hostBehavioralEngine")
    private @Nullable Output<Boolean> hostBehavioralEngine;

    /**
     * @return Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    public Optional<Output<Boolean>> hostBehavioralEngine() {
        return Optional.ofNullable(this.hostBehavioralEngine);
    }

    /**
     * Select Enabled to send activity logs in your host to the Aqua Server for forensics purposes.
     * 
     */
    @Import(name="hostForensics")
    private @Nullable Output<Boolean> hostForensics;

    /**
     * @return Select Enabled to send activity logs in your host to the Aqua Server for forensics purposes.
     * 
     */
    public Optional<Output<Boolean>> hostForensics() {
        return Optional.ofNullable(this.hostForensics);
    }

    /**
     * Set `True` to apply Firewall Policies to hosts, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information
     * 
     */
    @Import(name="hostNetworkProtection")
    private @Nullable Output<Boolean> hostNetworkProtection;

    /**
     * @return Set `True` to apply Firewall Policies to hosts, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information
     * 
     */
    public Optional<Output<Boolean>> hostNetworkProtection() {
        return Optional.ofNullable(this.hostNetworkProtection);
    }

    /**
     * The OS type for the host
     * 
     */
    @Import(name="hostOs")
    private @Nullable Output<String> hostOs;

    /**
     * @return The OS type for the host
     * 
     */
    public Optional<Output<String>> hostOs() {
        return Optional.ofNullable(this.hostOs);
    }

    /**
     * Set `True` to enable all Host Runtime Policy controls except for `OS Users and Groups Allowed` and `OS Users and Groups Blocked`.
     * 
     */
    @Import(name="hostProtection")
    private @Nullable Output<Boolean> hostProtection;

    /**
     * @return Set `True` to enable all Host Runtime Policy controls except for `OS Users and Groups Allowed` and `OS Users and Groups Blocked`.
     * 
     */
    public Optional<Output<Boolean>> hostProtection() {
        return Optional.ofNullable(this.hostProtection);
    }

    /**
     * Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    @Import(name="hostUserProtection")
    private @Nullable Output<Boolean> hostUserProtection;

    /**
     * @return Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    public Optional<Output<Boolean>> hostUserProtection() {
        return Optional.ofNullable(this.hostUserProtection);
    }

    /**
     * The hostname
     * 
     */
    @Import(name="hostname")
    private @Nullable Output<String> hostname;

    /**
     * @return The hostname
     * 
     */
    public Optional<Output<String>> hostname() {
        return Optional.ofNullable(this.hostname);
    }

    /**
     * Number of enforcers in the enforcer group.
     * 
     */
    @Import(name="hostsCount")
    private @Nullable Output<Integer> hostsCount;

    /**
     * @return Number of enforcers in the enforcer group.
     * 
     */
    public Optional<Output<Integer>> hostsCount() {
        return Optional.ofNullable(this.hostsCount);
    }

    /**
     * Set `True` to enable selected controls: Container Runtime Policy (`Block Non-Compliant Images`, `Block Unregistered Images`, and `Registries Allowed`) and Default Image Assurance Policy (`Images Blocked`).
     * 
     */
    @Import(name="imageAssurance")
    private @Nullable Output<Boolean> imageAssurance;

    /**
     * @return Set `True` to enable selected controls: Container Runtime Policy (`Block Non-Compliant Images`, `Block Unregistered Images`, and `Registries Allowed`) and Default Image Assurance Policy (`Images Blocked`).
     * 
     */
    public Optional<Output<Boolean>> imageAssurance() {
        return Optional.ofNullable(this.imageAssurance);
    }

    /**
     * Enforcer install command
     * 
     */
    @Import(name="installCommand")
    private @Nullable Output<String> installCommand;

    /**
     * @return Enforcer install command
     * 
     */
    public Optional<Output<String>> installCommand() {
        return Optional.ofNullable(this.installCommand);
    }

    /**
     * See https://docs.aquasec.com/docs/securing-kubernetes-applications#section-configuration-hardening, The KubeEnforcer can deploy the Aqua Security kube-bench open-source product to perform Kubernetes CIS benchmark testing of nodes.
     * 			This field specifies the path and file name of the kube-bench product image for the KubeEnforcer to deploy; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    @Import(name="kubeBenchImageName")
    private @Nullable Output<String> kubeBenchImageName;

    /**
     * @return See https://docs.aquasec.com/docs/securing-kubernetes-applications#section-configuration-hardening, The KubeEnforcer can deploy the Aqua Security kube-bench open-source product to perform Kubernetes CIS benchmark testing of nodes.
     * 			This field specifies the path and file name of the kube-bench product image for the KubeEnforcer to deploy; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    public Optional<Output<String>> kubeBenchImageName() {
        return Optional.ofNullable(this.kubeBenchImageName);
    }

    /**
     * The last date and time the batch token was updated in UNIX time.
     * 
     */
    @Import(name="lastUpdate")
    private @Nullable Output<Integer> lastUpdate;

    /**
     * @return The last date and time the batch token was updated in UNIX time.
     * 
     */
    public Optional<Output<Integer>> lastUpdate() {
        return Optional.ofNullable(this.lastUpdate);
    }

    /**
     * Name for the batch install record.
     * 
     */
    @Import(name="logicalName")
    private @Nullable Output<String> logicalName;

    /**
     * @return Name for the batch install record.
     * 
     */
    public Optional<Output<String>> logicalName() {
        return Optional.ofNullable(this.logicalName);
    }

    /**
     * Number of low vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    @Import(name="lowVulns")
    private @Nullable Output<Integer> lowVulns;

    /**
     * @return Number of low vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Optional<Output<Integer>> lowVulns() {
        return Optional.ofNullable(this.lowVulns);
    }

    /**
     * Number of medium vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    @Import(name="medVulns")
    private @Nullable Output<Integer> medVulns;

    /**
     * @return Number of medium vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Optional<Output<Integer>> medVulns() {
        return Optional.ofNullable(this.medVulns);
    }

    /**
     * This option is applicable only if `Enable Pod Enforcer injection` is selected.
     * 
     */
    @Import(name="microEnforcerCertsSecretsName")
    private @Nullable Output<String> microEnforcerCertsSecretsName;

    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected.
     * 
     */
    public Optional<Output<String>> microEnforcerCertsSecretsName() {
        return Optional.ofNullable(this.microEnforcerCertsSecretsName);
    }

    /**
     * This option is applicable only if `Enable Pod Enforcer injection` is selected. This field specifies the path and file name of the KubeEnforcer product image to be deployed; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    @Import(name="microEnforcerImageName")
    private @Nullable Output<String> microEnforcerImageName;

    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected. This field specifies the path and file name of the KubeEnforcer product image to be deployed; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    public Optional<Output<String>> microEnforcerImageName() {
        return Optional.ofNullable(this.microEnforcerImageName);
    }

    /**
     * This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    @Import(name="microEnforcerInjection")
    private @Nullable Output<Boolean> microEnforcerInjection;

    /**
     * @return This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    public Optional<Output<Boolean>> microEnforcerInjection() {
        return Optional.ofNullable(this.microEnforcerInjection);
    }

    /**
     * You can specify the name of the secret (in the Aqua namespace) that Aqua copies into the Pod Enforcer namespace and kube-bench, allowing them access to the Pod Enforcer and kube-bench product images, respectively.
     * 
     */
    @Import(name="microEnforcerSecretsName")
    private @Nullable Output<String> microEnforcerSecretsName;

    /**
     * @return You can specify the name of the secret (in the Aqua namespace) that Aqua copies into the Pod Enforcer namespace and kube-bench, allowing them access to the Pod Enforcer and kube-bench product images, respectively.
     * 
     */
    public Optional<Output<String>> microEnforcerSecretsName() {
        return Optional.ofNullable(this.microEnforcerSecretsName);
    }

    /**
     * Number of negligible vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    @Import(name="negVulns")
    private @Nullable Output<Integer> negVulns;

    /**
     * @return Number of negligible vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Optional<Output<Integer>> negVulns() {
        return Optional.ofNullable(this.negVulns);
    }

    /**
     * Send true to apply Firewall Policies to containers, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information.
     * 
     */
    @Import(name="networkProtection")
    private @Nullable Output<Boolean> networkProtection;

    /**
     * @return Send true to apply Firewall Policies to containers, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information.
     * 
     */
    public Optional<Output<Boolean>> networkProtection() {
        return Optional.ofNullable(this.networkProtection);
    }

    /**
     * The orchestrator for which you are creating the Enforcer group.
     * 
     */
    @Import(name="orchestrators")
    private @Nullable Output<List<EnforcerGroupsOrchestratorArgs>> orchestrators;

    /**
     * @return The orchestrator for which you are creating the Enforcer group.
     * 
     */
    public Optional<Output<List<EnforcerGroupsOrchestratorArgs>>> orchestrators() {
        return Optional.ofNullable(this.orchestrators);
    }

    /**
     * pas deployment link
     * 
     */
    @Import(name="pasDeploymentLink")
    private @Nullable Output<String> pasDeploymentLink;

    /**
     * @return pas deployment link
     * 
     */
    public Optional<Output<String>> pasDeploymentLink() {
        return Optional.ofNullable(this.pasDeploymentLink);
    }

    /**
     * Permission Action
     * 
     */
    @Import(name="permission")
    private @Nullable Output<String> permission;

    /**
     * @return Permission Action
     * 
     */
    public Optional<Output<String>> permission() {
        return Optional.ofNullable(this.permission);
    }

    /**
     * Set `True` to allow Enforcers to be discovered in the Risk Explorer.
     * 
     */
    @Import(name="riskExplorerAutoDiscovery")
    private @Nullable Output<Boolean> riskExplorerAutoDiscovery;

    /**
     * @return Set `True` to allow Enforcers to be discovered in the Risk Explorer.
     * 
     */
    public Optional<Output<Boolean>> riskExplorerAutoDiscovery() {
        return Optional.ofNullable(this.riskExplorerAutoDiscovery);
    }

    /**
     * Function Runtime Policy that will applay on the nano enforcer.
     * 
     */
    @Import(name="runtimePolicyName")
    private @Nullable Output<String> runtimePolicyName;

    /**
     * @return Function Runtime Policy that will applay on the nano enforcer.
     * 
     */
    public Optional<Output<String>> runtimePolicyName() {
        return Optional.ofNullable(this.runtimePolicyName);
    }

    /**
     * The container runtime environment.
     * 
     */
    @Import(name="runtimeType")
    private @Nullable Output<String> runtimeType;

    /**
     * @return The container runtime environment.
     * 
     */
    public Optional<Output<String>> runtimeType() {
        return Optional.ofNullable(this.runtimeType);
    }

    /**
     * Set `True` to configure Enforcers to discover local host images. Discovered images will be listed under Images &gt; Host Images, as well as under Infrastructure (in the Images tab for applicable hosts).
     * 
     */
    @Import(name="syncHostImages")
    private @Nullable Output<Boolean> syncHostImages;

    /**
     * @return Set `True` to configure Enforcers to discover local host images. Discovered images will be listed under Images &gt; Host Images, as well as under Infrastructure (in the Images tab for applicable hosts).
     * 
     */
    public Optional<Output<Boolean>> syncHostImages() {
        return Optional.ofNullable(this.syncHostImages);
    }

    /**
     * Set `True` will allow profiling and monitoring system calls made by running containers.
     * 
     */
    @Import(name="syscallEnabled")
    private @Nullable Output<Boolean> syscallEnabled;

    /**
     * @return Set `True` will allow profiling and monitoring system calls made by running containers.
     * 
     */
    public Optional<Output<Boolean>> syscallEnabled() {
        return Optional.ofNullable(this.syscallEnabled);
    }

    /**
     * The batch install token.
     * 
     */
    @Import(name="token")
    private @Nullable Output<String> token;

    /**
     * @return The batch install token.
     * 
     */
    public Optional<Output<String>> token() {
        return Optional.ofNullable(this.token);
    }

    /**
     * Enforcer Type.
     * 
     */
    @Import(name="type")
    private @Nullable Output<String> type;

    /**
     * @return Enforcer Type.
     * 
     */
    public Optional<Output<String>> type() {
        return Optional.ofNullable(this.type);
    }

    /**
     * Set `True` to apply User Access Control Policies to containers. Note that Aqua Enforcers must be deployed with the AQUA*RUNC*INTERCEPTION environment variable set to 0 in order to use User Access Control Policies.
     * 
     */
    @Import(name="userAccessControl")
    private @Nullable Output<Boolean> userAccessControl;

    /**
     * @return Set `True` to apply User Access Control Policies to containers. Note that Aqua Enforcers must be deployed with the AQUA*RUNC*INTERCEPTION environment variable set to 0 in order to use User Access Control Policies.
     * 
     */
    public Optional<Output<Boolean>> userAccessControl() {
        return Optional.ofNullable(this.userAccessControl);
    }

    private EnforcerGroupsState() {}

    private EnforcerGroupsState(EnforcerGroupsState $) {
        this.admissionControl = $.admissionControl;
        this.allowKubeEnforcerAudit = $.allowKubeEnforcerAudit;
        this.allowedApplications = $.allowedApplications;
        this.allowedLabels = $.allowedLabels;
        this.allowedRegistries = $.allowedRegistries;
        this.antivirusProtection = $.antivirusProtection;
        this.aquaVersion = $.aquaVersion;
        this.auditAll = $.auditAll;
        this.autoCopySecrets = $.autoCopySecrets;
        this.autoDiscoverConfigureRegistries = $.autoDiscoverConfigureRegistries;
        this.autoDiscoveryEnabled = $.autoDiscoveryEnabled;
        this.autoScanDiscoveredImagesRunningContainers = $.autoScanDiscoveredImagesRunningContainers;
        this.behavioralEngine = $.behavioralEngine;
        this.blockAdmissionControl = $.blockAdmissionControl;
        this.commands = $.commands;
        this.connectedCount = $.connectedCount;
        this.containerActivityProtection = $.containerActivityProtection;
        this.containerAntivirusProtection = $.containerAntivirusProtection;
        this.description = $.description;
        this.disconnectedCount = $.disconnectedCount;
        this.enforce = $.enforce;
        this.enforcerImageName = $.enforcerImageName;
        this.forensics = $.forensics;
        this.gatewayAddress = $.gatewayAddress;
        this.gatewayName = $.gatewayName;
        this.gateways = $.gateways;
        this.groupId = $.groupId;
        this.highVulns = $.highVulns;
        this.hostAssurance = $.hostAssurance;
        this.hostBehavioralEngine = $.hostBehavioralEngine;
        this.hostForensics = $.hostForensics;
        this.hostNetworkProtection = $.hostNetworkProtection;
        this.hostOs = $.hostOs;
        this.hostProtection = $.hostProtection;
        this.hostUserProtection = $.hostUserProtection;
        this.hostname = $.hostname;
        this.hostsCount = $.hostsCount;
        this.imageAssurance = $.imageAssurance;
        this.installCommand = $.installCommand;
        this.kubeBenchImageName = $.kubeBenchImageName;
        this.lastUpdate = $.lastUpdate;
        this.logicalName = $.logicalName;
        this.lowVulns = $.lowVulns;
        this.medVulns = $.medVulns;
        this.microEnforcerCertsSecretsName = $.microEnforcerCertsSecretsName;
        this.microEnforcerImageName = $.microEnforcerImageName;
        this.microEnforcerInjection = $.microEnforcerInjection;
        this.microEnforcerSecretsName = $.microEnforcerSecretsName;
        this.negVulns = $.negVulns;
        this.networkProtection = $.networkProtection;
        this.orchestrators = $.orchestrators;
        this.pasDeploymentLink = $.pasDeploymentLink;
        this.permission = $.permission;
        this.riskExplorerAutoDiscovery = $.riskExplorerAutoDiscovery;
        this.runtimePolicyName = $.runtimePolicyName;
        this.runtimeType = $.runtimeType;
        this.syncHostImages = $.syncHostImages;
        this.syscallEnabled = $.syscallEnabled;
        this.token = $.token;
        this.type = $.type;
        this.userAccessControl = $.userAccessControl;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(EnforcerGroupsState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private EnforcerGroupsState $;

        public Builder() {
            $ = new EnforcerGroupsState();
        }

        public Builder(EnforcerGroupsState defaults) {
            $ = new EnforcerGroupsState(Objects.requireNonNull(defaults));
        }

        /**
         * @param admissionControl Selecting this option will allow the KubeEnforcer to block the deployment of container images that have failed any of these Container Runtime Policy controls:\
         * 			* Block Non-Compliant Images\
         * 			* Block Non-Compliant Workloads\
         * 			* Block Unregistered Images\
         * 			This functionality can work only when the KubeEnforcer is deployed in Enforce mode.
         * 
         * @return builder
         * 
         */
        public Builder admissionControl(@Nullable Output<Boolean> admissionControl) {
            $.admissionControl = admissionControl;
            return this;
        }

        /**
         * @param admissionControl Selecting this option will allow the KubeEnforcer to block the deployment of container images that have failed any of these Container Runtime Policy controls:\
         * 			* Block Non-Compliant Images\
         * 			* Block Non-Compliant Workloads\
         * 			* Block Unregistered Images\
         * 			This functionality can work only when the KubeEnforcer is deployed in Enforce mode.
         * 
         * @return builder
         * 
         */
        public Builder admissionControl(Boolean admissionControl) {
            return admissionControl(Output.of(admissionControl));
        }

        /**
         * @param allowKubeEnforcerAudit Allow kube enforcer audit.
         * 
         * @return builder
         * 
         */
        public Builder allowKubeEnforcerAudit(@Nullable Output<Boolean> allowKubeEnforcerAudit) {
            $.allowKubeEnforcerAudit = allowKubeEnforcerAudit;
            return this;
        }

        /**
         * @param allowKubeEnforcerAudit Allow kube enforcer audit.
         * 
         * @return builder
         * 
         */
        public Builder allowKubeEnforcerAudit(Boolean allowKubeEnforcerAudit) {
            return allowKubeEnforcerAudit(Output.of(allowKubeEnforcerAudit));
        }

        /**
         * @param allowedApplications List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
         * 
         * @return builder
         * 
         */
        public Builder allowedApplications(@Nullable Output<List<String>> allowedApplications) {
            $.allowedApplications = allowedApplications;
            return this;
        }

        /**
         * @param allowedApplications List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
         * 
         * @return builder
         * 
         */
        public Builder allowedApplications(List<String> allowedApplications) {
            return allowedApplications(Output.of(allowedApplications));
        }

        /**
         * @param allowedApplications List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
         * 
         * @return builder
         * 
         */
        public Builder allowedApplications(String... allowedApplications) {
            return allowedApplications(List.of(allowedApplications));
        }

        /**
         * @param allowedLabels List of label names to allow on the hosts.
         * 
         * @return builder
         * 
         */
        public Builder allowedLabels(@Nullable Output<List<String>> allowedLabels) {
            $.allowedLabels = allowedLabels;
            return this;
        }

        /**
         * @param allowedLabels List of label names to allow on the hosts.
         * 
         * @return builder
         * 
         */
        public Builder allowedLabels(List<String> allowedLabels) {
            return allowedLabels(Output.of(allowedLabels));
        }

        /**
         * @param allowedLabels List of label names to allow on the hosts.
         * 
         * @return builder
         * 
         */
        public Builder allowedLabels(String... allowedLabels) {
            return allowedLabels(List.of(allowedLabels));
        }

        /**
         * @param allowedRegistries List of registry names to allow on the hosts.
         * 
         * @return builder
         * 
         */
        public Builder allowedRegistries(@Nullable Output<List<String>> allowedRegistries) {
            $.allowedRegistries = allowedRegistries;
            return this;
        }

        /**
         * @param allowedRegistries List of registry names to allow on the hosts.
         * 
         * @return builder
         * 
         */
        public Builder allowedRegistries(List<String> allowedRegistries) {
            return allowedRegistries(Output.of(allowedRegistries));
        }

        /**
         * @param allowedRegistries List of registry names to allow on the hosts.
         * 
         * @return builder
         * 
         */
        public Builder allowedRegistries(String... allowedRegistries) {
            return allowedRegistries(List.of(allowedRegistries));
        }

        /**
         * @param antivirusProtection This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Host Runtime policies.
         * 
         * @return builder
         * 
         */
        public Builder antivirusProtection(@Nullable Output<Boolean> antivirusProtection) {
            $.antivirusProtection = antivirusProtection;
            return this;
        }

        /**
         * @param antivirusProtection This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Host Runtime policies.
         * 
         * @return builder
         * 
         */
        public Builder antivirusProtection(Boolean antivirusProtection) {
            return antivirusProtection(Output.of(antivirusProtection));
        }

        /**
         * @param aquaVersion Aqua server version
         * 
         * @return builder
         * 
         */
        public Builder aquaVersion(@Nullable Output<String> aquaVersion) {
            $.aquaVersion = aquaVersion;
            return this;
        }

        /**
         * @param aquaVersion Aqua server version
         * 
         * @return builder
         * 
         */
        public Builder aquaVersion(String aquaVersion) {
            return aquaVersion(Output.of(aquaVersion));
        }

        /**
         * @param auditAll Agent will send extra audit messages to the server for success operations from inside the container (runtime).
         * 
         * @return builder
         * 
         */
        public Builder auditAll(@Nullable Output<Boolean> auditAll) {
            $.auditAll = auditAll;
            return this;
        }

        /**
         * @param auditAll Agent will send extra audit messages to the server for success operations from inside the container (runtime).
         * 
         * @return builder
         * 
         */
        public Builder auditAll(Boolean auditAll) {
            return auditAll(Output.of(auditAll));
        }

        /**
         * @param autoCopySecrets This option is applicable only if `Enable Pod Enforcer injection` is selected. Select this option if you want Aqua Enterprise to copy the secrets defined above to the Pod Enforcer namespace and container. Otherwise, you can choose to copy these secrets by other means.
         * 
         * @return builder
         * 
         */
        public Builder autoCopySecrets(@Nullable Output<Boolean> autoCopySecrets) {
            $.autoCopySecrets = autoCopySecrets;
            return this;
        }

        /**
         * @param autoCopySecrets This option is applicable only if `Enable Pod Enforcer injection` is selected. Select this option if you want Aqua Enterprise to copy the secrets defined above to the Pod Enforcer namespace and container. Otherwise, you can choose to copy these secrets by other means.
         * 
         * @return builder
         * 
         */
        public Builder autoCopySecrets(Boolean autoCopySecrets) {
            return autoCopySecrets(Output.of(autoCopySecrets));
        }

        /**
         * @param autoDiscoverConfigureRegistries This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will add previously unknown image registries from the cluster to Aqua.
         * 
         * @return builder
         * 
         */
        public Builder autoDiscoverConfigureRegistries(@Nullable Output<Boolean> autoDiscoverConfigureRegistries) {
            $.autoDiscoverConfigureRegistries = autoDiscoverConfigureRegistries;
            return this;
        }

        /**
         * @param autoDiscoverConfigureRegistries This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will add previously unknown image registries from the cluster to Aqua.
         * 
         * @return builder
         * 
         */
        public Builder autoDiscoverConfigureRegistries(Boolean autoDiscoverConfigureRegistries) {
            return autoDiscoverConfigureRegistries(Output.of(autoDiscoverConfigureRegistries));
        }

        /**
         * @param autoDiscoveryEnabled When this option is selected, the KubeEnforcer will discover workloads on its cluster.
         * 
         * @return builder
         * 
         */
        public Builder autoDiscoveryEnabled(@Nullable Output<Boolean> autoDiscoveryEnabled) {
            $.autoDiscoveryEnabled = autoDiscoveryEnabled;
            return this;
        }

        /**
         * @param autoDiscoveryEnabled When this option is selected, the KubeEnforcer will discover workloads on its cluster.
         * 
         * @return builder
         * 
         */
        public Builder autoDiscoveryEnabled(Boolean autoDiscoveryEnabled) {
            return autoDiscoveryEnabled(Output.of(autoDiscoveryEnabled));
        }

        /**
         * @param autoScanDiscoveredImagesRunningContainers This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will automatically register images running as workloads (and scan the discovered images for security issues).
         * 
         * @return builder
         * 
         */
        public Builder autoScanDiscoveredImagesRunningContainers(@Nullable Output<Boolean> autoScanDiscoveredImagesRunningContainers) {
            $.autoScanDiscoveredImagesRunningContainers = autoScanDiscoveredImagesRunningContainers;
            return this;
        }

        /**
         * @param autoScanDiscoveredImagesRunningContainers This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will automatically register images running as workloads (and scan the discovered images for security issues).
         * 
         * @return builder
         * 
         */
        public Builder autoScanDiscoveredImagesRunningContainers(Boolean autoScanDiscoveredImagesRunningContainers) {
            return autoScanDiscoveredImagesRunningContainers(Output.of(autoScanDiscoveredImagesRunningContainers));
        }

        /**
         * @param behavioralEngine Select Enabled to detect suspicious activity in your containers and display potential security threats in the Incidents and Audit pages.
         * 
         * @return builder
         * 
         */
        public Builder behavioralEngine(@Nullable Output<Boolean> behavioralEngine) {
            $.behavioralEngine = behavioralEngine;
            return this;
        }

        /**
         * @param behavioralEngine Select Enabled to detect suspicious activity in your containers and display potential security threats in the Incidents and Audit pages.
         * 
         * @return builder
         * 
         */
        public Builder behavioralEngine(Boolean behavioralEngine) {
            return behavioralEngine(Output.of(behavioralEngine));
        }

        /**
         * @param blockAdmissionControl This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
         * 
         * @return builder
         * 
         */
        public Builder blockAdmissionControl(@Nullable Output<Boolean> blockAdmissionControl) {
            $.blockAdmissionControl = blockAdmissionControl;
            return this;
        }

        /**
         * @param blockAdmissionControl This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
         * 
         * @return builder
         * 
         */
        public Builder blockAdmissionControl(Boolean blockAdmissionControl) {
            return blockAdmissionControl(Output.of(blockAdmissionControl));
        }

        /**
         * @param commands The installation command.
         * 
         * @return builder
         * 
         */
        public Builder commands(@Nullable Output<List<EnforcerGroupsCommandArgs>> commands) {
            $.commands = commands;
            return this;
        }

        /**
         * @param commands The installation command.
         * 
         * @return builder
         * 
         */
        public Builder commands(List<EnforcerGroupsCommandArgs> commands) {
            return commands(Output.of(commands));
        }

        /**
         * @param commands The installation command.
         * 
         * @return builder
         * 
         */
        public Builder commands(EnforcerGroupsCommandArgs... commands) {
            return commands(List.of(commands));
        }

        /**
         * @param connectedCount Number of connected enforcers in the enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder connectedCount(@Nullable Output<Integer> connectedCount) {
            $.connectedCount = connectedCount;
            return this;
        }

        /**
         * @param connectedCount Number of connected enforcers in the enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder connectedCount(Integer connectedCount) {
            return connectedCount(Output.of(connectedCount));
        }

        /**
         * @param containerActivityProtection Set `True` to apply Container Runtime Policies, Image Profiles, and Firewall Policies to containers.
         * 
         * @return builder
         * 
         */
        public Builder containerActivityProtection(@Nullable Output<Boolean> containerActivityProtection) {
            $.containerActivityProtection = containerActivityProtection;
            return this;
        }

        /**
         * @param containerActivityProtection Set `True` to apply Container Runtime Policies, Image Profiles, and Firewall Policies to containers.
         * 
         * @return builder
         * 
         */
        public Builder containerActivityProtection(Boolean containerActivityProtection) {
            return containerActivityProtection(Output.of(containerActivityProtection));
        }

        /**
         * @param containerAntivirusProtection This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Container Runtime policies.
         * 
         * @return builder
         * 
         */
        public Builder containerAntivirusProtection(@Nullable Output<Boolean> containerAntivirusProtection) {
            $.containerAntivirusProtection = containerAntivirusProtection;
            return this;
        }

        /**
         * @param containerAntivirusProtection This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Container Runtime policies.
         * 
         * @return builder
         * 
         */
        public Builder containerAntivirusProtection(Boolean containerAntivirusProtection) {
            return containerAntivirusProtection(Output.of(containerAntivirusProtection));
        }

        /**
         * @param description A description of the Aqua Enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description A description of the Aqua Enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param disconnectedCount Number of disconnected enforcers in the enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder disconnectedCount(@Nullable Output<Integer> disconnectedCount) {
            $.disconnectedCount = disconnectedCount;
            return this;
        }

        /**
         * @param disconnectedCount Number of disconnected enforcers in the enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder disconnectedCount(Integer disconnectedCount) {
            return disconnectedCount(Output.of(disconnectedCount));
        }

        /**
         * @param enforce Whether to enable enforce mode on the Enforcers, defaults to False.
         * 
         * @return builder
         * 
         */
        public Builder enforce(@Nullable Output<Boolean> enforce) {
            $.enforce = enforce;
            return this;
        }

        /**
         * @param enforce Whether to enable enforce mode on the Enforcers, defaults to False.
         * 
         * @return builder
         * 
         */
        public Builder enforce(Boolean enforce) {
            return enforce(Output.of(enforce));
        }

        /**
         * @param enforcerImageName The specific Aqua Enforcer product image (with image tag) to be deployed.
         * 
         * @return builder
         * 
         */
        public Builder enforcerImageName(@Nullable Output<String> enforcerImageName) {
            $.enforcerImageName = enforcerImageName;
            return this;
        }

        /**
         * @param enforcerImageName The specific Aqua Enforcer product image (with image tag) to be deployed.
         * 
         * @return builder
         * 
         */
        public Builder enforcerImageName(String enforcerImageName) {
            return enforcerImageName(Output.of(enforcerImageName));
        }

        /**
         * @param forensics Select Enabled to send activity logs in your containers to the Aqua Server for forensics purposes.
         * 
         * @return builder
         * 
         */
        public Builder forensics(@Nullable Output<Boolean> forensics) {
            $.forensics = forensics;
            return this;
        }

        /**
         * @param forensics Select Enabled to send activity logs in your containers to the Aqua Server for forensics purposes.
         * 
         * @return builder
         * 
         */
        public Builder forensics(Boolean forensics) {
            return forensics(Output.of(forensics));
        }

        /**
         * @param gatewayAddress Gateway Address
         * 
         * @return builder
         * 
         */
        public Builder gatewayAddress(@Nullable Output<String> gatewayAddress) {
            $.gatewayAddress = gatewayAddress;
            return this;
        }

        /**
         * @param gatewayAddress Gateway Address
         * 
         * @return builder
         * 
         */
        public Builder gatewayAddress(String gatewayAddress) {
            return gatewayAddress(Output.of(gatewayAddress));
        }

        /**
         * @param gatewayName Gateway Name
         * 
         * @return builder
         * 
         */
        public Builder gatewayName(@Nullable Output<String> gatewayName) {
            $.gatewayName = gatewayName;
            return this;
        }

        /**
         * @param gatewayName Gateway Name
         * 
         * @return builder
         * 
         */
        public Builder gatewayName(String gatewayName) {
            return gatewayName(Output.of(gatewayName));
        }

        /**
         * @param gateways List of Aqua gateway IDs for the Enforcers.
         * 
         * @return builder
         * 
         */
        public Builder gateways(@Nullable Output<List<String>> gateways) {
            $.gateways = gateways;
            return this;
        }

        /**
         * @param gateways List of Aqua gateway IDs for the Enforcers.
         * 
         * @return builder
         * 
         */
        public Builder gateways(List<String> gateways) {
            return gateways(Output.of(gateways));
        }

        /**
         * @param gateways List of Aqua gateway IDs for the Enforcers.
         * 
         * @return builder
         * 
         */
        public Builder gateways(String... gateways) {
            return gateways(List.of(gateways));
        }

        /**
         * @param groupId The ID of the Enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder groupId(@Nullable Output<String> groupId) {
            $.groupId = groupId;
            return this;
        }

        /**
         * @param groupId The ID of the Enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder groupId(String groupId) {
            return groupId(Output.of(groupId));
        }

        /**
         * @param highVulns Number of high vulnerabilities in the enforcers that in this enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder highVulns(@Nullable Output<Integer> highVulns) {
            $.highVulns = highVulns;
            return this;
        }

        /**
         * @param highVulns Number of high vulnerabilities in the enforcers that in this enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder highVulns(Integer highVulns) {
            return highVulns(Output.of(highVulns));
        }

        /**
         * @param hostAssurance Set `True` to enable host scanning and respective Host Assurance controls.
         * 
         * @return builder
         * 
         */
        public Builder hostAssurance(@Nullable Output<Boolean> hostAssurance) {
            $.hostAssurance = hostAssurance;
            return this;
        }

        /**
         * @param hostAssurance Set `True` to enable host scanning and respective Host Assurance controls.
         * 
         * @return builder
         * 
         */
        public Builder hostAssurance(Boolean hostAssurance) {
            return hostAssurance(Output.of(hostAssurance));
        }

        /**
         * @param hostBehavioralEngine Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
         * 
         * @return builder
         * 
         */
        public Builder hostBehavioralEngine(@Nullable Output<Boolean> hostBehavioralEngine) {
            $.hostBehavioralEngine = hostBehavioralEngine;
            return this;
        }

        /**
         * @param hostBehavioralEngine Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
         * 
         * @return builder
         * 
         */
        public Builder hostBehavioralEngine(Boolean hostBehavioralEngine) {
            return hostBehavioralEngine(Output.of(hostBehavioralEngine));
        }

        /**
         * @param hostForensics Select Enabled to send activity logs in your host to the Aqua Server for forensics purposes.
         * 
         * @return builder
         * 
         */
        public Builder hostForensics(@Nullable Output<Boolean> hostForensics) {
            $.hostForensics = hostForensics;
            return this;
        }

        /**
         * @param hostForensics Select Enabled to send activity logs in your host to the Aqua Server for forensics purposes.
         * 
         * @return builder
         * 
         */
        public Builder hostForensics(Boolean hostForensics) {
            return hostForensics(Output.of(hostForensics));
        }

        /**
         * @param hostNetworkProtection Set `True` to apply Firewall Policies to hosts, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information
         * 
         * @return builder
         * 
         */
        public Builder hostNetworkProtection(@Nullable Output<Boolean> hostNetworkProtection) {
            $.hostNetworkProtection = hostNetworkProtection;
            return this;
        }

        /**
         * @param hostNetworkProtection Set `True` to apply Firewall Policies to hosts, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information
         * 
         * @return builder
         * 
         */
        public Builder hostNetworkProtection(Boolean hostNetworkProtection) {
            return hostNetworkProtection(Output.of(hostNetworkProtection));
        }

        /**
         * @param hostOs The OS type for the host
         * 
         * @return builder
         * 
         */
        public Builder hostOs(@Nullable Output<String> hostOs) {
            $.hostOs = hostOs;
            return this;
        }

        /**
         * @param hostOs The OS type for the host
         * 
         * @return builder
         * 
         */
        public Builder hostOs(String hostOs) {
            return hostOs(Output.of(hostOs));
        }

        /**
         * @param hostProtection Set `True` to enable all Host Runtime Policy controls except for `OS Users and Groups Allowed` and `OS Users and Groups Blocked`.
         * 
         * @return builder
         * 
         */
        public Builder hostProtection(@Nullable Output<Boolean> hostProtection) {
            $.hostProtection = hostProtection;
            return this;
        }

        /**
         * @param hostProtection Set `True` to enable all Host Runtime Policy controls except for `OS Users and Groups Allowed` and `OS Users and Groups Blocked`.
         * 
         * @return builder
         * 
         */
        public Builder hostProtection(Boolean hostProtection) {
            return hostProtection(Output.of(hostProtection));
        }

        /**
         * @param hostUserProtection Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
         * 
         * @return builder
         * 
         */
        public Builder hostUserProtection(@Nullable Output<Boolean> hostUserProtection) {
            $.hostUserProtection = hostUserProtection;
            return this;
        }

        /**
         * @param hostUserProtection Set `True` to enable these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
         * 
         * @return builder
         * 
         */
        public Builder hostUserProtection(Boolean hostUserProtection) {
            return hostUserProtection(Output.of(hostUserProtection));
        }

        /**
         * @param hostname The hostname
         * 
         * @return builder
         * 
         */
        public Builder hostname(@Nullable Output<String> hostname) {
            $.hostname = hostname;
            return this;
        }

        /**
         * @param hostname The hostname
         * 
         * @return builder
         * 
         */
        public Builder hostname(String hostname) {
            return hostname(Output.of(hostname));
        }

        /**
         * @param hostsCount Number of enforcers in the enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder hostsCount(@Nullable Output<Integer> hostsCount) {
            $.hostsCount = hostsCount;
            return this;
        }

        /**
         * @param hostsCount Number of enforcers in the enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder hostsCount(Integer hostsCount) {
            return hostsCount(Output.of(hostsCount));
        }

        /**
         * @param imageAssurance Set `True` to enable selected controls: Container Runtime Policy (`Block Non-Compliant Images`, `Block Unregistered Images`, and `Registries Allowed`) and Default Image Assurance Policy (`Images Blocked`).
         * 
         * @return builder
         * 
         */
        public Builder imageAssurance(@Nullable Output<Boolean> imageAssurance) {
            $.imageAssurance = imageAssurance;
            return this;
        }

        /**
         * @param imageAssurance Set `True` to enable selected controls: Container Runtime Policy (`Block Non-Compliant Images`, `Block Unregistered Images`, and `Registries Allowed`) and Default Image Assurance Policy (`Images Blocked`).
         * 
         * @return builder
         * 
         */
        public Builder imageAssurance(Boolean imageAssurance) {
            return imageAssurance(Output.of(imageAssurance));
        }

        /**
         * @param installCommand Enforcer install command
         * 
         * @return builder
         * 
         */
        public Builder installCommand(@Nullable Output<String> installCommand) {
            $.installCommand = installCommand;
            return this;
        }

        /**
         * @param installCommand Enforcer install command
         * 
         * @return builder
         * 
         */
        public Builder installCommand(String installCommand) {
            return installCommand(Output.of(installCommand));
        }

        /**
         * @param kubeBenchImageName See https://docs.aquasec.com/docs/securing-kubernetes-applications#section-configuration-hardening, The KubeEnforcer can deploy the Aqua Security kube-bench open-source product to perform Kubernetes CIS benchmark testing of nodes.
         * 			This field specifies the path and file name of the kube-bench product image for the KubeEnforcer to deploy; it will be filled in automatically. You can optionally enter a different value.
         * 
         * @return builder
         * 
         */
        public Builder kubeBenchImageName(@Nullable Output<String> kubeBenchImageName) {
            $.kubeBenchImageName = kubeBenchImageName;
            return this;
        }

        /**
         * @param kubeBenchImageName See https://docs.aquasec.com/docs/securing-kubernetes-applications#section-configuration-hardening, The KubeEnforcer can deploy the Aqua Security kube-bench open-source product to perform Kubernetes CIS benchmark testing of nodes.
         * 			This field specifies the path and file name of the kube-bench product image for the KubeEnforcer to deploy; it will be filled in automatically. You can optionally enter a different value.
         * 
         * @return builder
         * 
         */
        public Builder kubeBenchImageName(String kubeBenchImageName) {
            return kubeBenchImageName(Output.of(kubeBenchImageName));
        }

        /**
         * @param lastUpdate The last date and time the batch token was updated in UNIX time.
         * 
         * @return builder
         * 
         */
        public Builder lastUpdate(@Nullable Output<Integer> lastUpdate) {
            $.lastUpdate = lastUpdate;
            return this;
        }

        /**
         * @param lastUpdate The last date and time the batch token was updated in UNIX time.
         * 
         * @return builder
         * 
         */
        public Builder lastUpdate(Integer lastUpdate) {
            return lastUpdate(Output.of(lastUpdate));
        }

        /**
         * @param logicalName Name for the batch install record.
         * 
         * @return builder
         * 
         */
        public Builder logicalName(@Nullable Output<String> logicalName) {
            $.logicalName = logicalName;
            return this;
        }

        /**
         * @param logicalName Name for the batch install record.
         * 
         * @return builder
         * 
         */
        public Builder logicalName(String logicalName) {
            return logicalName(Output.of(logicalName));
        }

        /**
         * @param lowVulns Number of low vulnerabilities in the enforcers that in this enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder lowVulns(@Nullable Output<Integer> lowVulns) {
            $.lowVulns = lowVulns;
            return this;
        }

        /**
         * @param lowVulns Number of low vulnerabilities in the enforcers that in this enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder lowVulns(Integer lowVulns) {
            return lowVulns(Output.of(lowVulns));
        }

        /**
         * @param medVulns Number of medium vulnerabilities in the enforcers that in this enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder medVulns(@Nullable Output<Integer> medVulns) {
            $.medVulns = medVulns;
            return this;
        }

        /**
         * @param medVulns Number of medium vulnerabilities in the enforcers that in this enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder medVulns(Integer medVulns) {
            return medVulns(Output.of(medVulns));
        }

        /**
         * @param microEnforcerCertsSecretsName This option is applicable only if `Enable Pod Enforcer injection` is selected.
         * 
         * @return builder
         * 
         */
        public Builder microEnforcerCertsSecretsName(@Nullable Output<String> microEnforcerCertsSecretsName) {
            $.microEnforcerCertsSecretsName = microEnforcerCertsSecretsName;
            return this;
        }

        /**
         * @param microEnforcerCertsSecretsName This option is applicable only if `Enable Pod Enforcer injection` is selected.
         * 
         * @return builder
         * 
         */
        public Builder microEnforcerCertsSecretsName(String microEnforcerCertsSecretsName) {
            return microEnforcerCertsSecretsName(Output.of(microEnforcerCertsSecretsName));
        }

        /**
         * @param microEnforcerImageName This option is applicable only if `Enable Pod Enforcer injection` is selected. This field specifies the path and file name of the KubeEnforcer product image to be deployed; it will be filled in automatically. You can optionally enter a different value.
         * 
         * @return builder
         * 
         */
        public Builder microEnforcerImageName(@Nullable Output<String> microEnforcerImageName) {
            $.microEnforcerImageName = microEnforcerImageName;
            return this;
        }

        /**
         * @param microEnforcerImageName This option is applicable only if `Enable Pod Enforcer injection` is selected. This field specifies the path and file name of the KubeEnforcer product image to be deployed; it will be filled in automatically. You can optionally enter a different value.
         * 
         * @return builder
         * 
         */
        public Builder microEnforcerImageName(String microEnforcerImageName) {
            return microEnforcerImageName(Output.of(microEnforcerImageName));
        }

        /**
         * @param microEnforcerInjection This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
         * 
         * @return builder
         * 
         */
        public Builder microEnforcerInjection(@Nullable Output<Boolean> microEnforcerInjection) {
            $.microEnforcerInjection = microEnforcerInjection;
            return this;
        }

        /**
         * @param microEnforcerInjection This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
         * 
         * @return builder
         * 
         */
        public Builder microEnforcerInjection(Boolean microEnforcerInjection) {
            return microEnforcerInjection(Output.of(microEnforcerInjection));
        }

        /**
         * @param microEnforcerSecretsName You can specify the name of the secret (in the Aqua namespace) that Aqua copies into the Pod Enforcer namespace and kube-bench, allowing them access to the Pod Enforcer and kube-bench product images, respectively.
         * 
         * @return builder
         * 
         */
        public Builder microEnforcerSecretsName(@Nullable Output<String> microEnforcerSecretsName) {
            $.microEnforcerSecretsName = microEnforcerSecretsName;
            return this;
        }

        /**
         * @param microEnforcerSecretsName You can specify the name of the secret (in the Aqua namespace) that Aqua copies into the Pod Enforcer namespace and kube-bench, allowing them access to the Pod Enforcer and kube-bench product images, respectively.
         * 
         * @return builder
         * 
         */
        public Builder microEnforcerSecretsName(String microEnforcerSecretsName) {
            return microEnforcerSecretsName(Output.of(microEnforcerSecretsName));
        }

        /**
         * @param negVulns Number of negligible vulnerabilities in the enforcers that in this enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder negVulns(@Nullable Output<Integer> negVulns) {
            $.negVulns = negVulns;
            return this;
        }

        /**
         * @param negVulns Number of negligible vulnerabilities in the enforcers that in this enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder negVulns(Integer negVulns) {
            return negVulns(Output.of(negVulns));
        }

        /**
         * @param networkProtection Send true to apply Firewall Policies to containers, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information.
         * 
         * @return builder
         * 
         */
        public Builder networkProtection(@Nullable Output<Boolean> networkProtection) {
            $.networkProtection = networkProtection;
            return this;
        }

        /**
         * @param networkProtection Send true to apply Firewall Policies to containers, and allow recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information.
         * 
         * @return builder
         * 
         */
        public Builder networkProtection(Boolean networkProtection) {
            return networkProtection(Output.of(networkProtection));
        }

        /**
         * @param orchestrators The orchestrator for which you are creating the Enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder orchestrators(@Nullable Output<List<EnforcerGroupsOrchestratorArgs>> orchestrators) {
            $.orchestrators = orchestrators;
            return this;
        }

        /**
         * @param orchestrators The orchestrator for which you are creating the Enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder orchestrators(List<EnforcerGroupsOrchestratorArgs> orchestrators) {
            return orchestrators(Output.of(orchestrators));
        }

        /**
         * @param orchestrators The orchestrator for which you are creating the Enforcer group.
         * 
         * @return builder
         * 
         */
        public Builder orchestrators(EnforcerGroupsOrchestratorArgs... orchestrators) {
            return orchestrators(List.of(orchestrators));
        }

        /**
         * @param pasDeploymentLink pas deployment link
         * 
         * @return builder
         * 
         */
        public Builder pasDeploymentLink(@Nullable Output<String> pasDeploymentLink) {
            $.pasDeploymentLink = pasDeploymentLink;
            return this;
        }

        /**
         * @param pasDeploymentLink pas deployment link
         * 
         * @return builder
         * 
         */
        public Builder pasDeploymentLink(String pasDeploymentLink) {
            return pasDeploymentLink(Output.of(pasDeploymentLink));
        }

        /**
         * @param permission Permission Action
         * 
         * @return builder
         * 
         */
        public Builder permission(@Nullable Output<String> permission) {
            $.permission = permission;
            return this;
        }

        /**
         * @param permission Permission Action
         * 
         * @return builder
         * 
         */
        public Builder permission(String permission) {
            return permission(Output.of(permission));
        }

        /**
         * @param riskExplorerAutoDiscovery Set `True` to allow Enforcers to be discovered in the Risk Explorer.
         * 
         * @return builder
         * 
         */
        public Builder riskExplorerAutoDiscovery(@Nullable Output<Boolean> riskExplorerAutoDiscovery) {
            $.riskExplorerAutoDiscovery = riskExplorerAutoDiscovery;
            return this;
        }

        /**
         * @param riskExplorerAutoDiscovery Set `True` to allow Enforcers to be discovered in the Risk Explorer.
         * 
         * @return builder
         * 
         */
        public Builder riskExplorerAutoDiscovery(Boolean riskExplorerAutoDiscovery) {
            return riskExplorerAutoDiscovery(Output.of(riskExplorerAutoDiscovery));
        }

        /**
         * @param runtimePolicyName Function Runtime Policy that will applay on the nano enforcer.
         * 
         * @return builder
         * 
         */
        public Builder runtimePolicyName(@Nullable Output<String> runtimePolicyName) {
            $.runtimePolicyName = runtimePolicyName;
            return this;
        }

        /**
         * @param runtimePolicyName Function Runtime Policy that will applay on the nano enforcer.
         * 
         * @return builder
         * 
         */
        public Builder runtimePolicyName(String runtimePolicyName) {
            return runtimePolicyName(Output.of(runtimePolicyName));
        }

        /**
         * @param runtimeType The container runtime environment.
         * 
         * @return builder
         * 
         */
        public Builder runtimeType(@Nullable Output<String> runtimeType) {
            $.runtimeType = runtimeType;
            return this;
        }

        /**
         * @param runtimeType The container runtime environment.
         * 
         * @return builder
         * 
         */
        public Builder runtimeType(String runtimeType) {
            return runtimeType(Output.of(runtimeType));
        }

        /**
         * @param syncHostImages Set `True` to configure Enforcers to discover local host images. Discovered images will be listed under Images &gt; Host Images, as well as under Infrastructure (in the Images tab for applicable hosts).
         * 
         * @return builder
         * 
         */
        public Builder syncHostImages(@Nullable Output<Boolean> syncHostImages) {
            $.syncHostImages = syncHostImages;
            return this;
        }

        /**
         * @param syncHostImages Set `True` to configure Enforcers to discover local host images. Discovered images will be listed under Images &gt; Host Images, as well as under Infrastructure (in the Images tab for applicable hosts).
         * 
         * @return builder
         * 
         */
        public Builder syncHostImages(Boolean syncHostImages) {
            return syncHostImages(Output.of(syncHostImages));
        }

        /**
         * @param syscallEnabled Set `True` will allow profiling and monitoring system calls made by running containers.
         * 
         * @return builder
         * 
         */
        public Builder syscallEnabled(@Nullable Output<Boolean> syscallEnabled) {
            $.syscallEnabled = syscallEnabled;
            return this;
        }

        /**
         * @param syscallEnabled Set `True` will allow profiling and monitoring system calls made by running containers.
         * 
         * @return builder
         * 
         */
        public Builder syscallEnabled(Boolean syscallEnabled) {
            return syscallEnabled(Output.of(syscallEnabled));
        }

        /**
         * @param token The batch install token.
         * 
         * @return builder
         * 
         */
        public Builder token(@Nullable Output<String> token) {
            $.token = token;
            return this;
        }

        /**
         * @param token The batch install token.
         * 
         * @return builder
         * 
         */
        public Builder token(String token) {
            return token(Output.of(token));
        }

        /**
         * @param type Enforcer Type.
         * 
         * @return builder
         * 
         */
        public Builder type(@Nullable Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type Enforcer Type.
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        /**
         * @param userAccessControl Set `True` to apply User Access Control Policies to containers. Note that Aqua Enforcers must be deployed with the AQUA*RUNC*INTERCEPTION environment variable set to 0 in order to use User Access Control Policies.
         * 
         * @return builder
         * 
         */
        public Builder userAccessControl(@Nullable Output<Boolean> userAccessControl) {
            $.userAccessControl = userAccessControl;
            return this;
        }

        /**
         * @param userAccessControl Set `True` to apply User Access Control Policies to containers. Note that Aqua Enforcers must be deployed with the AQUA*RUNC*INTERCEPTION environment variable set to 0 in order to use User Access Control Policies.
         * 
         * @return builder
         * 
         */
        public Builder userAccessControl(Boolean userAccessControl) {
            return userAccessControl(Output.of(userAccessControl));
        }

        public EnforcerGroupsState build() {
            return $;
        }
    }

}
