// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumiverse.aquasec.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumiverse.aquasec.outputs.GetContainerRuntimePolicyFileIntegrityMonitoring;
import com.pulumiverse.aquasec.outputs.GetContainerRuntimePolicyMalwareScanOption;
import com.pulumiverse.aquasec.outputs.GetContainerRuntimePolicyScopeVariable;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetContainerRuntimePolicyResult {
    /**
     * @return List of executables that are allowed for the user.
     * 
     */
    private List<String> allowedExecutables;
    /**
     * @return List of registries that allowed for running containers.
     * 
     */
    private List<String> allowedRegistries;
    /**
     * @return Indicates the application scope of the service.
     * 
     */
    private List<String> applicationScopes;
    /**
     * @return If true, all network activity will be audited.
     * 
     */
    private Boolean auditAllNetworkActivity;
    /**
     * @return If true, all process activity will be audited.
     * 
     */
    private Boolean auditAllProcessesActivity;
    /**
     * @return If true, full command arguments will be audited.
     * 
     */
    private Boolean auditFullCommandArguments;
    /**
     * @return Username of the account that created the service.
     * 
     */
    private String author;
    /**
     * @return If true, prevent containers from running with access to host network.
     * 
     */
    private Boolean blockAccessHostNetwork;
    /**
     * @return If true, prevent containers from running with adding capabilities with `--cap-add` privilege.
     * 
     */
    private Boolean blockAddingCapabilities;
    /**
     * @return If true, exec into a container is prevented.
     * 
     */
    private Boolean blockContainerExec;
    /**
     * @return Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
     * 
     */
    private Boolean blockCryptocurrencyMining;
    /**
     * @return Detect and prevent running in-memory execution
     * 
     */
    private Boolean blockFilelessExec;
    /**
     * @return If true, prevent containers from running with the capability to bind in port lower than 1024.
     * 
     */
    private Boolean blockLowPortBinding;
    /**
     * @return If true, running non-compliant image in the container is prevented.
     * 
     */
    private Boolean blockNonCompliantImages;
    /**
     * @return If true, running containers in non-compliant pods is prevented.
     * 
     */
    private Boolean blockNonCompliantWorkloads;
    /**
     * @return If true, running non-kubernetes containers is prevented.
     * 
     */
    private Boolean blockNonK8sContainers;
    /**
     * @return If true, prevent containers from running with privileged container capability.
     * 
     */
    private Boolean blockPrivilegedContainers;
    /**
     * @return If true, reverse shell is prevented.
     * 
     */
    private Boolean blockReverseShell;
    /**
     * @return If true, prevent containers from running with root user.
     * 
     */
    private Boolean blockRootUser;
    /**
     * @return If true, running images in the container that are not registered in Aqua is prevented.
     * 
     */
    private Boolean blockUnregisteredImages;
    /**
     * @return If true, prevent containers from running with the privilege to use the IPC namespace.
     * 
     */
    private Boolean blockUseIpcNamespace;
    /**
     * @return If true, prevent containers from running with the privilege to use the PID namespace.
     * 
     */
    private Boolean blockUsePidNamespace;
    /**
     * @return If true, prevent containers from running with the privilege to use the user namespace.
     * 
     */
    private Boolean blockUseUserNamespace;
    /**
     * @return If true, prevent containers from running with the privilege to use the UTS namespace.
     * 
     */
    private Boolean blockUseUtsNamespace;
    /**
     * @return If true, prevents containers from using specific Unix capabilities.
     * 
     */
    private List<String> blockedCapabilities;
    /**
     * @return List of executables that are prevented from running in containers.
     * 
     */
    private List<String> blockedExecutables;
    /**
     * @return List of files that are prevented from being read, modified and executed in the containers.
     * 
     */
    private List<String> blockedFiles;
    /**
     * @return List of blocked inbound ports.
     * 
     */
    private List<String> blockedInboundPorts;
    /**
     * @return List of blocked outbound ports.
     * 
     */
    private List<String> blockedOutboundPorts;
    /**
     * @return Prevent containers from reading, writing, or executing all files in the list of packages.
     * 
     */
    private List<String> blockedPackages;
    /**
     * @return List of volumes that are prevented from being mounted in the containers.
     * 
     */
    private List<String> blockedVolumes;
    /**
     * @return List of processes that will be allowed.
     * 
     */
    private List<String> containerExecAllowedProcesses;
    /**
     * @return The description of the container runtime policy
     * 
     */
    private String description;
    /**
     * @return If true, executables that are not in the original image is prevented from running.
     * 
     */
    private Boolean enableDriftPrevention;
    /**
     * @return If true, fork bombs are prevented in the containers.
     * 
     */
    private Boolean enableForkGuard;
    /**
     * @return If true, detect and prevent communication from containers to IP addresses known to have a bad reputation.
     * 
     */
    private Boolean enableIpReputationSecurity;
    /**
     * @return If true, detects port scanning behavior in the container.
     * 
     */
    private Boolean enablePortScanDetection;
    /**
     * @return Indicates if the runtime policy is enabled or not.
     * 
     */
    private Boolean enabled;
    /**
     * @return Indicates that policy should effect container execution (not just for audit).
     * 
     */
    private Boolean enforce;
    /**
     * @return Indicates the number of days after which the runtime policy will be changed to enforce mode.
     * 
     */
    private Integer enforceAfterDays;
    /**
     * @return List of files and directories to be excluded from the read-only list.
     * 
     */
    private List<String> exceptionalReadonlyFilesAndDirectories;
    /**
     * @return Configuration for file integrity monitoring.
     * 
     */
    private List<GetContainerRuntimePolicyFileIntegrityMonitoring> fileIntegrityMonitorings;
    /**
     * @return Process limit for the fork guard.
     * 
     */
    private Integer forkGuardProcessLimit;
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    private String id;
    /**
     * @return If true, prevents the container from obtaining new privileges at runtime. (only enabled in enforce mode)
     * 
     */
    private Boolean limitNewPrivileges;
    /**
     * @return Configuration for Real-Time Malware Protection.
     * 
     */
    private List<GetContainerRuntimePolicyMalwareScanOption> malwareScanOptions;
    /**
     * @return If true, system time changes will be monitored.
     * 
     */
    private Boolean monitorSystemTimeChanges;
    /**
     * @return Name of the container runtime policy
     * 
     */
    private String name;
    /**
     * @return List of files and directories to be restricted as read-only
     * 
     */
    private List<String> readonlyFilesAndDirectories;
    /**
     * @return List of IPs/ CIDRs that will be allowed
     * 
     */
    private List<String> reverseShellAllowedIps;
    /**
     * @return List of processes that will be allowed
     * 
     */
    private List<String> reverseShellAllowedProcesses;
    /**
     * @return Logical expression of how to compute the dependency of the scope variables.
     * 
     */
    private String scopeExpression;
    /**
     * @return List of scope attributes.
     * 
     */
    private List<GetContainerRuntimePolicyScopeVariable> scopeVariables;

    private GetContainerRuntimePolicyResult() {}
    /**
     * @return List of executables that are allowed for the user.
     * 
     */
    public List<String> allowedExecutables() {
        return this.allowedExecutables;
    }
    /**
     * @return List of registries that allowed for running containers.
     * 
     */
    public List<String> allowedRegistries() {
        return this.allowedRegistries;
    }
    /**
     * @return Indicates the application scope of the service.
     * 
     */
    public List<String> applicationScopes() {
        return this.applicationScopes;
    }
    /**
     * @return If true, all network activity will be audited.
     * 
     */
    public Boolean auditAllNetworkActivity() {
        return this.auditAllNetworkActivity;
    }
    /**
     * @return If true, all process activity will be audited.
     * 
     */
    public Boolean auditAllProcessesActivity() {
        return this.auditAllProcessesActivity;
    }
    /**
     * @return If true, full command arguments will be audited.
     * 
     */
    public Boolean auditFullCommandArguments() {
        return this.auditFullCommandArguments;
    }
    /**
     * @return Username of the account that created the service.
     * 
     */
    public String author() {
        return this.author;
    }
    /**
     * @return If true, prevent containers from running with access to host network.
     * 
     */
    public Boolean blockAccessHostNetwork() {
        return this.blockAccessHostNetwork;
    }
    /**
     * @return If true, prevent containers from running with adding capabilities with `--cap-add` privilege.
     * 
     */
    public Boolean blockAddingCapabilities() {
        return this.blockAddingCapabilities;
    }
    /**
     * @return If true, exec into a container is prevented.
     * 
     */
    public Boolean blockContainerExec() {
        return this.blockContainerExec;
    }
    /**
     * @return Detect and prevent communication to DNS/IP addresses known to be used for Cryptocurrency Mining
     * 
     */
    public Boolean blockCryptocurrencyMining() {
        return this.blockCryptocurrencyMining;
    }
    /**
     * @return Detect and prevent running in-memory execution
     * 
     */
    public Boolean blockFilelessExec() {
        return this.blockFilelessExec;
    }
    /**
     * @return If true, prevent containers from running with the capability to bind in port lower than 1024.
     * 
     */
    public Boolean blockLowPortBinding() {
        return this.blockLowPortBinding;
    }
    /**
     * @return If true, running non-compliant image in the container is prevented.
     * 
     */
    public Boolean blockNonCompliantImages() {
        return this.blockNonCompliantImages;
    }
    /**
     * @return If true, running containers in non-compliant pods is prevented.
     * 
     */
    public Boolean blockNonCompliantWorkloads() {
        return this.blockNonCompliantWorkloads;
    }
    /**
     * @return If true, running non-kubernetes containers is prevented.
     * 
     */
    public Boolean blockNonK8sContainers() {
        return this.blockNonK8sContainers;
    }
    /**
     * @return If true, prevent containers from running with privileged container capability.
     * 
     */
    public Boolean blockPrivilegedContainers() {
        return this.blockPrivilegedContainers;
    }
    /**
     * @return If true, reverse shell is prevented.
     * 
     */
    public Boolean blockReverseShell() {
        return this.blockReverseShell;
    }
    /**
     * @return If true, prevent containers from running with root user.
     * 
     */
    public Boolean blockRootUser() {
        return this.blockRootUser;
    }
    /**
     * @return If true, running images in the container that are not registered in Aqua is prevented.
     * 
     */
    public Boolean blockUnregisteredImages() {
        return this.blockUnregisteredImages;
    }
    /**
     * @return If true, prevent containers from running with the privilege to use the IPC namespace.
     * 
     */
    public Boolean blockUseIpcNamespace() {
        return this.blockUseIpcNamespace;
    }
    /**
     * @return If true, prevent containers from running with the privilege to use the PID namespace.
     * 
     */
    public Boolean blockUsePidNamespace() {
        return this.blockUsePidNamespace;
    }
    /**
     * @return If true, prevent containers from running with the privilege to use the user namespace.
     * 
     */
    public Boolean blockUseUserNamespace() {
        return this.blockUseUserNamespace;
    }
    /**
     * @return If true, prevent containers from running with the privilege to use the UTS namespace.
     * 
     */
    public Boolean blockUseUtsNamespace() {
        return this.blockUseUtsNamespace;
    }
    /**
     * @return If true, prevents containers from using specific Unix capabilities.
     * 
     */
    public List<String> blockedCapabilities() {
        return this.blockedCapabilities;
    }
    /**
     * @return List of executables that are prevented from running in containers.
     * 
     */
    public List<String> blockedExecutables() {
        return this.blockedExecutables;
    }
    /**
     * @return List of files that are prevented from being read, modified and executed in the containers.
     * 
     */
    public List<String> blockedFiles() {
        return this.blockedFiles;
    }
    /**
     * @return List of blocked inbound ports.
     * 
     */
    public List<String> blockedInboundPorts() {
        return this.blockedInboundPorts;
    }
    /**
     * @return List of blocked outbound ports.
     * 
     */
    public List<String> blockedOutboundPorts() {
        return this.blockedOutboundPorts;
    }
    /**
     * @return Prevent containers from reading, writing, or executing all files in the list of packages.
     * 
     */
    public List<String> blockedPackages() {
        return this.blockedPackages;
    }
    /**
     * @return List of volumes that are prevented from being mounted in the containers.
     * 
     */
    public List<String> blockedVolumes() {
        return this.blockedVolumes;
    }
    /**
     * @return List of processes that will be allowed.
     * 
     */
    public List<String> containerExecAllowedProcesses() {
        return this.containerExecAllowedProcesses;
    }
    /**
     * @return The description of the container runtime policy
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return If true, executables that are not in the original image is prevented from running.
     * 
     */
    public Boolean enableDriftPrevention() {
        return this.enableDriftPrevention;
    }
    /**
     * @return If true, fork bombs are prevented in the containers.
     * 
     */
    public Boolean enableForkGuard() {
        return this.enableForkGuard;
    }
    /**
     * @return If true, detect and prevent communication from containers to IP addresses known to have a bad reputation.
     * 
     */
    public Boolean enableIpReputationSecurity() {
        return this.enableIpReputationSecurity;
    }
    /**
     * @return If true, detects port scanning behavior in the container.
     * 
     */
    public Boolean enablePortScanDetection() {
        return this.enablePortScanDetection;
    }
    /**
     * @return Indicates if the runtime policy is enabled or not.
     * 
     */
    public Boolean enabled() {
        return this.enabled;
    }
    /**
     * @return Indicates that policy should effect container execution (not just for audit).
     * 
     */
    public Boolean enforce() {
        return this.enforce;
    }
    /**
     * @return Indicates the number of days after which the runtime policy will be changed to enforce mode.
     * 
     */
    public Integer enforceAfterDays() {
        return this.enforceAfterDays;
    }
    /**
     * @return List of files and directories to be excluded from the read-only list.
     * 
     */
    public List<String> exceptionalReadonlyFilesAndDirectories() {
        return this.exceptionalReadonlyFilesAndDirectories;
    }
    /**
     * @return Configuration for file integrity monitoring.
     * 
     */
    public List<GetContainerRuntimePolicyFileIntegrityMonitoring> fileIntegrityMonitorings() {
        return this.fileIntegrityMonitorings;
    }
    /**
     * @return Process limit for the fork guard.
     * 
     */
    public Integer forkGuardProcessLimit() {
        return this.forkGuardProcessLimit;
    }
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return If true, prevents the container from obtaining new privileges at runtime. (only enabled in enforce mode)
     * 
     */
    public Boolean limitNewPrivileges() {
        return this.limitNewPrivileges;
    }
    /**
     * @return Configuration for Real-Time Malware Protection.
     * 
     */
    public List<GetContainerRuntimePolicyMalwareScanOption> malwareScanOptions() {
        return this.malwareScanOptions;
    }
    /**
     * @return If true, system time changes will be monitored.
     * 
     */
    public Boolean monitorSystemTimeChanges() {
        return this.monitorSystemTimeChanges;
    }
    /**
     * @return Name of the container runtime policy
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return List of files and directories to be restricted as read-only
     * 
     */
    public List<String> readonlyFilesAndDirectories() {
        return this.readonlyFilesAndDirectories;
    }
    /**
     * @return List of IPs/ CIDRs that will be allowed
     * 
     */
    public List<String> reverseShellAllowedIps() {
        return this.reverseShellAllowedIps;
    }
    /**
     * @return List of processes that will be allowed
     * 
     */
    public List<String> reverseShellAllowedProcesses() {
        return this.reverseShellAllowedProcesses;
    }
    /**
     * @return Logical expression of how to compute the dependency of the scope variables.
     * 
     */
    public String scopeExpression() {
        return this.scopeExpression;
    }
    /**
     * @return List of scope attributes.
     * 
     */
    public List<GetContainerRuntimePolicyScopeVariable> scopeVariables() {
        return this.scopeVariables;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetContainerRuntimePolicyResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private List<String> allowedExecutables;
        private List<String> allowedRegistries;
        private List<String> applicationScopes;
        private Boolean auditAllNetworkActivity;
        private Boolean auditAllProcessesActivity;
        private Boolean auditFullCommandArguments;
        private String author;
        private Boolean blockAccessHostNetwork;
        private Boolean blockAddingCapabilities;
        private Boolean blockContainerExec;
        private Boolean blockCryptocurrencyMining;
        private Boolean blockFilelessExec;
        private Boolean blockLowPortBinding;
        private Boolean blockNonCompliantImages;
        private Boolean blockNonCompliantWorkloads;
        private Boolean blockNonK8sContainers;
        private Boolean blockPrivilegedContainers;
        private Boolean blockReverseShell;
        private Boolean blockRootUser;
        private Boolean blockUnregisteredImages;
        private Boolean blockUseIpcNamespace;
        private Boolean blockUsePidNamespace;
        private Boolean blockUseUserNamespace;
        private Boolean blockUseUtsNamespace;
        private List<String> blockedCapabilities;
        private List<String> blockedExecutables;
        private List<String> blockedFiles;
        private List<String> blockedInboundPorts;
        private List<String> blockedOutboundPorts;
        private List<String> blockedPackages;
        private List<String> blockedVolumes;
        private List<String> containerExecAllowedProcesses;
        private String description;
        private Boolean enableDriftPrevention;
        private Boolean enableForkGuard;
        private Boolean enableIpReputationSecurity;
        private Boolean enablePortScanDetection;
        private Boolean enabled;
        private Boolean enforce;
        private Integer enforceAfterDays;
        private List<String> exceptionalReadonlyFilesAndDirectories;
        private List<GetContainerRuntimePolicyFileIntegrityMonitoring> fileIntegrityMonitorings;
        private Integer forkGuardProcessLimit;
        private String id;
        private Boolean limitNewPrivileges;
        private List<GetContainerRuntimePolicyMalwareScanOption> malwareScanOptions;
        private Boolean monitorSystemTimeChanges;
        private String name;
        private List<String> readonlyFilesAndDirectories;
        private List<String> reverseShellAllowedIps;
        private List<String> reverseShellAllowedProcesses;
        private String scopeExpression;
        private List<GetContainerRuntimePolicyScopeVariable> scopeVariables;
        public Builder() {}
        public Builder(GetContainerRuntimePolicyResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.allowedExecutables = defaults.allowedExecutables;
    	      this.allowedRegistries = defaults.allowedRegistries;
    	      this.applicationScopes = defaults.applicationScopes;
    	      this.auditAllNetworkActivity = defaults.auditAllNetworkActivity;
    	      this.auditAllProcessesActivity = defaults.auditAllProcessesActivity;
    	      this.auditFullCommandArguments = defaults.auditFullCommandArguments;
    	      this.author = defaults.author;
    	      this.blockAccessHostNetwork = defaults.blockAccessHostNetwork;
    	      this.blockAddingCapabilities = defaults.blockAddingCapabilities;
    	      this.blockContainerExec = defaults.blockContainerExec;
    	      this.blockCryptocurrencyMining = defaults.blockCryptocurrencyMining;
    	      this.blockFilelessExec = defaults.blockFilelessExec;
    	      this.blockLowPortBinding = defaults.blockLowPortBinding;
    	      this.blockNonCompliantImages = defaults.blockNonCompliantImages;
    	      this.blockNonCompliantWorkloads = defaults.blockNonCompliantWorkloads;
    	      this.blockNonK8sContainers = defaults.blockNonK8sContainers;
    	      this.blockPrivilegedContainers = defaults.blockPrivilegedContainers;
    	      this.blockReverseShell = defaults.blockReverseShell;
    	      this.blockRootUser = defaults.blockRootUser;
    	      this.blockUnregisteredImages = defaults.blockUnregisteredImages;
    	      this.blockUseIpcNamespace = defaults.blockUseIpcNamespace;
    	      this.blockUsePidNamespace = defaults.blockUsePidNamespace;
    	      this.blockUseUserNamespace = defaults.blockUseUserNamespace;
    	      this.blockUseUtsNamespace = defaults.blockUseUtsNamespace;
    	      this.blockedCapabilities = defaults.blockedCapabilities;
    	      this.blockedExecutables = defaults.blockedExecutables;
    	      this.blockedFiles = defaults.blockedFiles;
    	      this.blockedInboundPorts = defaults.blockedInboundPorts;
    	      this.blockedOutboundPorts = defaults.blockedOutboundPorts;
    	      this.blockedPackages = defaults.blockedPackages;
    	      this.blockedVolumes = defaults.blockedVolumes;
    	      this.containerExecAllowedProcesses = defaults.containerExecAllowedProcesses;
    	      this.description = defaults.description;
    	      this.enableDriftPrevention = defaults.enableDriftPrevention;
    	      this.enableForkGuard = defaults.enableForkGuard;
    	      this.enableIpReputationSecurity = defaults.enableIpReputationSecurity;
    	      this.enablePortScanDetection = defaults.enablePortScanDetection;
    	      this.enabled = defaults.enabled;
    	      this.enforce = defaults.enforce;
    	      this.enforceAfterDays = defaults.enforceAfterDays;
    	      this.exceptionalReadonlyFilesAndDirectories = defaults.exceptionalReadonlyFilesAndDirectories;
    	      this.fileIntegrityMonitorings = defaults.fileIntegrityMonitorings;
    	      this.forkGuardProcessLimit = defaults.forkGuardProcessLimit;
    	      this.id = defaults.id;
    	      this.limitNewPrivileges = defaults.limitNewPrivileges;
    	      this.malwareScanOptions = defaults.malwareScanOptions;
    	      this.monitorSystemTimeChanges = defaults.monitorSystemTimeChanges;
    	      this.name = defaults.name;
    	      this.readonlyFilesAndDirectories = defaults.readonlyFilesAndDirectories;
    	      this.reverseShellAllowedIps = defaults.reverseShellAllowedIps;
    	      this.reverseShellAllowedProcesses = defaults.reverseShellAllowedProcesses;
    	      this.scopeExpression = defaults.scopeExpression;
    	      this.scopeVariables = defaults.scopeVariables;
        }

        @CustomType.Setter
        public Builder allowedExecutables(List<String> allowedExecutables) {
            this.allowedExecutables = Objects.requireNonNull(allowedExecutables);
            return this;
        }
        public Builder allowedExecutables(String... allowedExecutables) {
            return allowedExecutables(List.of(allowedExecutables));
        }
        @CustomType.Setter
        public Builder allowedRegistries(List<String> allowedRegistries) {
            this.allowedRegistries = Objects.requireNonNull(allowedRegistries);
            return this;
        }
        public Builder allowedRegistries(String... allowedRegistries) {
            return allowedRegistries(List.of(allowedRegistries));
        }
        @CustomType.Setter
        public Builder applicationScopes(List<String> applicationScopes) {
            this.applicationScopes = Objects.requireNonNull(applicationScopes);
            return this;
        }
        public Builder applicationScopes(String... applicationScopes) {
            return applicationScopes(List.of(applicationScopes));
        }
        @CustomType.Setter
        public Builder auditAllNetworkActivity(Boolean auditAllNetworkActivity) {
            this.auditAllNetworkActivity = Objects.requireNonNull(auditAllNetworkActivity);
            return this;
        }
        @CustomType.Setter
        public Builder auditAllProcessesActivity(Boolean auditAllProcessesActivity) {
            this.auditAllProcessesActivity = Objects.requireNonNull(auditAllProcessesActivity);
            return this;
        }
        @CustomType.Setter
        public Builder auditFullCommandArguments(Boolean auditFullCommandArguments) {
            this.auditFullCommandArguments = Objects.requireNonNull(auditFullCommandArguments);
            return this;
        }
        @CustomType.Setter
        public Builder author(String author) {
            this.author = Objects.requireNonNull(author);
            return this;
        }
        @CustomType.Setter
        public Builder blockAccessHostNetwork(Boolean blockAccessHostNetwork) {
            this.blockAccessHostNetwork = Objects.requireNonNull(blockAccessHostNetwork);
            return this;
        }
        @CustomType.Setter
        public Builder blockAddingCapabilities(Boolean blockAddingCapabilities) {
            this.blockAddingCapabilities = Objects.requireNonNull(blockAddingCapabilities);
            return this;
        }
        @CustomType.Setter
        public Builder blockContainerExec(Boolean blockContainerExec) {
            this.blockContainerExec = Objects.requireNonNull(blockContainerExec);
            return this;
        }
        @CustomType.Setter
        public Builder blockCryptocurrencyMining(Boolean blockCryptocurrencyMining) {
            this.blockCryptocurrencyMining = Objects.requireNonNull(blockCryptocurrencyMining);
            return this;
        }
        @CustomType.Setter
        public Builder blockFilelessExec(Boolean blockFilelessExec) {
            this.blockFilelessExec = Objects.requireNonNull(blockFilelessExec);
            return this;
        }
        @CustomType.Setter
        public Builder blockLowPortBinding(Boolean blockLowPortBinding) {
            this.blockLowPortBinding = Objects.requireNonNull(blockLowPortBinding);
            return this;
        }
        @CustomType.Setter
        public Builder blockNonCompliantImages(Boolean blockNonCompliantImages) {
            this.blockNonCompliantImages = Objects.requireNonNull(blockNonCompliantImages);
            return this;
        }
        @CustomType.Setter
        public Builder blockNonCompliantWorkloads(Boolean blockNonCompliantWorkloads) {
            this.blockNonCompliantWorkloads = Objects.requireNonNull(blockNonCompliantWorkloads);
            return this;
        }
        @CustomType.Setter
        public Builder blockNonK8sContainers(Boolean blockNonK8sContainers) {
            this.blockNonK8sContainers = Objects.requireNonNull(blockNonK8sContainers);
            return this;
        }
        @CustomType.Setter
        public Builder blockPrivilegedContainers(Boolean blockPrivilegedContainers) {
            this.blockPrivilegedContainers = Objects.requireNonNull(blockPrivilegedContainers);
            return this;
        }
        @CustomType.Setter
        public Builder blockReverseShell(Boolean blockReverseShell) {
            this.blockReverseShell = Objects.requireNonNull(blockReverseShell);
            return this;
        }
        @CustomType.Setter
        public Builder blockRootUser(Boolean blockRootUser) {
            this.blockRootUser = Objects.requireNonNull(blockRootUser);
            return this;
        }
        @CustomType.Setter
        public Builder blockUnregisteredImages(Boolean blockUnregisteredImages) {
            this.blockUnregisteredImages = Objects.requireNonNull(blockUnregisteredImages);
            return this;
        }
        @CustomType.Setter
        public Builder blockUseIpcNamespace(Boolean blockUseIpcNamespace) {
            this.blockUseIpcNamespace = Objects.requireNonNull(blockUseIpcNamespace);
            return this;
        }
        @CustomType.Setter
        public Builder blockUsePidNamespace(Boolean blockUsePidNamespace) {
            this.blockUsePidNamespace = Objects.requireNonNull(blockUsePidNamespace);
            return this;
        }
        @CustomType.Setter
        public Builder blockUseUserNamespace(Boolean blockUseUserNamespace) {
            this.blockUseUserNamespace = Objects.requireNonNull(blockUseUserNamespace);
            return this;
        }
        @CustomType.Setter
        public Builder blockUseUtsNamespace(Boolean blockUseUtsNamespace) {
            this.blockUseUtsNamespace = Objects.requireNonNull(blockUseUtsNamespace);
            return this;
        }
        @CustomType.Setter
        public Builder blockedCapabilities(List<String> blockedCapabilities) {
            this.blockedCapabilities = Objects.requireNonNull(blockedCapabilities);
            return this;
        }
        public Builder blockedCapabilities(String... blockedCapabilities) {
            return blockedCapabilities(List.of(blockedCapabilities));
        }
        @CustomType.Setter
        public Builder blockedExecutables(List<String> blockedExecutables) {
            this.blockedExecutables = Objects.requireNonNull(blockedExecutables);
            return this;
        }
        public Builder blockedExecutables(String... blockedExecutables) {
            return blockedExecutables(List.of(blockedExecutables));
        }
        @CustomType.Setter
        public Builder blockedFiles(List<String> blockedFiles) {
            this.blockedFiles = Objects.requireNonNull(blockedFiles);
            return this;
        }
        public Builder blockedFiles(String... blockedFiles) {
            return blockedFiles(List.of(blockedFiles));
        }
        @CustomType.Setter
        public Builder blockedInboundPorts(List<String> blockedInboundPorts) {
            this.blockedInboundPorts = Objects.requireNonNull(blockedInboundPorts);
            return this;
        }
        public Builder blockedInboundPorts(String... blockedInboundPorts) {
            return blockedInboundPorts(List.of(blockedInboundPorts));
        }
        @CustomType.Setter
        public Builder blockedOutboundPorts(List<String> blockedOutboundPorts) {
            this.blockedOutboundPorts = Objects.requireNonNull(blockedOutboundPorts);
            return this;
        }
        public Builder blockedOutboundPorts(String... blockedOutboundPorts) {
            return blockedOutboundPorts(List.of(blockedOutboundPorts));
        }
        @CustomType.Setter
        public Builder blockedPackages(List<String> blockedPackages) {
            this.blockedPackages = Objects.requireNonNull(blockedPackages);
            return this;
        }
        public Builder blockedPackages(String... blockedPackages) {
            return blockedPackages(List.of(blockedPackages));
        }
        @CustomType.Setter
        public Builder blockedVolumes(List<String> blockedVolumes) {
            this.blockedVolumes = Objects.requireNonNull(blockedVolumes);
            return this;
        }
        public Builder blockedVolumes(String... blockedVolumes) {
            return blockedVolumes(List.of(blockedVolumes));
        }
        @CustomType.Setter
        public Builder containerExecAllowedProcesses(List<String> containerExecAllowedProcesses) {
            this.containerExecAllowedProcesses = Objects.requireNonNull(containerExecAllowedProcesses);
            return this;
        }
        public Builder containerExecAllowedProcesses(String... containerExecAllowedProcesses) {
            return containerExecAllowedProcesses(List.of(containerExecAllowedProcesses));
        }
        @CustomType.Setter
        public Builder description(String description) {
            this.description = Objects.requireNonNull(description);
            return this;
        }
        @CustomType.Setter
        public Builder enableDriftPrevention(Boolean enableDriftPrevention) {
            this.enableDriftPrevention = Objects.requireNonNull(enableDriftPrevention);
            return this;
        }
        @CustomType.Setter
        public Builder enableForkGuard(Boolean enableForkGuard) {
            this.enableForkGuard = Objects.requireNonNull(enableForkGuard);
            return this;
        }
        @CustomType.Setter
        public Builder enableIpReputationSecurity(Boolean enableIpReputationSecurity) {
            this.enableIpReputationSecurity = Objects.requireNonNull(enableIpReputationSecurity);
            return this;
        }
        @CustomType.Setter
        public Builder enablePortScanDetection(Boolean enablePortScanDetection) {
            this.enablePortScanDetection = Objects.requireNonNull(enablePortScanDetection);
            return this;
        }
        @CustomType.Setter
        public Builder enabled(Boolean enabled) {
            this.enabled = Objects.requireNonNull(enabled);
            return this;
        }
        @CustomType.Setter
        public Builder enforce(Boolean enforce) {
            this.enforce = Objects.requireNonNull(enforce);
            return this;
        }
        @CustomType.Setter
        public Builder enforceAfterDays(Integer enforceAfterDays) {
            this.enforceAfterDays = Objects.requireNonNull(enforceAfterDays);
            return this;
        }
        @CustomType.Setter
        public Builder exceptionalReadonlyFilesAndDirectories(List<String> exceptionalReadonlyFilesAndDirectories) {
            this.exceptionalReadonlyFilesAndDirectories = Objects.requireNonNull(exceptionalReadonlyFilesAndDirectories);
            return this;
        }
        public Builder exceptionalReadonlyFilesAndDirectories(String... exceptionalReadonlyFilesAndDirectories) {
            return exceptionalReadonlyFilesAndDirectories(List.of(exceptionalReadonlyFilesAndDirectories));
        }
        @CustomType.Setter
        public Builder fileIntegrityMonitorings(List<GetContainerRuntimePolicyFileIntegrityMonitoring> fileIntegrityMonitorings) {
            this.fileIntegrityMonitorings = Objects.requireNonNull(fileIntegrityMonitorings);
            return this;
        }
        public Builder fileIntegrityMonitorings(GetContainerRuntimePolicyFileIntegrityMonitoring... fileIntegrityMonitorings) {
            return fileIntegrityMonitorings(List.of(fileIntegrityMonitorings));
        }
        @CustomType.Setter
        public Builder forkGuardProcessLimit(Integer forkGuardProcessLimit) {
            this.forkGuardProcessLimit = Objects.requireNonNull(forkGuardProcessLimit);
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            this.id = Objects.requireNonNull(id);
            return this;
        }
        @CustomType.Setter
        public Builder limitNewPrivileges(Boolean limitNewPrivileges) {
            this.limitNewPrivileges = Objects.requireNonNull(limitNewPrivileges);
            return this;
        }
        @CustomType.Setter
        public Builder malwareScanOptions(List<GetContainerRuntimePolicyMalwareScanOption> malwareScanOptions) {
            this.malwareScanOptions = Objects.requireNonNull(malwareScanOptions);
            return this;
        }
        public Builder malwareScanOptions(GetContainerRuntimePolicyMalwareScanOption... malwareScanOptions) {
            return malwareScanOptions(List.of(malwareScanOptions));
        }
        @CustomType.Setter
        public Builder monitorSystemTimeChanges(Boolean monitorSystemTimeChanges) {
            this.monitorSystemTimeChanges = Objects.requireNonNull(monitorSystemTimeChanges);
            return this;
        }
        @CustomType.Setter
        public Builder name(String name) {
            this.name = Objects.requireNonNull(name);
            return this;
        }
        @CustomType.Setter
        public Builder readonlyFilesAndDirectories(List<String> readonlyFilesAndDirectories) {
            this.readonlyFilesAndDirectories = Objects.requireNonNull(readonlyFilesAndDirectories);
            return this;
        }
        public Builder readonlyFilesAndDirectories(String... readonlyFilesAndDirectories) {
            return readonlyFilesAndDirectories(List.of(readonlyFilesAndDirectories));
        }
        @CustomType.Setter
        public Builder reverseShellAllowedIps(List<String> reverseShellAllowedIps) {
            this.reverseShellAllowedIps = Objects.requireNonNull(reverseShellAllowedIps);
            return this;
        }
        public Builder reverseShellAllowedIps(String... reverseShellAllowedIps) {
            return reverseShellAllowedIps(List.of(reverseShellAllowedIps));
        }
        @CustomType.Setter
        public Builder reverseShellAllowedProcesses(List<String> reverseShellAllowedProcesses) {
            this.reverseShellAllowedProcesses = Objects.requireNonNull(reverseShellAllowedProcesses);
            return this;
        }
        public Builder reverseShellAllowedProcesses(String... reverseShellAllowedProcesses) {
            return reverseShellAllowedProcesses(List.of(reverseShellAllowedProcesses));
        }
        @CustomType.Setter
        public Builder scopeExpression(String scopeExpression) {
            this.scopeExpression = Objects.requireNonNull(scopeExpression);
            return this;
        }
        @CustomType.Setter
        public Builder scopeVariables(List<GetContainerRuntimePolicyScopeVariable> scopeVariables) {
            this.scopeVariables = Objects.requireNonNull(scopeVariables);
            return this;
        }
        public Builder scopeVariables(GetContainerRuntimePolicyScopeVariable... scopeVariables) {
            return scopeVariables(List.of(scopeVariables));
        }
        public GetContainerRuntimePolicyResult build() {
            final var o = new GetContainerRuntimePolicyResult();
            o.allowedExecutables = allowedExecutables;
            o.allowedRegistries = allowedRegistries;
            o.applicationScopes = applicationScopes;
            o.auditAllNetworkActivity = auditAllNetworkActivity;
            o.auditAllProcessesActivity = auditAllProcessesActivity;
            o.auditFullCommandArguments = auditFullCommandArguments;
            o.author = author;
            o.blockAccessHostNetwork = blockAccessHostNetwork;
            o.blockAddingCapabilities = blockAddingCapabilities;
            o.blockContainerExec = blockContainerExec;
            o.blockCryptocurrencyMining = blockCryptocurrencyMining;
            o.blockFilelessExec = blockFilelessExec;
            o.blockLowPortBinding = blockLowPortBinding;
            o.blockNonCompliantImages = blockNonCompliantImages;
            o.blockNonCompliantWorkloads = blockNonCompliantWorkloads;
            o.blockNonK8sContainers = blockNonK8sContainers;
            o.blockPrivilegedContainers = blockPrivilegedContainers;
            o.blockReverseShell = blockReverseShell;
            o.blockRootUser = blockRootUser;
            o.blockUnregisteredImages = blockUnregisteredImages;
            o.blockUseIpcNamespace = blockUseIpcNamespace;
            o.blockUsePidNamespace = blockUsePidNamespace;
            o.blockUseUserNamespace = blockUseUserNamespace;
            o.blockUseUtsNamespace = blockUseUtsNamespace;
            o.blockedCapabilities = blockedCapabilities;
            o.blockedExecutables = blockedExecutables;
            o.blockedFiles = blockedFiles;
            o.blockedInboundPorts = blockedInboundPorts;
            o.blockedOutboundPorts = blockedOutboundPorts;
            o.blockedPackages = blockedPackages;
            o.blockedVolumes = blockedVolumes;
            o.containerExecAllowedProcesses = containerExecAllowedProcesses;
            o.description = description;
            o.enableDriftPrevention = enableDriftPrevention;
            o.enableForkGuard = enableForkGuard;
            o.enableIpReputationSecurity = enableIpReputationSecurity;
            o.enablePortScanDetection = enablePortScanDetection;
            o.enabled = enabled;
            o.enforce = enforce;
            o.enforceAfterDays = enforceAfterDays;
            o.exceptionalReadonlyFilesAndDirectories = exceptionalReadonlyFilesAndDirectories;
            o.fileIntegrityMonitorings = fileIntegrityMonitorings;
            o.forkGuardProcessLimit = forkGuardProcessLimit;
            o.id = id;
            o.limitNewPrivileges = limitNewPrivileges;
            o.malwareScanOptions = malwareScanOptions;
            o.monitorSystemTimeChanges = monitorSystemTimeChanges;
            o.name = name;
            o.readonlyFilesAndDirectories = readonlyFilesAndDirectories;
            o.reverseShellAllowedIps = reverseShellAllowedIps;
            o.reverseShellAllowedProcesses = reverseShellAllowedProcesses;
            o.scopeExpression = scopeExpression;
            o.scopeVariables = scopeVariables;
            return o;
        }
    }
}
