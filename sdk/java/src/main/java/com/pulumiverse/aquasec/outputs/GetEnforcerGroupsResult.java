// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumiverse.aquasec.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumiverse.aquasec.outputs.GetEnforcerGroupsCommand;
import com.pulumiverse.aquasec.outputs.GetEnforcerGroupsOrchestrator;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetEnforcerGroupsResult {
    /**
     * @return Selecting this option will allow the KubeEnforcer to block the deployment of container images that have failed any of these Container Runtime Policy controls:\
     * 			* Block Non-Compliant Images\
     * 			* Block Non-Compliant Workloads\
     * 			* Block Unregistered Images\
     * 			This functionality can work only when the KubeEnforcer is deployed in Enforce mode.
     * 
     */
    private Boolean admissionControl;
    /**
     * @return Allow kube enforcer audit.
     * 
     */
    private Boolean allowKubeEnforcerAudit;
    /**
     * @return List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
     * 
     */
    private List<String> allowedApplications;
    /**
     * @return List of label names to allow on the hosts.
     * 
     */
    private List<String> allowedLabels;
    /**
     * @return List of registry names to allow on the hosts.
     * 
     */
    private List<String> allowedRegistries;
    /**
     * @return This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Host Runtime policies.
     * 
     */
    private Boolean antivirusProtection;
    /**
     * @return Aqua server version
     * 
     */
    private String aquaVersion;
    /**
     * @return Agent will send extra audit messages to the server for success operations from inside the container (runtime).
     * 
     */
    private Boolean auditAll;
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected. Select this option if you want Aqua Enterprise to copy the secrets defined above to the Pod Enforcer namespace and container. Otherwise, you can choose to copy these secrets by other means.
     * 
     */
    private Boolean autoCopySecrets;
    /**
     * @return This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will add previously unknown image registries from the cluster to Aqua.
     * 
     */
    private Boolean autoDiscoverConfigureRegistries;
    /**
     * @return When this option is selected, the KubeEnforcer will discover workloads on its cluster.
     * 
     */
    private Boolean autoDiscoveryEnabled;
    /**
     * @return This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will automatically register images running as workloads (and scan the discovered images for security issues).
     * 
     */
    private Boolean autoScanDiscoveredImagesRunningContainers;
    /**
     * @return If `Enabled`, detects suspicious activity in your containers and displays potential security threats in the Incidents and Audits pages.
     * 
     */
    private Boolean behavioralEngine;
    /**
     * @return This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    private Boolean blockAdmissionControl;
    /**
     * @return The installation command.
     * 
     */
    private List<GetEnforcerGroupsCommand> commands;
    /**
     * @return Number of connected enforcers in the enforcer group.
     * 
     */
    private Integer connectedCount;
    /**
     * @return When set to `True` applies Container Runtime Policies, Image Profiles, and Firewall Policies to containers.
     * 
     */
    private Boolean containerActivityProtection;
    /**
     * @return This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Container Runtime policies.
     * 
     */
    private Boolean containerAntivirusProtection;
    /**
     * @return A description for the Aqua Enforcer group.
     * 
     */
    private String description;
    /**
     * @return Number of disconnected enforcers in the enforcer group.
     * 
     */
    private Integer disconnectedCount;
    /**
     * @return Whether the enforce mode is enabled on the Enforcers.
     * 
     */
    private Boolean enforce;
    /**
     * @return The specific Aqua Enforcer product image (with image tag) to be deployed.
     * 
     */
    private String enforcerImageName;
    /**
     * @return Select Enabled to send activity logs in your containers to the Aqua Server for forensics purposes.
     * 
     */
    private @Nullable Boolean forensics;
    /**
     * @return Gateway Address
     * 
     */
    private String gatewayAddress;
    /**
     * @return Gateway Name
     * 
     */
    private String gatewayName;
    /**
     * @return List of Aqua gateway IDs for the Enforcers.
     * 
     */
    private List<String> gateways;
    /**
     * @return The ID of the Enforcer group.
     * 
     */
    private String groupId;
    /**
     * @return Number of high vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    private Integer highVulns;
    /**
     * @return When set to `True` enables host scanning and respective Host Assurance controls.
     * 
     */
    private Boolean hostAssurance;
    /**
     * @return When set to `True` enables these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    private Boolean hostBehavioralEngine;
    /**
     * @return Select Enabled to send activity logs in your host to the Aqua Server for forensics purposes.
     * 
     */
    private @Nullable Boolean hostForensics;
    /**
     * @return When set to `True` applies Firewall Policies to hosts, and allows recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information
     * 
     */
    private Boolean hostNetworkProtection;
    /**
     * @return The OS type for the host
     * 
     */
    private String hostOs;
    /**
     * @return When set to `True` enables all Host Runtime Policy controls except for `OS Users and Groups Allowed` and `OS Users and Groups Blocked`.
     * 
     */
    private Boolean hostProtection;
    /**
     * @return When set to `True` enables these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    private Boolean hostUserProtection;
    /**
     * @return Number of enforcers in the enforcer group.
     * 
     */
    private Integer hostsCount;
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    private String id;
    /**
     * @return When Set to `True` enables selected controls: Container Runtime Policy (`Block Non-Compliant Images`, `Block Unregistered Images`, and `Registries Allowed`) and Default Image Assurance Policy (`Images Blocked`).
     * 
     */
    private Boolean imageAssurance;
    /**
     * @return Enforcer install command
     * 
     */
    private String installCommand;
    /**
     * @return See https://docs.aquasec.com/docs/securing-kubernetes-applications#section-configuration-hardening, The KubeEnforcer can deploy the Aqua Security kube-bench open-source product to perform Kubernetes CIS benchmark testing of nodes.
     * 			This field specifies the path and file name of the kube-bench product image for the KubeEnforcer to deploy; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    private String kubeBenchImageName;
    /**
     * @return The last date and time the batch token was updated in UNIX time.
     * 
     */
    private Integer lastUpdate;
    /**
     * @return Name for the batch install record.
     * 
     */
    private String logicalName;
    /**
     * @return Number of low vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    private Integer lowVulns;
    /**
     * @return Number of medium vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    private Integer medVulns;
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected.
     * 
     */
    private String microEnforcerCertsSecretsName;
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected. This field specifies the path and file name of the KubeEnforcer product image to be deployed; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    private String microEnforcerImageName;
    /**
     * @return This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    private Boolean microEnforcerInjection;
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected.
     * 
     */
    private String microEnforcerSecretsName;
    /**
     * @return Number of negligible vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    private Integer negVulns;
    /**
     * @return When set to `True` applies Firewall Policies to containers, and allows recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information.
     * 
     */
    private Boolean networkProtection;
    /**
     * @return The orchestrator for which you are creating the Enforcer group.
     * 
     */
    private List<GetEnforcerGroupsOrchestrator> orchestrators;
    /**
     * @return pas deployment link
     * 
     */
    private String pasDeploymentLink;
    /**
     * @return Permission Action
     * 
     */
    private String permission;
    /**
     * @return When set to `True` allows Enforcers to be discovered in the Risk Explorer.
     * 
     */
    private Boolean riskExplorerAutoDiscovery;
    /**
     * @return Function Runtime Policy that will applay on the nano enforcer.
     * 
     */
    private String runtimePolicyName;
    /**
     * @return The container runtime environment.
     * 
     */
    private String runtimeType;
    /**
     * @return When set to `True` configures Enforcers to discover local host images. Discovered images will be listed under Images &gt; Host Images, as well as under Infrastructure (in the Images tab for applicable hosts).
     * 
     */
    private Boolean syncHostImages;
    /**
     * @return When set to `True` allows profiling and monitoring system calls made by running containers.
     * 
     */
    private Boolean syscallEnabled;
    /**
     * @return The batch install token.
     * 
     */
    private String token;
    /**
     * @return Enforcer Type.
     * 
     */
    private String type;
    /**
     * @return When set to `True` applies User Access Control Policies to containers. Note that Aqua Enforcers must be deployed with the AQUA*RUNC*INTERCEPTION environment variable set to 0 in order to use User Access Control Policies.
     * 
     */
    private Boolean userAccessControl;

    private GetEnforcerGroupsResult() {}
    /**
     * @return Selecting this option will allow the KubeEnforcer to block the deployment of container images that have failed any of these Container Runtime Policy controls:\
     * 			* Block Non-Compliant Images\
     * 			* Block Non-Compliant Workloads\
     * 			* Block Unregistered Images\
     * 			This functionality can work only when the KubeEnforcer is deployed in Enforce mode.
     * 
     */
    public Boolean admissionControl() {
        return this.admissionControl;
    }
    /**
     * @return Allow kube enforcer audit.
     * 
     */
    public Boolean allowKubeEnforcerAudit() {
        return this.allowKubeEnforcerAudit;
    }
    /**
     * @return List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
     * 
     */
    public List<String> allowedApplications() {
        return this.allowedApplications;
    }
    /**
     * @return List of label names to allow on the hosts.
     * 
     */
    public List<String> allowedLabels() {
        return this.allowedLabels;
    }
    /**
     * @return List of registry names to allow on the hosts.
     * 
     */
    public List<String> allowedRegistries() {
        return this.allowedRegistries;
    }
    /**
     * @return This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Host Runtime policies.
     * 
     */
    public Boolean antivirusProtection() {
        return this.antivirusProtection;
    }
    /**
     * @return Aqua server version
     * 
     */
    public String aquaVersion() {
        return this.aquaVersion;
    }
    /**
     * @return Agent will send extra audit messages to the server for success operations from inside the container (runtime).
     * 
     */
    public Boolean auditAll() {
        return this.auditAll;
    }
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected. Select this option if you want Aqua Enterprise to copy the secrets defined above to the Pod Enforcer namespace and container. Otherwise, you can choose to copy these secrets by other means.
     * 
     */
    public Boolean autoCopySecrets() {
        return this.autoCopySecrets;
    }
    /**
     * @return This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will add previously unknown image registries from the cluster to Aqua.
     * 
     */
    public Boolean autoDiscoverConfigureRegistries() {
        return this.autoDiscoverConfigureRegistries;
    }
    /**
     * @return When this option is selected, the KubeEnforcer will discover workloads on its cluster.
     * 
     */
    public Boolean autoDiscoveryEnabled() {
        return this.autoDiscoveryEnabled;
    }
    /**
     * @return This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will automatically register images running as workloads (and scan the discovered images for security issues).
     * 
     */
    public Boolean autoScanDiscoveredImagesRunningContainers() {
        return this.autoScanDiscoveredImagesRunningContainers;
    }
    /**
     * @return If `Enabled`, detects suspicious activity in your containers and displays potential security threats in the Incidents and Audits pages.
     * 
     */
    public Boolean behavioralEngine() {
        return this.behavioralEngine;
    }
    /**
     * @return This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    public Boolean blockAdmissionControl() {
        return this.blockAdmissionControl;
    }
    /**
     * @return The installation command.
     * 
     */
    public List<GetEnforcerGroupsCommand> commands() {
        return this.commands;
    }
    /**
     * @return Number of connected enforcers in the enforcer group.
     * 
     */
    public Integer connectedCount() {
        return this.connectedCount;
    }
    /**
     * @return When set to `True` applies Container Runtime Policies, Image Profiles, and Firewall Policies to containers.
     * 
     */
    public Boolean containerActivityProtection() {
        return this.containerActivityProtection;
    }
    /**
     * @return This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Container Runtime policies.
     * 
     */
    public Boolean containerAntivirusProtection() {
        return this.containerAntivirusProtection;
    }
    /**
     * @return A description for the Aqua Enforcer group.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return Number of disconnected enforcers in the enforcer group.
     * 
     */
    public Integer disconnectedCount() {
        return this.disconnectedCount;
    }
    /**
     * @return Whether the enforce mode is enabled on the Enforcers.
     * 
     */
    public Boolean enforce() {
        return this.enforce;
    }
    /**
     * @return The specific Aqua Enforcer product image (with image tag) to be deployed.
     * 
     */
    public String enforcerImageName() {
        return this.enforcerImageName;
    }
    /**
     * @return Select Enabled to send activity logs in your containers to the Aqua Server for forensics purposes.
     * 
     */
    public Optional<Boolean> forensics() {
        return Optional.ofNullable(this.forensics);
    }
    /**
     * @return Gateway Address
     * 
     */
    public String gatewayAddress() {
        return this.gatewayAddress;
    }
    /**
     * @return Gateway Name
     * 
     */
    public String gatewayName() {
        return this.gatewayName;
    }
    /**
     * @return List of Aqua gateway IDs for the Enforcers.
     * 
     */
    public List<String> gateways() {
        return this.gateways;
    }
    /**
     * @return The ID of the Enforcer group.
     * 
     */
    public String groupId() {
        return this.groupId;
    }
    /**
     * @return Number of high vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Integer highVulns() {
        return this.highVulns;
    }
    /**
     * @return When set to `True` enables host scanning and respective Host Assurance controls.
     * 
     */
    public Boolean hostAssurance() {
        return this.hostAssurance;
    }
    /**
     * @return When set to `True` enables these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    public Boolean hostBehavioralEngine() {
        return this.hostBehavioralEngine;
    }
    /**
     * @return Select Enabled to send activity logs in your host to the Aqua Server for forensics purposes.
     * 
     */
    public Optional<Boolean> hostForensics() {
        return Optional.ofNullable(this.hostForensics);
    }
    /**
     * @return When set to `True` applies Firewall Policies to hosts, and allows recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information
     * 
     */
    public Boolean hostNetworkProtection() {
        return this.hostNetworkProtection;
    }
    /**
     * @return The OS type for the host
     * 
     */
    public String hostOs() {
        return this.hostOs;
    }
    /**
     * @return When set to `True` enables all Host Runtime Policy controls except for `OS Users and Groups Allowed` and `OS Users and Groups Blocked`.
     * 
     */
    public Boolean hostProtection() {
        return this.hostProtection;
    }
    /**
     * @return When set to `True` enables these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    public Boolean hostUserProtection() {
        return this.hostUserProtection;
    }
    /**
     * @return Number of enforcers in the enforcer group.
     * 
     */
    public Integer hostsCount() {
        return this.hostsCount;
    }
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return When Set to `True` enables selected controls: Container Runtime Policy (`Block Non-Compliant Images`, `Block Unregistered Images`, and `Registries Allowed`) and Default Image Assurance Policy (`Images Blocked`).
     * 
     */
    public Boolean imageAssurance() {
        return this.imageAssurance;
    }
    /**
     * @return Enforcer install command
     * 
     */
    public String installCommand() {
        return this.installCommand;
    }
    /**
     * @return See https://docs.aquasec.com/docs/securing-kubernetes-applications#section-configuration-hardening, The KubeEnforcer can deploy the Aqua Security kube-bench open-source product to perform Kubernetes CIS benchmark testing of nodes.
     * 			This field specifies the path and file name of the kube-bench product image for the KubeEnforcer to deploy; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    public String kubeBenchImageName() {
        return this.kubeBenchImageName;
    }
    /**
     * @return The last date and time the batch token was updated in UNIX time.
     * 
     */
    public Integer lastUpdate() {
        return this.lastUpdate;
    }
    /**
     * @return Name for the batch install record.
     * 
     */
    public String logicalName() {
        return this.logicalName;
    }
    /**
     * @return Number of low vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Integer lowVulns() {
        return this.lowVulns;
    }
    /**
     * @return Number of medium vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Integer medVulns() {
        return this.medVulns;
    }
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected.
     * 
     */
    public String microEnforcerCertsSecretsName() {
        return this.microEnforcerCertsSecretsName;
    }
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected. This field specifies the path and file name of the KubeEnforcer product image to be deployed; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    public String microEnforcerImageName() {
        return this.microEnforcerImageName;
    }
    /**
     * @return This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    public Boolean microEnforcerInjection() {
        return this.microEnforcerInjection;
    }
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected.
     * 
     */
    public String microEnforcerSecretsName() {
        return this.microEnforcerSecretsName;
    }
    /**
     * @return Number of negligible vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Integer negVulns() {
        return this.negVulns;
    }
    /**
     * @return When set to `True` applies Firewall Policies to containers, and allows recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information.
     * 
     */
    public Boolean networkProtection() {
        return this.networkProtection;
    }
    /**
     * @return The orchestrator for which you are creating the Enforcer group.
     * 
     */
    public List<GetEnforcerGroupsOrchestrator> orchestrators() {
        return this.orchestrators;
    }
    /**
     * @return pas deployment link
     * 
     */
    public String pasDeploymentLink() {
        return this.pasDeploymentLink;
    }
    /**
     * @return Permission Action
     * 
     */
    public String permission() {
        return this.permission;
    }
    /**
     * @return When set to `True` allows Enforcers to be discovered in the Risk Explorer.
     * 
     */
    public Boolean riskExplorerAutoDiscovery() {
        return this.riskExplorerAutoDiscovery;
    }
    /**
     * @return Function Runtime Policy that will applay on the nano enforcer.
     * 
     */
    public String runtimePolicyName() {
        return this.runtimePolicyName;
    }
    /**
     * @return The container runtime environment.
     * 
     */
    public String runtimeType() {
        return this.runtimeType;
    }
    /**
     * @return When set to `True` configures Enforcers to discover local host images. Discovered images will be listed under Images &gt; Host Images, as well as under Infrastructure (in the Images tab for applicable hosts).
     * 
     */
    public Boolean syncHostImages() {
        return this.syncHostImages;
    }
    /**
     * @return When set to `True` allows profiling and monitoring system calls made by running containers.
     * 
     */
    public Boolean syscallEnabled() {
        return this.syscallEnabled;
    }
    /**
     * @return The batch install token.
     * 
     */
    public String token() {
        return this.token;
    }
    /**
     * @return Enforcer Type.
     * 
     */
    public String type() {
        return this.type;
    }
    /**
     * @return When set to `True` applies User Access Control Policies to containers. Note that Aqua Enforcers must be deployed with the AQUA*RUNC*INTERCEPTION environment variable set to 0 in order to use User Access Control Policies.
     * 
     */
    public Boolean userAccessControl() {
        return this.userAccessControl;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetEnforcerGroupsResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Boolean admissionControl;
        private Boolean allowKubeEnforcerAudit;
        private List<String> allowedApplications;
        private List<String> allowedLabels;
        private List<String> allowedRegistries;
        private Boolean antivirusProtection;
        private String aquaVersion;
        private Boolean auditAll;
        private Boolean autoCopySecrets;
        private Boolean autoDiscoverConfigureRegistries;
        private Boolean autoDiscoveryEnabled;
        private Boolean autoScanDiscoveredImagesRunningContainers;
        private Boolean behavioralEngine;
        private Boolean blockAdmissionControl;
        private List<GetEnforcerGroupsCommand> commands;
        private Integer connectedCount;
        private Boolean containerActivityProtection;
        private Boolean containerAntivirusProtection;
        private String description;
        private Integer disconnectedCount;
        private Boolean enforce;
        private String enforcerImageName;
        private @Nullable Boolean forensics;
        private String gatewayAddress;
        private String gatewayName;
        private List<String> gateways;
        private String groupId;
        private Integer highVulns;
        private Boolean hostAssurance;
        private Boolean hostBehavioralEngine;
        private @Nullable Boolean hostForensics;
        private Boolean hostNetworkProtection;
        private String hostOs;
        private Boolean hostProtection;
        private Boolean hostUserProtection;
        private Integer hostsCount;
        private String id;
        private Boolean imageAssurance;
        private String installCommand;
        private String kubeBenchImageName;
        private Integer lastUpdate;
        private String logicalName;
        private Integer lowVulns;
        private Integer medVulns;
        private String microEnforcerCertsSecretsName;
        private String microEnforcerImageName;
        private Boolean microEnforcerInjection;
        private String microEnforcerSecretsName;
        private Integer negVulns;
        private Boolean networkProtection;
        private List<GetEnforcerGroupsOrchestrator> orchestrators;
        private String pasDeploymentLink;
        private String permission;
        private Boolean riskExplorerAutoDiscovery;
        private String runtimePolicyName;
        private String runtimeType;
        private Boolean syncHostImages;
        private Boolean syscallEnabled;
        private String token;
        private String type;
        private Boolean userAccessControl;
        public Builder() {}
        public Builder(GetEnforcerGroupsResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.admissionControl = defaults.admissionControl;
    	      this.allowKubeEnforcerAudit = defaults.allowKubeEnforcerAudit;
    	      this.allowedApplications = defaults.allowedApplications;
    	      this.allowedLabels = defaults.allowedLabels;
    	      this.allowedRegistries = defaults.allowedRegistries;
    	      this.antivirusProtection = defaults.antivirusProtection;
    	      this.aquaVersion = defaults.aquaVersion;
    	      this.auditAll = defaults.auditAll;
    	      this.autoCopySecrets = defaults.autoCopySecrets;
    	      this.autoDiscoverConfigureRegistries = defaults.autoDiscoverConfigureRegistries;
    	      this.autoDiscoveryEnabled = defaults.autoDiscoveryEnabled;
    	      this.autoScanDiscoveredImagesRunningContainers = defaults.autoScanDiscoveredImagesRunningContainers;
    	      this.behavioralEngine = defaults.behavioralEngine;
    	      this.blockAdmissionControl = defaults.blockAdmissionControl;
    	      this.commands = defaults.commands;
    	      this.connectedCount = defaults.connectedCount;
    	      this.containerActivityProtection = defaults.containerActivityProtection;
    	      this.containerAntivirusProtection = defaults.containerAntivirusProtection;
    	      this.description = defaults.description;
    	      this.disconnectedCount = defaults.disconnectedCount;
    	      this.enforce = defaults.enforce;
    	      this.enforcerImageName = defaults.enforcerImageName;
    	      this.forensics = defaults.forensics;
    	      this.gatewayAddress = defaults.gatewayAddress;
    	      this.gatewayName = defaults.gatewayName;
    	      this.gateways = defaults.gateways;
    	      this.groupId = defaults.groupId;
    	      this.highVulns = defaults.highVulns;
    	      this.hostAssurance = defaults.hostAssurance;
    	      this.hostBehavioralEngine = defaults.hostBehavioralEngine;
    	      this.hostForensics = defaults.hostForensics;
    	      this.hostNetworkProtection = defaults.hostNetworkProtection;
    	      this.hostOs = defaults.hostOs;
    	      this.hostProtection = defaults.hostProtection;
    	      this.hostUserProtection = defaults.hostUserProtection;
    	      this.hostsCount = defaults.hostsCount;
    	      this.id = defaults.id;
    	      this.imageAssurance = defaults.imageAssurance;
    	      this.installCommand = defaults.installCommand;
    	      this.kubeBenchImageName = defaults.kubeBenchImageName;
    	      this.lastUpdate = defaults.lastUpdate;
    	      this.logicalName = defaults.logicalName;
    	      this.lowVulns = defaults.lowVulns;
    	      this.medVulns = defaults.medVulns;
    	      this.microEnforcerCertsSecretsName = defaults.microEnforcerCertsSecretsName;
    	      this.microEnforcerImageName = defaults.microEnforcerImageName;
    	      this.microEnforcerInjection = defaults.microEnforcerInjection;
    	      this.microEnforcerSecretsName = defaults.microEnforcerSecretsName;
    	      this.negVulns = defaults.negVulns;
    	      this.networkProtection = defaults.networkProtection;
    	      this.orchestrators = defaults.orchestrators;
    	      this.pasDeploymentLink = defaults.pasDeploymentLink;
    	      this.permission = defaults.permission;
    	      this.riskExplorerAutoDiscovery = defaults.riskExplorerAutoDiscovery;
    	      this.runtimePolicyName = defaults.runtimePolicyName;
    	      this.runtimeType = defaults.runtimeType;
    	      this.syncHostImages = defaults.syncHostImages;
    	      this.syscallEnabled = defaults.syscallEnabled;
    	      this.token = defaults.token;
    	      this.type = defaults.type;
    	      this.userAccessControl = defaults.userAccessControl;
        }

        @CustomType.Setter
        public Builder admissionControl(Boolean admissionControl) {
            this.admissionControl = Objects.requireNonNull(admissionControl);
            return this;
        }
        @CustomType.Setter
        public Builder allowKubeEnforcerAudit(Boolean allowKubeEnforcerAudit) {
            this.allowKubeEnforcerAudit = Objects.requireNonNull(allowKubeEnforcerAudit);
            return this;
        }
        @CustomType.Setter
        public Builder allowedApplications(List<String> allowedApplications) {
            this.allowedApplications = Objects.requireNonNull(allowedApplications);
            return this;
        }
        public Builder allowedApplications(String... allowedApplications) {
            return allowedApplications(List.of(allowedApplications));
        }
        @CustomType.Setter
        public Builder allowedLabels(List<String> allowedLabels) {
            this.allowedLabels = Objects.requireNonNull(allowedLabels);
            return this;
        }
        public Builder allowedLabels(String... allowedLabels) {
            return allowedLabels(List.of(allowedLabels));
        }
        @CustomType.Setter
        public Builder allowedRegistries(List<String> allowedRegistries) {
            this.allowedRegistries = Objects.requireNonNull(allowedRegistries);
            return this;
        }
        public Builder allowedRegistries(String... allowedRegistries) {
            return allowedRegistries(List.of(allowedRegistries));
        }
        @CustomType.Setter
        public Builder antivirusProtection(Boolean antivirusProtection) {
            this.antivirusProtection = Objects.requireNonNull(antivirusProtection);
            return this;
        }
        @CustomType.Setter
        public Builder aquaVersion(String aquaVersion) {
            this.aquaVersion = Objects.requireNonNull(aquaVersion);
            return this;
        }
        @CustomType.Setter
        public Builder auditAll(Boolean auditAll) {
            this.auditAll = Objects.requireNonNull(auditAll);
            return this;
        }
        @CustomType.Setter
        public Builder autoCopySecrets(Boolean autoCopySecrets) {
            this.autoCopySecrets = Objects.requireNonNull(autoCopySecrets);
            return this;
        }
        @CustomType.Setter
        public Builder autoDiscoverConfigureRegistries(Boolean autoDiscoverConfigureRegistries) {
            this.autoDiscoverConfigureRegistries = Objects.requireNonNull(autoDiscoverConfigureRegistries);
            return this;
        }
        @CustomType.Setter
        public Builder autoDiscoveryEnabled(Boolean autoDiscoveryEnabled) {
            this.autoDiscoveryEnabled = Objects.requireNonNull(autoDiscoveryEnabled);
            return this;
        }
        @CustomType.Setter
        public Builder autoScanDiscoveredImagesRunningContainers(Boolean autoScanDiscoveredImagesRunningContainers) {
            this.autoScanDiscoveredImagesRunningContainers = Objects.requireNonNull(autoScanDiscoveredImagesRunningContainers);
            return this;
        }
        @CustomType.Setter
        public Builder behavioralEngine(Boolean behavioralEngine) {
            this.behavioralEngine = Objects.requireNonNull(behavioralEngine);
            return this;
        }
        @CustomType.Setter
        public Builder blockAdmissionControl(Boolean blockAdmissionControl) {
            this.blockAdmissionControl = Objects.requireNonNull(blockAdmissionControl);
            return this;
        }
        @CustomType.Setter
        public Builder commands(List<GetEnforcerGroupsCommand> commands) {
            this.commands = Objects.requireNonNull(commands);
            return this;
        }
        public Builder commands(GetEnforcerGroupsCommand... commands) {
            return commands(List.of(commands));
        }
        @CustomType.Setter
        public Builder connectedCount(Integer connectedCount) {
            this.connectedCount = Objects.requireNonNull(connectedCount);
            return this;
        }
        @CustomType.Setter
        public Builder containerActivityProtection(Boolean containerActivityProtection) {
            this.containerActivityProtection = Objects.requireNonNull(containerActivityProtection);
            return this;
        }
        @CustomType.Setter
        public Builder containerAntivirusProtection(Boolean containerAntivirusProtection) {
            this.containerAntivirusProtection = Objects.requireNonNull(containerAntivirusProtection);
            return this;
        }
        @CustomType.Setter
        public Builder description(String description) {
            this.description = Objects.requireNonNull(description);
            return this;
        }
        @CustomType.Setter
        public Builder disconnectedCount(Integer disconnectedCount) {
            this.disconnectedCount = Objects.requireNonNull(disconnectedCount);
            return this;
        }
        @CustomType.Setter
        public Builder enforce(Boolean enforce) {
            this.enforce = Objects.requireNonNull(enforce);
            return this;
        }
        @CustomType.Setter
        public Builder enforcerImageName(String enforcerImageName) {
            this.enforcerImageName = Objects.requireNonNull(enforcerImageName);
            return this;
        }
        @CustomType.Setter
        public Builder forensics(@Nullable Boolean forensics) {
            this.forensics = forensics;
            return this;
        }
        @CustomType.Setter
        public Builder gatewayAddress(String gatewayAddress) {
            this.gatewayAddress = Objects.requireNonNull(gatewayAddress);
            return this;
        }
        @CustomType.Setter
        public Builder gatewayName(String gatewayName) {
            this.gatewayName = Objects.requireNonNull(gatewayName);
            return this;
        }
        @CustomType.Setter
        public Builder gateways(List<String> gateways) {
            this.gateways = Objects.requireNonNull(gateways);
            return this;
        }
        public Builder gateways(String... gateways) {
            return gateways(List.of(gateways));
        }
        @CustomType.Setter
        public Builder groupId(String groupId) {
            this.groupId = Objects.requireNonNull(groupId);
            return this;
        }
        @CustomType.Setter
        public Builder highVulns(Integer highVulns) {
            this.highVulns = Objects.requireNonNull(highVulns);
            return this;
        }
        @CustomType.Setter
        public Builder hostAssurance(Boolean hostAssurance) {
            this.hostAssurance = Objects.requireNonNull(hostAssurance);
            return this;
        }
        @CustomType.Setter
        public Builder hostBehavioralEngine(Boolean hostBehavioralEngine) {
            this.hostBehavioralEngine = Objects.requireNonNull(hostBehavioralEngine);
            return this;
        }
        @CustomType.Setter
        public Builder hostForensics(@Nullable Boolean hostForensics) {
            this.hostForensics = hostForensics;
            return this;
        }
        @CustomType.Setter
        public Builder hostNetworkProtection(Boolean hostNetworkProtection) {
            this.hostNetworkProtection = Objects.requireNonNull(hostNetworkProtection);
            return this;
        }
        @CustomType.Setter
        public Builder hostOs(String hostOs) {
            this.hostOs = Objects.requireNonNull(hostOs);
            return this;
        }
        @CustomType.Setter
        public Builder hostProtection(Boolean hostProtection) {
            this.hostProtection = Objects.requireNonNull(hostProtection);
            return this;
        }
        @CustomType.Setter
        public Builder hostUserProtection(Boolean hostUserProtection) {
            this.hostUserProtection = Objects.requireNonNull(hostUserProtection);
            return this;
        }
        @CustomType.Setter
        public Builder hostsCount(Integer hostsCount) {
            this.hostsCount = Objects.requireNonNull(hostsCount);
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            this.id = Objects.requireNonNull(id);
            return this;
        }
        @CustomType.Setter
        public Builder imageAssurance(Boolean imageAssurance) {
            this.imageAssurance = Objects.requireNonNull(imageAssurance);
            return this;
        }
        @CustomType.Setter
        public Builder installCommand(String installCommand) {
            this.installCommand = Objects.requireNonNull(installCommand);
            return this;
        }
        @CustomType.Setter
        public Builder kubeBenchImageName(String kubeBenchImageName) {
            this.kubeBenchImageName = Objects.requireNonNull(kubeBenchImageName);
            return this;
        }
        @CustomType.Setter
        public Builder lastUpdate(Integer lastUpdate) {
            this.lastUpdate = Objects.requireNonNull(lastUpdate);
            return this;
        }
        @CustomType.Setter
        public Builder logicalName(String logicalName) {
            this.logicalName = Objects.requireNonNull(logicalName);
            return this;
        }
        @CustomType.Setter
        public Builder lowVulns(Integer lowVulns) {
            this.lowVulns = Objects.requireNonNull(lowVulns);
            return this;
        }
        @CustomType.Setter
        public Builder medVulns(Integer medVulns) {
            this.medVulns = Objects.requireNonNull(medVulns);
            return this;
        }
        @CustomType.Setter
        public Builder microEnforcerCertsSecretsName(String microEnforcerCertsSecretsName) {
            this.microEnforcerCertsSecretsName = Objects.requireNonNull(microEnforcerCertsSecretsName);
            return this;
        }
        @CustomType.Setter
        public Builder microEnforcerImageName(String microEnforcerImageName) {
            this.microEnforcerImageName = Objects.requireNonNull(microEnforcerImageName);
            return this;
        }
        @CustomType.Setter
        public Builder microEnforcerInjection(Boolean microEnforcerInjection) {
            this.microEnforcerInjection = Objects.requireNonNull(microEnforcerInjection);
            return this;
        }
        @CustomType.Setter
        public Builder microEnforcerSecretsName(String microEnforcerSecretsName) {
            this.microEnforcerSecretsName = Objects.requireNonNull(microEnforcerSecretsName);
            return this;
        }
        @CustomType.Setter
        public Builder negVulns(Integer negVulns) {
            this.negVulns = Objects.requireNonNull(negVulns);
            return this;
        }
        @CustomType.Setter
        public Builder networkProtection(Boolean networkProtection) {
            this.networkProtection = Objects.requireNonNull(networkProtection);
            return this;
        }
        @CustomType.Setter
        public Builder orchestrators(List<GetEnforcerGroupsOrchestrator> orchestrators) {
            this.orchestrators = Objects.requireNonNull(orchestrators);
            return this;
        }
        public Builder orchestrators(GetEnforcerGroupsOrchestrator... orchestrators) {
            return orchestrators(List.of(orchestrators));
        }
        @CustomType.Setter
        public Builder pasDeploymentLink(String pasDeploymentLink) {
            this.pasDeploymentLink = Objects.requireNonNull(pasDeploymentLink);
            return this;
        }
        @CustomType.Setter
        public Builder permission(String permission) {
            this.permission = Objects.requireNonNull(permission);
            return this;
        }
        @CustomType.Setter
        public Builder riskExplorerAutoDiscovery(Boolean riskExplorerAutoDiscovery) {
            this.riskExplorerAutoDiscovery = Objects.requireNonNull(riskExplorerAutoDiscovery);
            return this;
        }
        @CustomType.Setter
        public Builder runtimePolicyName(String runtimePolicyName) {
            this.runtimePolicyName = Objects.requireNonNull(runtimePolicyName);
            return this;
        }
        @CustomType.Setter
        public Builder runtimeType(String runtimeType) {
            this.runtimeType = Objects.requireNonNull(runtimeType);
            return this;
        }
        @CustomType.Setter
        public Builder syncHostImages(Boolean syncHostImages) {
            this.syncHostImages = Objects.requireNonNull(syncHostImages);
            return this;
        }
        @CustomType.Setter
        public Builder syscallEnabled(Boolean syscallEnabled) {
            this.syscallEnabled = Objects.requireNonNull(syscallEnabled);
            return this;
        }
        @CustomType.Setter
        public Builder token(String token) {
            this.token = Objects.requireNonNull(token);
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            this.type = Objects.requireNonNull(type);
            return this;
        }
        @CustomType.Setter
        public Builder userAccessControl(Boolean userAccessControl) {
            this.userAccessControl = Objects.requireNonNull(userAccessControl);
            return this;
        }
        public GetEnforcerGroupsResult build() {
            final var o = new GetEnforcerGroupsResult();
            o.admissionControl = admissionControl;
            o.allowKubeEnforcerAudit = allowKubeEnforcerAudit;
            o.allowedApplications = allowedApplications;
            o.allowedLabels = allowedLabels;
            o.allowedRegistries = allowedRegistries;
            o.antivirusProtection = antivirusProtection;
            o.aquaVersion = aquaVersion;
            o.auditAll = auditAll;
            o.autoCopySecrets = autoCopySecrets;
            o.autoDiscoverConfigureRegistries = autoDiscoverConfigureRegistries;
            o.autoDiscoveryEnabled = autoDiscoveryEnabled;
            o.autoScanDiscoveredImagesRunningContainers = autoScanDiscoveredImagesRunningContainers;
            o.behavioralEngine = behavioralEngine;
            o.blockAdmissionControl = blockAdmissionControl;
            o.commands = commands;
            o.connectedCount = connectedCount;
            o.containerActivityProtection = containerActivityProtection;
            o.containerAntivirusProtection = containerAntivirusProtection;
            o.description = description;
            o.disconnectedCount = disconnectedCount;
            o.enforce = enforce;
            o.enforcerImageName = enforcerImageName;
            o.forensics = forensics;
            o.gatewayAddress = gatewayAddress;
            o.gatewayName = gatewayName;
            o.gateways = gateways;
            o.groupId = groupId;
            o.highVulns = highVulns;
            o.hostAssurance = hostAssurance;
            o.hostBehavioralEngine = hostBehavioralEngine;
            o.hostForensics = hostForensics;
            o.hostNetworkProtection = hostNetworkProtection;
            o.hostOs = hostOs;
            o.hostProtection = hostProtection;
            o.hostUserProtection = hostUserProtection;
            o.hostsCount = hostsCount;
            o.id = id;
            o.imageAssurance = imageAssurance;
            o.installCommand = installCommand;
            o.kubeBenchImageName = kubeBenchImageName;
            o.lastUpdate = lastUpdate;
            o.logicalName = logicalName;
            o.lowVulns = lowVulns;
            o.medVulns = medVulns;
            o.microEnforcerCertsSecretsName = microEnforcerCertsSecretsName;
            o.microEnforcerImageName = microEnforcerImageName;
            o.microEnforcerInjection = microEnforcerInjection;
            o.microEnforcerSecretsName = microEnforcerSecretsName;
            o.negVulns = negVulns;
            o.networkProtection = networkProtection;
            o.orchestrators = orchestrators;
            o.pasDeploymentLink = pasDeploymentLink;
            o.permission = permission;
            o.riskExplorerAutoDiscovery = riskExplorerAutoDiscovery;
            o.runtimePolicyName = runtimePolicyName;
            o.runtimeType = runtimeType;
            o.syncHostImages = syncHostImages;
            o.syscallEnabled = syscallEnabled;
            o.token = token;
            o.type = type;
            o.userAccessControl = userAccessControl;
            return o;
        }
    }
}
