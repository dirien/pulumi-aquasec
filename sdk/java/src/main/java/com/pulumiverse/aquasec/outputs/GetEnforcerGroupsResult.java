// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumiverse.aquasec.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumiverse.aquasec.outputs.GetEnforcerGroupsCommand;
import com.pulumiverse.aquasec.outputs.GetEnforcerGroupsOrchestrator;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetEnforcerGroupsResult {
    /**
     * @return Selecting this option will allow the KubeEnforcer to block the deployment of container images that have failed any of these Container Runtime Policy controls:\
     * 			* Block Non-Compliant Images\
     * 			* Block Non-Compliant Workloads\
     * 			* Block Unregistered Images\
     * 			This functionality can work only when the KubeEnforcer is deployed in Enforce mode.
     * 
     */
    private final Boolean admissionControl;
    /**
     * @return Allow kube enforcer audit.
     * 
     */
    private final Boolean allowKubeEnforcerAudit;
    /**
     * @return List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
     * 
     */
    private final List<String> allowedApplications;
    /**
     * @return List of label names to allow on the hosts.
     * 
     */
    private final List<String> allowedLabels;
    /**
     * @return List of registry names to allow on the hosts.
     * 
     */
    private final List<String> allowedRegistries;
    /**
     * @return This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Host Runtime policies.
     * 
     */
    private final Boolean antivirusProtection;
    /**
     * @return Aqua server version
     * 
     */
    private final String aquaVersion;
    /**
     * @return Agent will send extra audit messages to the server for success operations from inside the container (runtime).
     * 
     */
    private final Boolean auditAll;
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected. Select this option if you want Aqua Enterprise to copy the secrets defined above to the Pod Enforcer namespace and container. Otherwise, you can choose to copy these secrets by other means.
     * 
     */
    private final Boolean autoCopySecrets;
    /**
     * @return This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will add previously unknown image registries from the cluster to Aqua.
     * 
     */
    private final Boolean autoDiscoverConfigureRegistries;
    /**
     * @return When this option is selected, the KubeEnforcer will discover workloads on its cluster.
     * 
     */
    private final Boolean autoDiscoveryEnabled;
    /**
     * @return This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will automatically register images running as workloads (and scan the discovered images for security issues).
     * 
     */
    private final Boolean autoScanDiscoveredImagesRunningContainers;
    /**
     * @return If `Enabled`, detects suspicious activity in your containers and displays potential security threats in the Incidents and Audits pages.
     * 
     */
    private final Boolean behavioralEngine;
    /**
     * @return This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    private final Boolean blockAdmissionControl;
    /**
     * @return The installation command.
     * 
     */
    private final List<GetEnforcerGroupsCommand> commands;
    /**
     * @return Number of connected enforcers in the enforcer group.
     * 
     */
    private final Integer connectedCount;
    /**
     * @return When set to `True` applies Container Runtime Policies, Image Profiles, and Firewall Policies to containers.
     * 
     */
    private final Boolean containerActivityProtection;
    /**
     * @return This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Container Runtime policies.
     * 
     */
    private final Boolean containerAntivirusProtection;
    /**
     * @return A description for the Aqua Enforcer group.
     * 
     */
    private final String description;
    /**
     * @return Number of disconnected enforcers in the enforcer group.
     * 
     */
    private final Integer disconnectedCount;
    /**
     * @return Whether the enforce mode is enabled on the Enforcers.
     * 
     */
    private final Boolean enforce;
    /**
     * @return The specific Aqua Enforcer product image (with image tag) to be deployed.
     * 
     */
    private final String enforcerImageName;
    /**
     * @return Select Enabled to send activity logs in your containers to the Aqua Server for forensics purposes.
     * 
     */
    private final @Nullable Boolean forensics;
    /**
     * @return Gateway Address
     * 
     */
    private final String gatewayAddress;
    /**
     * @return Gateway Name
     * 
     */
    private final String gatewayName;
    /**
     * @return List of Aqua gateway IDs for the Enforcers.
     * 
     */
    private final List<String> gateways;
    /**
     * @return The ID of the Enforcer group.
     * 
     */
    private final String groupId;
    /**
     * @return Number of high vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    private final Integer highVulns;
    /**
     * @return When set to `True` enables host scanning and respective Host Assurance controls.
     * 
     */
    private final Boolean hostAssurance;
    /**
     * @return When set to `True` enables these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    private final Boolean hostBehavioralEngine;
    /**
     * @return Select Enabled to send activity logs in your host to the Aqua Server for forensics purposes.
     * 
     */
    private final @Nullable Boolean hostForensics;
    /**
     * @return When set to `True` applies Firewall Policies to hosts, and allows recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information
     * 
     */
    private final Boolean hostNetworkProtection;
    /**
     * @return The OS type for the host
     * 
     */
    private final String hostOs;
    /**
     * @return When set to `True` enables all Host Runtime Policy controls except for `OS Users and Groups Allowed` and `OS Users and Groups Blocked`.
     * 
     */
    private final Boolean hostProtection;
    /**
     * @return When set to `True` enables these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    private final Boolean hostUserProtection;
    /**
     * @return Number of enforcers in the enforcer group.
     * 
     */
    private final Integer hostsCount;
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    private final String id;
    /**
     * @return When Set to `True` enables selected controls: Container Runtime Policy (`Block Non-Compliant Images`, `Block Unregistered Images`, and `Registries Allowed`) and Default Image Assurance Policy (`Images Blocked`).
     * 
     */
    private final Boolean imageAssurance;
    /**
     * @return Enforcer install command
     * 
     */
    private final String installCommand;
    /**
     * @return See https://docs.aquasec.com/docs/securing-kubernetes-applications#section-configuration-hardening, The KubeEnforcer can deploy the Aqua Security kube-bench open-source product to perform Kubernetes CIS benchmark testing of nodes.
     * 			This field specifies the path and file name of the kube-bench product image for the KubeEnforcer to deploy; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    private final String kubeBenchImageName;
    /**
     * @return The last date and time the batch token was updated in UNIX time.
     * 
     */
    private final Integer lastUpdate;
    /**
     * @return Name for the batch install record.
     * 
     */
    private final String logicalName;
    /**
     * @return Number of low vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    private final Integer lowVulns;
    /**
     * @return Number of medium vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    private final Integer medVulns;
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected.
     * 
     */
    private final String microEnforcerCertsSecretsName;
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected. This field specifies the path and file name of the KubeEnforcer product image to be deployed; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    private final String microEnforcerImageName;
    /**
     * @return This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    private final Boolean microEnforcerInjection;
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected.
     * 
     */
    private final String microEnforcerSecretsName;
    /**
     * @return Number of negligible vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    private final Integer negVulns;
    /**
     * @return When set to `True` applies Firewall Policies to containers, and allows recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information.
     * 
     */
    private final Boolean networkProtection;
    /**
     * @return The orchestrator for which you are creating the Enforcer group.
     * 
     */
    private final List<GetEnforcerGroupsOrchestrator> orchestrators;
    /**
     * @return pas deployment link
     * 
     */
    private final String pasDeploymentLink;
    /**
     * @return Permission Action
     * 
     */
    private final String permission;
    /**
     * @return When set to `True` allows Enforcers to be discovered in the Risk Explorer.
     * 
     */
    private final Boolean riskExplorerAutoDiscovery;
    /**
     * @return Function Runtime Policy that will applay on the nano enforcer.
     * 
     */
    private final String runtimePolicyName;
    /**
     * @return The container runtime environment.
     * 
     */
    private final String runtimeType;
    /**
     * @return When set to `True` configures Enforcers to discover local host images. Discovered images will be listed under Images &gt; Host Images, as well as under Infrastructure (in the Images tab for applicable hosts).
     * 
     */
    private final Boolean syncHostImages;
    /**
     * @return When set to `True` allows profiling and monitoring system calls made by running containers.
     * 
     */
    private final Boolean syscallEnabled;
    /**
     * @return The batch install token.
     * 
     */
    private final String token;
    /**
     * @return Enforcer Type.
     * 
     */
    private final String type;
    /**
     * @return When set to `True` applies User Access Control Policies to containers. Note that Aqua Enforcers must be deployed with the AQUA*RUNC*INTERCEPTION environment variable set to 0 in order to use User Access Control Policies.
     * 
     */
    private final Boolean userAccessControl;

    @CustomType.Constructor
    private GetEnforcerGroupsResult(
        @CustomType.Parameter("admissionControl") Boolean admissionControl,
        @CustomType.Parameter("allowKubeEnforcerAudit") Boolean allowKubeEnforcerAudit,
        @CustomType.Parameter("allowedApplications") List<String> allowedApplications,
        @CustomType.Parameter("allowedLabels") List<String> allowedLabels,
        @CustomType.Parameter("allowedRegistries") List<String> allowedRegistries,
        @CustomType.Parameter("antivirusProtection") Boolean antivirusProtection,
        @CustomType.Parameter("aquaVersion") String aquaVersion,
        @CustomType.Parameter("auditAll") Boolean auditAll,
        @CustomType.Parameter("autoCopySecrets") Boolean autoCopySecrets,
        @CustomType.Parameter("autoDiscoverConfigureRegistries") Boolean autoDiscoverConfigureRegistries,
        @CustomType.Parameter("autoDiscoveryEnabled") Boolean autoDiscoveryEnabled,
        @CustomType.Parameter("autoScanDiscoveredImagesRunningContainers") Boolean autoScanDiscoveredImagesRunningContainers,
        @CustomType.Parameter("behavioralEngine") Boolean behavioralEngine,
        @CustomType.Parameter("blockAdmissionControl") Boolean blockAdmissionControl,
        @CustomType.Parameter("commands") List<GetEnforcerGroupsCommand> commands,
        @CustomType.Parameter("connectedCount") Integer connectedCount,
        @CustomType.Parameter("containerActivityProtection") Boolean containerActivityProtection,
        @CustomType.Parameter("containerAntivirusProtection") Boolean containerAntivirusProtection,
        @CustomType.Parameter("description") String description,
        @CustomType.Parameter("disconnectedCount") Integer disconnectedCount,
        @CustomType.Parameter("enforce") Boolean enforce,
        @CustomType.Parameter("enforcerImageName") String enforcerImageName,
        @CustomType.Parameter("forensics") @Nullable Boolean forensics,
        @CustomType.Parameter("gatewayAddress") String gatewayAddress,
        @CustomType.Parameter("gatewayName") String gatewayName,
        @CustomType.Parameter("gateways") List<String> gateways,
        @CustomType.Parameter("groupId") String groupId,
        @CustomType.Parameter("highVulns") Integer highVulns,
        @CustomType.Parameter("hostAssurance") Boolean hostAssurance,
        @CustomType.Parameter("hostBehavioralEngine") Boolean hostBehavioralEngine,
        @CustomType.Parameter("hostForensics") @Nullable Boolean hostForensics,
        @CustomType.Parameter("hostNetworkProtection") Boolean hostNetworkProtection,
        @CustomType.Parameter("hostOs") String hostOs,
        @CustomType.Parameter("hostProtection") Boolean hostProtection,
        @CustomType.Parameter("hostUserProtection") Boolean hostUserProtection,
        @CustomType.Parameter("hostsCount") Integer hostsCount,
        @CustomType.Parameter("id") String id,
        @CustomType.Parameter("imageAssurance") Boolean imageAssurance,
        @CustomType.Parameter("installCommand") String installCommand,
        @CustomType.Parameter("kubeBenchImageName") String kubeBenchImageName,
        @CustomType.Parameter("lastUpdate") Integer lastUpdate,
        @CustomType.Parameter("logicalName") String logicalName,
        @CustomType.Parameter("lowVulns") Integer lowVulns,
        @CustomType.Parameter("medVulns") Integer medVulns,
        @CustomType.Parameter("microEnforcerCertsSecretsName") String microEnforcerCertsSecretsName,
        @CustomType.Parameter("microEnforcerImageName") String microEnforcerImageName,
        @CustomType.Parameter("microEnforcerInjection") Boolean microEnforcerInjection,
        @CustomType.Parameter("microEnforcerSecretsName") String microEnforcerSecretsName,
        @CustomType.Parameter("negVulns") Integer negVulns,
        @CustomType.Parameter("networkProtection") Boolean networkProtection,
        @CustomType.Parameter("orchestrators") List<GetEnforcerGroupsOrchestrator> orchestrators,
        @CustomType.Parameter("pasDeploymentLink") String pasDeploymentLink,
        @CustomType.Parameter("permission") String permission,
        @CustomType.Parameter("riskExplorerAutoDiscovery") Boolean riskExplorerAutoDiscovery,
        @CustomType.Parameter("runtimePolicyName") String runtimePolicyName,
        @CustomType.Parameter("runtimeType") String runtimeType,
        @CustomType.Parameter("syncHostImages") Boolean syncHostImages,
        @CustomType.Parameter("syscallEnabled") Boolean syscallEnabled,
        @CustomType.Parameter("token") String token,
        @CustomType.Parameter("type") String type,
        @CustomType.Parameter("userAccessControl") Boolean userAccessControl) {
        this.admissionControl = admissionControl;
        this.allowKubeEnforcerAudit = allowKubeEnforcerAudit;
        this.allowedApplications = allowedApplications;
        this.allowedLabels = allowedLabels;
        this.allowedRegistries = allowedRegistries;
        this.antivirusProtection = antivirusProtection;
        this.aquaVersion = aquaVersion;
        this.auditAll = auditAll;
        this.autoCopySecrets = autoCopySecrets;
        this.autoDiscoverConfigureRegistries = autoDiscoverConfigureRegistries;
        this.autoDiscoveryEnabled = autoDiscoveryEnabled;
        this.autoScanDiscoveredImagesRunningContainers = autoScanDiscoveredImagesRunningContainers;
        this.behavioralEngine = behavioralEngine;
        this.blockAdmissionControl = blockAdmissionControl;
        this.commands = commands;
        this.connectedCount = connectedCount;
        this.containerActivityProtection = containerActivityProtection;
        this.containerAntivirusProtection = containerAntivirusProtection;
        this.description = description;
        this.disconnectedCount = disconnectedCount;
        this.enforce = enforce;
        this.enforcerImageName = enforcerImageName;
        this.forensics = forensics;
        this.gatewayAddress = gatewayAddress;
        this.gatewayName = gatewayName;
        this.gateways = gateways;
        this.groupId = groupId;
        this.highVulns = highVulns;
        this.hostAssurance = hostAssurance;
        this.hostBehavioralEngine = hostBehavioralEngine;
        this.hostForensics = hostForensics;
        this.hostNetworkProtection = hostNetworkProtection;
        this.hostOs = hostOs;
        this.hostProtection = hostProtection;
        this.hostUserProtection = hostUserProtection;
        this.hostsCount = hostsCount;
        this.id = id;
        this.imageAssurance = imageAssurance;
        this.installCommand = installCommand;
        this.kubeBenchImageName = kubeBenchImageName;
        this.lastUpdate = lastUpdate;
        this.logicalName = logicalName;
        this.lowVulns = lowVulns;
        this.medVulns = medVulns;
        this.microEnforcerCertsSecretsName = microEnforcerCertsSecretsName;
        this.microEnforcerImageName = microEnforcerImageName;
        this.microEnforcerInjection = microEnforcerInjection;
        this.microEnforcerSecretsName = microEnforcerSecretsName;
        this.negVulns = negVulns;
        this.networkProtection = networkProtection;
        this.orchestrators = orchestrators;
        this.pasDeploymentLink = pasDeploymentLink;
        this.permission = permission;
        this.riskExplorerAutoDiscovery = riskExplorerAutoDiscovery;
        this.runtimePolicyName = runtimePolicyName;
        this.runtimeType = runtimeType;
        this.syncHostImages = syncHostImages;
        this.syscallEnabled = syscallEnabled;
        this.token = token;
        this.type = type;
        this.userAccessControl = userAccessControl;
    }

    /**
     * @return Selecting this option will allow the KubeEnforcer to block the deployment of container images that have failed any of these Container Runtime Policy controls:\
     * 			* Block Non-Compliant Images\
     * 			* Block Non-Compliant Workloads\
     * 			* Block Unregistered Images\
     * 			This functionality can work only when the KubeEnforcer is deployed in Enforce mode.
     * 
     */
    public Boolean admissionControl() {
        return this.admissionControl;
    }
    /**
     * @return Allow kube enforcer audit.
     * 
     */
    public Boolean allowKubeEnforcerAudit() {
        return this.allowKubeEnforcerAudit;
    }
    /**
     * @return List of application names to allow on the hosts. if provided, only containers of the listed applications will be allowed to run.
     * 
     */
    public List<String> allowedApplications() {
        return this.allowedApplications;
    }
    /**
     * @return List of label names to allow on the hosts.
     * 
     */
    public List<String> allowedLabels() {
        return this.allowedLabels;
    }
    /**
     * @return List of registry names to allow on the hosts.
     * 
     */
    public List<String> allowedRegistries() {
        return this.allowedRegistries;
    }
    /**
     * @return This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Host Runtime policies.
     * 
     */
    public Boolean antivirusProtection() {
        return this.antivirusProtection;
    }
    /**
     * @return Aqua server version
     * 
     */
    public String aquaVersion() {
        return this.aquaVersion;
    }
    /**
     * @return Agent will send extra audit messages to the server for success operations from inside the container (runtime).
     * 
     */
    public Boolean auditAll() {
        return this.auditAll;
    }
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected. Select this option if you want Aqua Enterprise to copy the secrets defined above to the Pod Enforcer namespace and container. Otherwise, you can choose to copy these secrets by other means.
     * 
     */
    public Boolean autoCopySecrets() {
        return this.autoCopySecrets;
    }
    /**
     * @return This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will add previously unknown image registries from the cluster to Aqua.
     * 
     */
    public Boolean autoDiscoverConfigureRegistries() {
        return this.autoDiscoverConfigureRegistries;
    }
    /**
     * @return When this option is selected, the KubeEnforcer will discover workloads on its cluster.
     * 
     */
    public Boolean autoDiscoveryEnabled() {
        return this.autoDiscoveryEnabled;
    }
    /**
     * @return This option is available only if `Enable workload discovery` is selected. If selected, the KubeEnforcer will automatically register images running as workloads (and scan the discovered images for security issues).
     * 
     */
    public Boolean autoScanDiscoveredImagesRunningContainers() {
        return this.autoScanDiscoveredImagesRunningContainers;
    }
    /**
     * @return If `Enabled`, detects suspicious activity in your containers and displays potential security threats in the Incidents and Audits pages.
     * 
     */
    public Boolean behavioralEngine() {
        return this.behavioralEngine;
    }
    /**
     * @return This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    public Boolean blockAdmissionControl() {
        return this.blockAdmissionControl;
    }
    /**
     * @return The installation command.
     * 
     */
    public List<GetEnforcerGroupsCommand> commands() {
        return this.commands;
    }
    /**
     * @return Number of connected enforcers in the enforcer group.
     * 
     */
    public Integer connectedCount() {
        return this.connectedCount;
    }
    /**
     * @return When set to `True` applies Container Runtime Policies, Image Profiles, and Firewall Policies to containers.
     * 
     */
    public Boolean containerActivityProtection() {
        return this.containerActivityProtection;
    }
    /**
     * @return This setting is available only when you have license for `Advanced Malware Protection`. Send true to make use of the license and enable the `Real-time Malware Protection` control in the Container Runtime policies.
     * 
     */
    public Boolean containerAntivirusProtection() {
        return this.containerAntivirusProtection;
    }
    /**
     * @return A description for the Aqua Enforcer group.
     * 
     */
    public String description() {
        return this.description;
    }
    /**
     * @return Number of disconnected enforcers in the enforcer group.
     * 
     */
    public Integer disconnectedCount() {
        return this.disconnectedCount;
    }
    /**
     * @return Whether the enforce mode is enabled on the Enforcers.
     * 
     */
    public Boolean enforce() {
        return this.enforce;
    }
    /**
     * @return The specific Aqua Enforcer product image (with image tag) to be deployed.
     * 
     */
    public String enforcerImageName() {
        return this.enforcerImageName;
    }
    /**
     * @return Select Enabled to send activity logs in your containers to the Aqua Server for forensics purposes.
     * 
     */
    public Optional<Boolean> forensics() {
        return Optional.ofNullable(this.forensics);
    }
    /**
     * @return Gateway Address
     * 
     */
    public String gatewayAddress() {
        return this.gatewayAddress;
    }
    /**
     * @return Gateway Name
     * 
     */
    public String gatewayName() {
        return this.gatewayName;
    }
    /**
     * @return List of Aqua gateway IDs for the Enforcers.
     * 
     */
    public List<String> gateways() {
        return this.gateways;
    }
    /**
     * @return The ID of the Enforcer group.
     * 
     */
    public String groupId() {
        return this.groupId;
    }
    /**
     * @return Number of high vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Integer highVulns() {
        return this.highVulns;
    }
    /**
     * @return When set to `True` enables host scanning and respective Host Assurance controls.
     * 
     */
    public Boolean hostAssurance() {
        return this.hostAssurance;
    }
    /**
     * @return When set to `True` enables these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    public Boolean hostBehavioralEngine() {
        return this.hostBehavioralEngine;
    }
    /**
     * @return Select Enabled to send activity logs in your host to the Aqua Server for forensics purposes.
     * 
     */
    public Optional<Boolean> hostForensics() {
        return Optional.ofNullable(this.hostForensics);
    }
    /**
     * @return When set to `True` applies Firewall Policies to hosts, and allows recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information
     * 
     */
    public Boolean hostNetworkProtection() {
        return this.hostNetworkProtection;
    }
    /**
     * @return The OS type for the host
     * 
     */
    public String hostOs() {
        return this.hostOs;
    }
    /**
     * @return When set to `True` enables all Host Runtime Policy controls except for `OS Users and Groups Allowed` and `OS Users and Groups Blocked`.
     * 
     */
    public Boolean hostProtection() {
        return this.hostProtection;
    }
    /**
     * @return When set to `True` enables these Host Runtime Policy controls: `OS Users and Groups Allowed` and `OS Users and Groups Blocked`
     * 
     */
    public Boolean hostUserProtection() {
        return this.hostUserProtection;
    }
    /**
     * @return Number of enforcers in the enforcer group.
     * 
     */
    public Integer hostsCount() {
        return this.hostsCount;
    }
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return When Set to `True` enables selected controls: Container Runtime Policy (`Block Non-Compliant Images`, `Block Unregistered Images`, and `Registries Allowed`) and Default Image Assurance Policy (`Images Blocked`).
     * 
     */
    public Boolean imageAssurance() {
        return this.imageAssurance;
    }
    /**
     * @return Enforcer install command
     * 
     */
    public String installCommand() {
        return this.installCommand;
    }
    /**
     * @return See https://docs.aquasec.com/docs/securing-kubernetes-applications#section-configuration-hardening, The KubeEnforcer can deploy the Aqua Security kube-bench open-source product to perform Kubernetes CIS benchmark testing of nodes.
     * 			This field specifies the path and file name of the kube-bench product image for the KubeEnforcer to deploy; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    public String kubeBenchImageName() {
        return this.kubeBenchImageName;
    }
    /**
     * @return The last date and time the batch token was updated in UNIX time.
     * 
     */
    public Integer lastUpdate() {
        return this.lastUpdate;
    }
    /**
     * @return Name for the batch install record.
     * 
     */
    public String logicalName() {
        return this.logicalName;
    }
    /**
     * @return Number of low vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Integer lowVulns() {
        return this.lowVulns;
    }
    /**
     * @return Number of medium vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Integer medVulns() {
        return this.medVulns;
    }
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected.
     * 
     */
    public String microEnforcerCertsSecretsName() {
        return this.microEnforcerCertsSecretsName;
    }
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected. This field specifies the path and file name of the KubeEnforcer product image to be deployed; it will be filled in automatically. You can optionally enter a different value.
     * 
     */
    public String microEnforcerImageName() {
        return this.microEnforcerImageName;
    }
    /**
     * @return This applies only if both `Enable admission control` and Enforce mode are set. This additional option must be selected for admission control to work if the KubeEnforcer is not connected to any Gateway. If this option is not selected, admission control will be disabled; this will have no effect on containers already running.
     * 
     */
    public Boolean microEnforcerInjection() {
        return this.microEnforcerInjection;
    }
    /**
     * @return This option is applicable only if `Enable Pod Enforcer injection` is selected.
     * 
     */
    public String microEnforcerSecretsName() {
        return this.microEnforcerSecretsName;
    }
    /**
     * @return Number of negligible vulnerabilities in the enforcers that in this enforcer group.
     * 
     */
    public Integer negVulns() {
        return this.negVulns;
    }
    /**
     * @return When set to `True` applies Firewall Policies to containers, and allows recording network maps for Aqua services. The Network Firewall setting must be disabled when deploying the Aqua Enforcer on a machine running Rocky Linux. See https://docs.aquasec.com/docs/platform-support-limitations-rocky-linux for further information.
     * 
     */
    public Boolean networkProtection() {
        return this.networkProtection;
    }
    /**
     * @return The orchestrator for which you are creating the Enforcer group.
     * 
     */
    public List<GetEnforcerGroupsOrchestrator> orchestrators() {
        return this.orchestrators;
    }
    /**
     * @return pas deployment link
     * 
     */
    public String pasDeploymentLink() {
        return this.pasDeploymentLink;
    }
    /**
     * @return Permission Action
     * 
     */
    public String permission() {
        return this.permission;
    }
    /**
     * @return When set to `True` allows Enforcers to be discovered in the Risk Explorer.
     * 
     */
    public Boolean riskExplorerAutoDiscovery() {
        return this.riskExplorerAutoDiscovery;
    }
    /**
     * @return Function Runtime Policy that will applay on the nano enforcer.
     * 
     */
    public String runtimePolicyName() {
        return this.runtimePolicyName;
    }
    /**
     * @return The container runtime environment.
     * 
     */
    public String runtimeType() {
        return this.runtimeType;
    }
    /**
     * @return When set to `True` configures Enforcers to discover local host images. Discovered images will be listed under Images &gt; Host Images, as well as under Infrastructure (in the Images tab for applicable hosts).
     * 
     */
    public Boolean syncHostImages() {
        return this.syncHostImages;
    }
    /**
     * @return When set to `True` allows profiling and monitoring system calls made by running containers.
     * 
     */
    public Boolean syscallEnabled() {
        return this.syscallEnabled;
    }
    /**
     * @return The batch install token.
     * 
     */
    public String token() {
        return this.token;
    }
    /**
     * @return Enforcer Type.
     * 
     */
    public String type() {
        return this.type;
    }
    /**
     * @return When set to `True` applies User Access Control Policies to containers. Note that Aqua Enforcers must be deployed with the AQUA*RUNC*INTERCEPTION environment variable set to 0 in order to use User Access Control Policies.
     * 
     */
    public Boolean userAccessControl() {
        return this.userAccessControl;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetEnforcerGroupsResult defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private Boolean admissionControl;
        private Boolean allowKubeEnforcerAudit;
        private List<String> allowedApplications;
        private List<String> allowedLabels;
        private List<String> allowedRegistries;
        private Boolean antivirusProtection;
        private String aquaVersion;
        private Boolean auditAll;
        private Boolean autoCopySecrets;
        private Boolean autoDiscoverConfigureRegistries;
        private Boolean autoDiscoveryEnabled;
        private Boolean autoScanDiscoveredImagesRunningContainers;
        private Boolean behavioralEngine;
        private Boolean blockAdmissionControl;
        private List<GetEnforcerGroupsCommand> commands;
        private Integer connectedCount;
        private Boolean containerActivityProtection;
        private Boolean containerAntivirusProtection;
        private String description;
        private Integer disconnectedCount;
        private Boolean enforce;
        private String enforcerImageName;
        private @Nullable Boolean forensics;
        private String gatewayAddress;
        private String gatewayName;
        private List<String> gateways;
        private String groupId;
        private Integer highVulns;
        private Boolean hostAssurance;
        private Boolean hostBehavioralEngine;
        private @Nullable Boolean hostForensics;
        private Boolean hostNetworkProtection;
        private String hostOs;
        private Boolean hostProtection;
        private Boolean hostUserProtection;
        private Integer hostsCount;
        private String id;
        private Boolean imageAssurance;
        private String installCommand;
        private String kubeBenchImageName;
        private Integer lastUpdate;
        private String logicalName;
        private Integer lowVulns;
        private Integer medVulns;
        private String microEnforcerCertsSecretsName;
        private String microEnforcerImageName;
        private Boolean microEnforcerInjection;
        private String microEnforcerSecretsName;
        private Integer negVulns;
        private Boolean networkProtection;
        private List<GetEnforcerGroupsOrchestrator> orchestrators;
        private String pasDeploymentLink;
        private String permission;
        private Boolean riskExplorerAutoDiscovery;
        private String runtimePolicyName;
        private String runtimeType;
        private Boolean syncHostImages;
        private Boolean syscallEnabled;
        private String token;
        private String type;
        private Boolean userAccessControl;

        public Builder() {
    	      // Empty
        }

        public Builder(GetEnforcerGroupsResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.admissionControl = defaults.admissionControl;
    	      this.allowKubeEnforcerAudit = defaults.allowKubeEnforcerAudit;
    	      this.allowedApplications = defaults.allowedApplications;
    	      this.allowedLabels = defaults.allowedLabels;
    	      this.allowedRegistries = defaults.allowedRegistries;
    	      this.antivirusProtection = defaults.antivirusProtection;
    	      this.aquaVersion = defaults.aquaVersion;
    	      this.auditAll = defaults.auditAll;
    	      this.autoCopySecrets = defaults.autoCopySecrets;
    	      this.autoDiscoverConfigureRegistries = defaults.autoDiscoverConfigureRegistries;
    	      this.autoDiscoveryEnabled = defaults.autoDiscoveryEnabled;
    	      this.autoScanDiscoveredImagesRunningContainers = defaults.autoScanDiscoveredImagesRunningContainers;
    	      this.behavioralEngine = defaults.behavioralEngine;
    	      this.blockAdmissionControl = defaults.blockAdmissionControl;
    	      this.commands = defaults.commands;
    	      this.connectedCount = defaults.connectedCount;
    	      this.containerActivityProtection = defaults.containerActivityProtection;
    	      this.containerAntivirusProtection = defaults.containerAntivirusProtection;
    	      this.description = defaults.description;
    	      this.disconnectedCount = defaults.disconnectedCount;
    	      this.enforce = defaults.enforce;
    	      this.enforcerImageName = defaults.enforcerImageName;
    	      this.forensics = defaults.forensics;
    	      this.gatewayAddress = defaults.gatewayAddress;
    	      this.gatewayName = defaults.gatewayName;
    	      this.gateways = defaults.gateways;
    	      this.groupId = defaults.groupId;
    	      this.highVulns = defaults.highVulns;
    	      this.hostAssurance = defaults.hostAssurance;
    	      this.hostBehavioralEngine = defaults.hostBehavioralEngine;
    	      this.hostForensics = defaults.hostForensics;
    	      this.hostNetworkProtection = defaults.hostNetworkProtection;
    	      this.hostOs = defaults.hostOs;
    	      this.hostProtection = defaults.hostProtection;
    	      this.hostUserProtection = defaults.hostUserProtection;
    	      this.hostsCount = defaults.hostsCount;
    	      this.id = defaults.id;
    	      this.imageAssurance = defaults.imageAssurance;
    	      this.installCommand = defaults.installCommand;
    	      this.kubeBenchImageName = defaults.kubeBenchImageName;
    	      this.lastUpdate = defaults.lastUpdate;
    	      this.logicalName = defaults.logicalName;
    	      this.lowVulns = defaults.lowVulns;
    	      this.medVulns = defaults.medVulns;
    	      this.microEnforcerCertsSecretsName = defaults.microEnforcerCertsSecretsName;
    	      this.microEnforcerImageName = defaults.microEnforcerImageName;
    	      this.microEnforcerInjection = defaults.microEnforcerInjection;
    	      this.microEnforcerSecretsName = defaults.microEnforcerSecretsName;
    	      this.negVulns = defaults.negVulns;
    	      this.networkProtection = defaults.networkProtection;
    	      this.orchestrators = defaults.orchestrators;
    	      this.pasDeploymentLink = defaults.pasDeploymentLink;
    	      this.permission = defaults.permission;
    	      this.riskExplorerAutoDiscovery = defaults.riskExplorerAutoDiscovery;
    	      this.runtimePolicyName = defaults.runtimePolicyName;
    	      this.runtimeType = defaults.runtimeType;
    	      this.syncHostImages = defaults.syncHostImages;
    	      this.syscallEnabled = defaults.syscallEnabled;
    	      this.token = defaults.token;
    	      this.type = defaults.type;
    	      this.userAccessControl = defaults.userAccessControl;
        }

        public Builder admissionControl(Boolean admissionControl) {
            this.admissionControl = Objects.requireNonNull(admissionControl);
            return this;
        }
        public Builder allowKubeEnforcerAudit(Boolean allowKubeEnforcerAudit) {
            this.allowKubeEnforcerAudit = Objects.requireNonNull(allowKubeEnforcerAudit);
            return this;
        }
        public Builder allowedApplications(List<String> allowedApplications) {
            this.allowedApplications = Objects.requireNonNull(allowedApplications);
            return this;
        }
        public Builder allowedApplications(String... allowedApplications) {
            return allowedApplications(List.of(allowedApplications));
        }
        public Builder allowedLabels(List<String> allowedLabels) {
            this.allowedLabels = Objects.requireNonNull(allowedLabels);
            return this;
        }
        public Builder allowedLabels(String... allowedLabels) {
            return allowedLabels(List.of(allowedLabels));
        }
        public Builder allowedRegistries(List<String> allowedRegistries) {
            this.allowedRegistries = Objects.requireNonNull(allowedRegistries);
            return this;
        }
        public Builder allowedRegistries(String... allowedRegistries) {
            return allowedRegistries(List.of(allowedRegistries));
        }
        public Builder antivirusProtection(Boolean antivirusProtection) {
            this.antivirusProtection = Objects.requireNonNull(antivirusProtection);
            return this;
        }
        public Builder aquaVersion(String aquaVersion) {
            this.aquaVersion = Objects.requireNonNull(aquaVersion);
            return this;
        }
        public Builder auditAll(Boolean auditAll) {
            this.auditAll = Objects.requireNonNull(auditAll);
            return this;
        }
        public Builder autoCopySecrets(Boolean autoCopySecrets) {
            this.autoCopySecrets = Objects.requireNonNull(autoCopySecrets);
            return this;
        }
        public Builder autoDiscoverConfigureRegistries(Boolean autoDiscoverConfigureRegistries) {
            this.autoDiscoverConfigureRegistries = Objects.requireNonNull(autoDiscoverConfigureRegistries);
            return this;
        }
        public Builder autoDiscoveryEnabled(Boolean autoDiscoveryEnabled) {
            this.autoDiscoveryEnabled = Objects.requireNonNull(autoDiscoveryEnabled);
            return this;
        }
        public Builder autoScanDiscoveredImagesRunningContainers(Boolean autoScanDiscoveredImagesRunningContainers) {
            this.autoScanDiscoveredImagesRunningContainers = Objects.requireNonNull(autoScanDiscoveredImagesRunningContainers);
            return this;
        }
        public Builder behavioralEngine(Boolean behavioralEngine) {
            this.behavioralEngine = Objects.requireNonNull(behavioralEngine);
            return this;
        }
        public Builder blockAdmissionControl(Boolean blockAdmissionControl) {
            this.blockAdmissionControl = Objects.requireNonNull(blockAdmissionControl);
            return this;
        }
        public Builder commands(List<GetEnforcerGroupsCommand> commands) {
            this.commands = Objects.requireNonNull(commands);
            return this;
        }
        public Builder commands(GetEnforcerGroupsCommand... commands) {
            return commands(List.of(commands));
        }
        public Builder connectedCount(Integer connectedCount) {
            this.connectedCount = Objects.requireNonNull(connectedCount);
            return this;
        }
        public Builder containerActivityProtection(Boolean containerActivityProtection) {
            this.containerActivityProtection = Objects.requireNonNull(containerActivityProtection);
            return this;
        }
        public Builder containerAntivirusProtection(Boolean containerAntivirusProtection) {
            this.containerAntivirusProtection = Objects.requireNonNull(containerAntivirusProtection);
            return this;
        }
        public Builder description(String description) {
            this.description = Objects.requireNonNull(description);
            return this;
        }
        public Builder disconnectedCount(Integer disconnectedCount) {
            this.disconnectedCount = Objects.requireNonNull(disconnectedCount);
            return this;
        }
        public Builder enforce(Boolean enforce) {
            this.enforce = Objects.requireNonNull(enforce);
            return this;
        }
        public Builder enforcerImageName(String enforcerImageName) {
            this.enforcerImageName = Objects.requireNonNull(enforcerImageName);
            return this;
        }
        public Builder forensics(@Nullable Boolean forensics) {
            this.forensics = forensics;
            return this;
        }
        public Builder gatewayAddress(String gatewayAddress) {
            this.gatewayAddress = Objects.requireNonNull(gatewayAddress);
            return this;
        }
        public Builder gatewayName(String gatewayName) {
            this.gatewayName = Objects.requireNonNull(gatewayName);
            return this;
        }
        public Builder gateways(List<String> gateways) {
            this.gateways = Objects.requireNonNull(gateways);
            return this;
        }
        public Builder gateways(String... gateways) {
            return gateways(List.of(gateways));
        }
        public Builder groupId(String groupId) {
            this.groupId = Objects.requireNonNull(groupId);
            return this;
        }
        public Builder highVulns(Integer highVulns) {
            this.highVulns = Objects.requireNonNull(highVulns);
            return this;
        }
        public Builder hostAssurance(Boolean hostAssurance) {
            this.hostAssurance = Objects.requireNonNull(hostAssurance);
            return this;
        }
        public Builder hostBehavioralEngine(Boolean hostBehavioralEngine) {
            this.hostBehavioralEngine = Objects.requireNonNull(hostBehavioralEngine);
            return this;
        }
        public Builder hostForensics(@Nullable Boolean hostForensics) {
            this.hostForensics = hostForensics;
            return this;
        }
        public Builder hostNetworkProtection(Boolean hostNetworkProtection) {
            this.hostNetworkProtection = Objects.requireNonNull(hostNetworkProtection);
            return this;
        }
        public Builder hostOs(String hostOs) {
            this.hostOs = Objects.requireNonNull(hostOs);
            return this;
        }
        public Builder hostProtection(Boolean hostProtection) {
            this.hostProtection = Objects.requireNonNull(hostProtection);
            return this;
        }
        public Builder hostUserProtection(Boolean hostUserProtection) {
            this.hostUserProtection = Objects.requireNonNull(hostUserProtection);
            return this;
        }
        public Builder hostsCount(Integer hostsCount) {
            this.hostsCount = Objects.requireNonNull(hostsCount);
            return this;
        }
        public Builder id(String id) {
            this.id = Objects.requireNonNull(id);
            return this;
        }
        public Builder imageAssurance(Boolean imageAssurance) {
            this.imageAssurance = Objects.requireNonNull(imageAssurance);
            return this;
        }
        public Builder installCommand(String installCommand) {
            this.installCommand = Objects.requireNonNull(installCommand);
            return this;
        }
        public Builder kubeBenchImageName(String kubeBenchImageName) {
            this.kubeBenchImageName = Objects.requireNonNull(kubeBenchImageName);
            return this;
        }
        public Builder lastUpdate(Integer lastUpdate) {
            this.lastUpdate = Objects.requireNonNull(lastUpdate);
            return this;
        }
        public Builder logicalName(String logicalName) {
            this.logicalName = Objects.requireNonNull(logicalName);
            return this;
        }
        public Builder lowVulns(Integer lowVulns) {
            this.lowVulns = Objects.requireNonNull(lowVulns);
            return this;
        }
        public Builder medVulns(Integer medVulns) {
            this.medVulns = Objects.requireNonNull(medVulns);
            return this;
        }
        public Builder microEnforcerCertsSecretsName(String microEnforcerCertsSecretsName) {
            this.microEnforcerCertsSecretsName = Objects.requireNonNull(microEnforcerCertsSecretsName);
            return this;
        }
        public Builder microEnforcerImageName(String microEnforcerImageName) {
            this.microEnforcerImageName = Objects.requireNonNull(microEnforcerImageName);
            return this;
        }
        public Builder microEnforcerInjection(Boolean microEnforcerInjection) {
            this.microEnforcerInjection = Objects.requireNonNull(microEnforcerInjection);
            return this;
        }
        public Builder microEnforcerSecretsName(String microEnforcerSecretsName) {
            this.microEnforcerSecretsName = Objects.requireNonNull(microEnforcerSecretsName);
            return this;
        }
        public Builder negVulns(Integer negVulns) {
            this.negVulns = Objects.requireNonNull(negVulns);
            return this;
        }
        public Builder networkProtection(Boolean networkProtection) {
            this.networkProtection = Objects.requireNonNull(networkProtection);
            return this;
        }
        public Builder orchestrators(List<GetEnforcerGroupsOrchestrator> orchestrators) {
            this.orchestrators = Objects.requireNonNull(orchestrators);
            return this;
        }
        public Builder orchestrators(GetEnforcerGroupsOrchestrator... orchestrators) {
            return orchestrators(List.of(orchestrators));
        }
        public Builder pasDeploymentLink(String pasDeploymentLink) {
            this.pasDeploymentLink = Objects.requireNonNull(pasDeploymentLink);
            return this;
        }
        public Builder permission(String permission) {
            this.permission = Objects.requireNonNull(permission);
            return this;
        }
        public Builder riskExplorerAutoDiscovery(Boolean riskExplorerAutoDiscovery) {
            this.riskExplorerAutoDiscovery = Objects.requireNonNull(riskExplorerAutoDiscovery);
            return this;
        }
        public Builder runtimePolicyName(String runtimePolicyName) {
            this.runtimePolicyName = Objects.requireNonNull(runtimePolicyName);
            return this;
        }
        public Builder runtimeType(String runtimeType) {
            this.runtimeType = Objects.requireNonNull(runtimeType);
            return this;
        }
        public Builder syncHostImages(Boolean syncHostImages) {
            this.syncHostImages = Objects.requireNonNull(syncHostImages);
            return this;
        }
        public Builder syscallEnabled(Boolean syscallEnabled) {
            this.syscallEnabled = Objects.requireNonNull(syscallEnabled);
            return this;
        }
        public Builder token(String token) {
            this.token = Objects.requireNonNull(token);
            return this;
        }
        public Builder type(String type) {
            this.type = Objects.requireNonNull(type);
            return this;
        }
        public Builder userAccessControl(Boolean userAccessControl) {
            this.userAccessControl = Objects.requireNonNull(userAccessControl);
            return this;
        }        public GetEnforcerGroupsResult build() {
            return new GetEnforcerGroupsResult(admissionControl, allowKubeEnforcerAudit, allowedApplications, allowedLabels, allowedRegistries, antivirusProtection, aquaVersion, auditAll, autoCopySecrets, autoDiscoverConfigureRegistries, autoDiscoveryEnabled, autoScanDiscoveredImagesRunningContainers, behavioralEngine, blockAdmissionControl, commands, connectedCount, containerActivityProtection, containerAntivirusProtection, description, disconnectedCount, enforce, enforcerImageName, forensics, gatewayAddress, gatewayName, gateways, groupId, highVulns, hostAssurance, hostBehavioralEngine, hostForensics, hostNetworkProtection, hostOs, hostProtection, hostUserProtection, hostsCount, id, imageAssurance, installCommand, kubeBenchImageName, lastUpdate, logicalName, lowVulns, medVulns, microEnforcerCertsSecretsName, microEnforcerImageName, microEnforcerInjection, microEnforcerSecretsName, negVulns, networkProtection, orchestrators, pasDeploymentLink, permission, riskExplorerAutoDiscovery, runtimePolicyName, runtimeType, syncHostImages, syscallEnabled, token, type, userAccessControl);
        }
    }
}
