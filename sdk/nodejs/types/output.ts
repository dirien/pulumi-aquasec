// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AcknowledgeIssue {
    /**
     * The user who acknowledged the issue.
     */
    author: string;
    /**
     * The date and time of the acknowledgment.
     */
    date: string;
    dockerId?: string;
    /**
     * The current dat and time when the expiration was set
     */
    expirationConfiguredAt: string;
    /**
     * The user who set the expiration of the issue.
     */
    expirationConfiguredBy: string;
    /**
     * Number of days until expiration of the acknowledgement. The value must be integer from 1 to 999, inclusive.
     */
    expirationDays?: number;
    /**
     * The version of the package that having a fix for the issue.
     */
    fixVersion?: string;
    /**
     * Only acknowledge the issue in the context of the specified image (also requires 'registry_name')
     */
    imageName?: string;
    /**
     * The name of the security issue (the CVE or security advisory for vulnerabilities, name of malware or type of sensitive data)
     */
    issueName: string;
    /**
     * The type of the security issue (either 'vulnerability', 'sensitive_data' or 'malware')
     */
    issueType: string;
    /**
     * When the resourceType is 'package', the operating system is required (e.g., 'ubuntu', 'alpine').
     */
    os?: string;
    /**
     * When the resourceType is 'package', the operating system version is required.
     */
    osVersion?: string;
    /**
     * The permissions of the user who acknowledged the issue.
     */
    permission: string;
    /**
     * Only acknowledge the issue in the context of the specified repository (also requires 'registry_name').
     */
    registryName?: string;
    /**
     * The CPE of the resource as listed in the issue by the Aqua API. This is required for resources of type 'executable'. For packages and files, the next parameters can be specified instead.
     */
    resourceCpe?: string;
    /**
     * The format of the resource.
     */
    resourceFormat?: string;
    /**
     * When the resourceType is 'file', the hash of the file is required
     */
    resourceHash?: string;
    /**
     * When the resourceType is 'package', the name of the package is required.
     */
    resourceName?: string;
    /**
     * The path of the resource. This is required for resources of type 'file' and 'executable'.
     */
    resourcePath?: string;
    /**
     * The type of the resource where the issue was detected (either 'package', 'file' or 'executable')
     */
    resourceType: string;
    /**
     * When the resourceType is 'package', the version of the package is required
     */
    resourceVersion?: string;
}

export interface ApplicationScopeCategory {
    /**
     * An artifact is an application. It can be an image (for a container, not a CF application); a serverless function; or a Tanzu Application Service (TAS) droplet.
     */
    artifacts?: outputs.ApplicationScopeCategoryArtifact[];
    entityScopes: outputs.ApplicationScopeCategoryEntityScope[];
    /**
     * An infrastructure resource is an element of a computing environment on which a workload is orchestrated and run. It can be a host (VM) or a Kubernetes cluster.
     */
    infrastructures?: outputs.ApplicationScopeCategoryInfrastructure[];
    /**
     * A workload is a running container. It can run in a Kubernetes cluster, on a VM (no orchestrator), or under Tanzu Application Service (TAS).
     */
    workloads?: outputs.ApplicationScopeCategoryWorkload[];
}

export interface ApplicationScopeCategoryArtifact {
    cfs?: outputs.ApplicationScopeCategoryArtifactCf[];
    /**
     * Function name
     */
    functions?: outputs.ApplicationScopeCategoryArtifactFunction[];
    /**
     * Name of a registry as defined in Aqua
     */
    images?: outputs.ApplicationScopeCategoryArtifactImage[];
}

export interface ApplicationScopeCategoryArtifactCf {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryArtifactCfVariable[];
}

export interface ApplicationScopeCategoryArtifactCfVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryArtifactFunction {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryArtifactFunctionVariable[];
}

export interface ApplicationScopeCategoryArtifactFunctionVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryArtifactImage {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryArtifactImageVariable[];
}

export interface ApplicationScopeCategoryArtifactImageVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryEntityScope {
    expression: string;
    variables: outputs.ApplicationScopeCategoryEntityScopeVariable[];
}

export interface ApplicationScopeCategoryEntityScopeVariable {
    attribute: string;
    value: string;
}

export interface ApplicationScopeCategoryInfrastructure {
    kubernetes?: outputs.ApplicationScopeCategoryInfrastructureKubernete[];
    os?: outputs.ApplicationScopeCategoryInfrastructureO[];
}

export interface ApplicationScopeCategoryInfrastructureKubernete {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryInfrastructureKuberneteVariable[];
}

export interface ApplicationScopeCategoryInfrastructureKuberneteVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryInfrastructureO {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryInfrastructureOVariable[];
}

export interface ApplicationScopeCategoryInfrastructureOVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryWorkload {
    cfs?: outputs.ApplicationScopeCategoryWorkloadCf[];
    kubernetes?: outputs.ApplicationScopeCategoryWorkloadKubernete[];
    os?: outputs.ApplicationScopeCategoryWorkloadO[];
}

export interface ApplicationScopeCategoryWorkloadCf {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryWorkloadCfVariable[];
}

export interface ApplicationScopeCategoryWorkloadCfVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryWorkloadKubernete {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryWorkloadKuberneteVariable[];
}

export interface ApplicationScopeCategoryWorkloadKuberneteVariable {
    attribute?: string;
    value?: string;
}

export interface ApplicationScopeCategoryWorkloadO {
    expression?: string;
    variables?: outputs.ApplicationScopeCategoryWorkloadOVariable[];
}

export interface ApplicationScopeCategoryWorkloadOVariable {
    attribute?: string;
    value?: string;
}

export interface ContainerRuntimePolicyAllowedExecutable {
    /**
     * List of allowed executables.
     */
    allowExecutables?: string[];
    /**
     * List of allowed root executables.
     */
    allowRootExecutables?: string[];
    /**
     * Whether allowed executables configuration is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to treat executables separately.
     */
    separateExecutables?: boolean;
}

export interface ContainerRuntimePolicyAllowedRegistry {
    /**
     * List of allowed registries.
     */
    allowedRegistries?: string[];
    /**
     * Whether allowed registries are enabled.
     */
    enabled?: boolean;
}

export interface ContainerRuntimePolicyAuditing {
    auditAllNetwork?: boolean;
    auditAllProcesses?: boolean;
    auditFailedLogin?: boolean;
    auditOsUserActivity?: boolean;
    auditProcessCmdline?: boolean;
    auditSuccessLogin?: boolean;
    auditUserAccountManagement?: boolean;
    enabled?: boolean;
}

export interface ContainerRuntimePolicyBlacklistedOsUsers {
    enabled?: boolean;
    groupBlackLists?: string[];
    userBlackLists?: string[];
}

export interface ContainerRuntimePolicyBypassScope {
    /**
     * Whether bypassing the scope is enabled.
     */
    enabled?: boolean;
    /**
     * Scope configuration.
     */
    scopes?: outputs.ContainerRuntimePolicyBypassScopeScope[];
}

export interface ContainerRuntimePolicyBypassScopeScope {
    /**
     * Scope expression.
     */
    expression?: string;
    /**
     * List of variables in the scope.
     */
    variables?: outputs.ContainerRuntimePolicyBypassScopeScopeVariable[];
}

export interface ContainerRuntimePolicyBypassScopeScopeVariable {
    /**
     * Variable attribute.
     */
    attribute?: string;
    /**
     * Variable value.
     */
    value?: string;
}

export interface ContainerRuntimePolicyContainerExec {
    blockContainerExec?: boolean;
    containerExecProcWhiteLists?: string[];
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
}

export interface ContainerRuntimePolicyDriftPrevention {
    /**
     * Whether drift prevention is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to lockdown execution drift.
     */
    execLockdown?: boolean;
    /**
     * List of items in the execution lockdown white list.
     */
    execLockdownWhiteLists?: string[];
    /**
     * Whether to lockdown image drift.
     */
    imageLockdown?: boolean;
}

export interface ContainerRuntimePolicyExecutableBlacklist {
    /**
     * Whether the executable blacklist is enabled.
     */
    enabled?: boolean;
    /**
     * List of blacklisted executables.
     */
    executables?: string[];
}

export interface ContainerRuntimePolicyFailedKubernetesChecks {
    enabled?: boolean;
    failedChecks?: string[];
}

export interface ContainerRuntimePolicyFileBlock {
    blockFilesProcesses?: string[];
    blockFilesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockFiles?: string[];
    exceptionalBlockFilesProcesses?: string[];
    exceptionalBlockFilesUsers?: string[];
    filenameBlockLists?: string[];
}

export interface ContainerRuntimePolicyFileIntegrityMonitoring {
    /**
     * If true, file integrity monitoring is enabled.
     */
    enabled?: boolean;
    /**
     * List of paths to be excluded from monitoring.
     */
    exceptionalMonitoredFiles?: string[];
    /**
     * List of processes to be excluded from monitoring.
     */
    exceptionalMonitoredFilesProcesses?: string[];
    /**
     * List of users to be excluded from monitoring.
     */
    exceptionalMonitoredFilesUsers?: string[];
    /**
     * List of paths to be monitored.
     */
    monitoredFiles?: string[];
    /**
     * Whether to monitor file attribute operations.
     */
    monitoredFilesAttributes?: boolean;
    /**
     * Whether to monitor file create operations.
     */
    monitoredFilesCreate?: boolean;
    /**
     * Whether to monitor file delete operations.
     */
    monitoredFilesDelete?: boolean;
    /**
     * Whether to monitor file modify operations.
     */
    monitoredFilesModify?: boolean;
    /**
     * List of processes associated with monitored files.
     */
    monitoredFilesProcesses?: string[];
    /**
     * Whether to monitor file read operations.
     */
    monitoredFilesRead?: boolean;
    /**
     * List of users associated with monitored files.
     */
    monitoredFilesUsers?: string[];
}

export interface ContainerRuntimePolicyLimitContainerPrivilege {
    /**
     * Whether to block adding capabilities.
     */
    blockAddCapabilities?: boolean;
    /**
     * Whether container privilege limitations are enabled.
     */
    enabled?: boolean;
    /**
     * Whether to limit IPC-related capabilities.
     */
    ipcmode?: boolean;
    /**
     * Whether to limit network-related capabilities.
     */
    netmode?: boolean;
    /**
     * Whether to limit process-related capabilities.
     */
    pidmode?: boolean;
    /**
     * Whether to prevent low port binding.
     */
    preventLowPortBinding?: boolean;
    /**
     * Whether to prevent the use of the root user.
     */
    preventRootUser?: boolean;
    /**
     * Whether the container is run in privileged mode.
     */
    privileged?: boolean;
    /**
     * Whether to use the host user.
     */
    useHostUser?: boolean;
    /**
     * Whether to limit user-related capabilities.
     */
    usermode?: boolean;
    /**
     * Whether to limit UTS-related capabilities.
     */
    utsmode?: boolean;
}

export interface ContainerRuntimePolicyLinuxCapabilities {
    enabled?: boolean;
    removeLinuxCapabilities?: string[];
}

export interface ContainerRuntimePolicyMalwareScanOptions {
    /**
     * Set Action, Defaults to 'Alert' when empty
     */
    action?: string;
    /**
     * Defines if enabled or not
     */
    enabled?: boolean;
    /**
     * List of registry paths to be excluded from being protected.
     */
    excludeDirectories?: string[];
    /**
     * List of registry processes to be excluded from being protected.
     */
    excludeProcesses?: string[];
    /**
     * List of registry paths to be excluded from being protected.
     */
    includeDirectories?: string[];
}

export interface ContainerRuntimePolicyPackageBlock {
    blockPackagesProcesses?: string[];
    blockPackagesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockPackagesFiles?: string[];
    exceptionalBlockPackagesProcesses?: string[];
    exceptionalBlockPackagesUsers?: string[];
    packagesBlackLists?: string[];
}

export interface ContainerRuntimePolicyPortBlock {
    blockInboundPorts?: string[];
    blockOutboundPorts?: string[];
    enabled?: boolean;
}

export interface ContainerRuntimePolicyReadonlyFiles {
    enabled?: boolean;
    exceptionalReadonlyFiles?: string[];
    exceptionalReadonlyFilesProcesses?: string[];
    exceptionalReadonlyFilesUsers?: string[];
    readonlyFiles?: string[];
    readonlyFilesProcesses?: string[];
    readonlyFilesUsers?: string[];
}

export interface ContainerRuntimePolicyReadonlyRegistry {
    enabled?: boolean;
    exceptionalReadonlyRegistryPaths?: string[];
    exceptionalReadonlyRegistryProcesses?: string[];
    exceptionalReadonlyRegistryUsers?: string[];
    readonlyRegistryPaths?: string[];
    readonlyRegistryProcesses?: string[];
    readonlyRegistryUsers?: string[];
}

export interface ContainerRuntimePolicyRegistryAccessMonitoring {
    enabled?: boolean;
    exceptionalMonitoredRegistryPaths?: string[];
    exceptionalMonitoredRegistryProcesses?: string[];
    exceptionalMonitoredRegistryUsers?: string[];
    monitoredRegistryAttributes?: boolean;
    monitoredRegistryCreate?: boolean;
    monitoredRegistryDelete?: boolean;
    monitoredRegistryModify?: boolean;
    monitoredRegistryPaths?: string[];
    monitoredRegistryProcesses?: string[];
    monitoredRegistryRead?: boolean;
    monitoredRegistryUsers?: string[];
}

export interface ContainerRuntimePolicyRestrictedVolume {
    /**
     * Whether restricted volumes are enabled.
     */
    enabled?: boolean;
    /**
     * List of restricted volumes.
     */
    volumes?: string[];
}

export interface ContainerRuntimePolicyReverseShell {
    blockReverseShell?: boolean;
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
    reverseShellProcWhiteLists?: string[];
}

export interface ContainerRuntimePolicyScope {
    /**
     * Scope expression.
     */
    expression: string;
    /**
     * List of variables in the scope.
     */
    variables: outputs.ContainerRuntimePolicyScopeVariable[];
}

export interface ContainerRuntimePolicyScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Name assigned to the attribute.
     */
    name?: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface ContainerRuntimePolicySystemIntegrityProtection {
    auditSystemtimeChange?: boolean;
    enabled?: boolean;
    monitorAuditLogIntegrity?: boolean;
    windowsServicesMonitoring?: boolean;
}

export interface ContainerRuntimePolicyTripwire {
    applyOns?: string[];
    enabled?: boolean;
    serverlessApp?: string;
    userId?: string;
    userPassword?: string;
}

export interface ContainerRuntimePolicyWhitelistedOsUsers {
    enabled?: boolean;
    groupWhiteLists?: string[];
    userWhiteLists?: string[];
}

export interface EnforcerGroupsCommand {
    default: string;
    kubernetes: string;
    swarm: string;
    windows: string;
}

export interface EnforcerGroupsOrchestrator {
    master?: boolean;
    /**
     * May be specified for these orchestrators: Kubernetes, Kubernetes GKE, VMware Tanzu Kubernetes Grid Integrated Edition (PKS).
     */
    namespace?: string;
    /**
     * May be specified for these orchestrators: Kubernetes, Kubernetes GKE, OpenShift, VMware Tanzu Kubernetes Grid Integrated Edition (PKS).
     */
    serviceAccount?: string;
    type?: string;
}

export interface FirewallPolicyInboundNetwork {
    /**
     * Indicates whether the specified resources are allowed to pass in data or requests.
     */
    allow: boolean;
    /**
     * Range of ports affected by firewall.
     */
    portRange: string;
    /**
     * Information of the resource.
     */
    resource: string;
    /**
     * Type of the resource
     */
    resourceType: string;
}

export interface FirewallPolicyOutboundNetwork {
    /**
     * Indicates whether the specified resources are allowed to receive data or requests.
     */
    allow: boolean;
    /**
     * Range of ports affected by firewall.
     */
    portRange: string;
    /**
     * Information of the resource.
     */
    resource: string;
    /**
     * Type of the resource.
     */
    resourceType: string;
}

export interface FunctionAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType?: string;
    time?: string;
    weekDays: string[];
}

export interface FunctionAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author?: string;
    description?: string;
    engine?: string;
    lastModified?: number;
    name?: string;
    path?: string;
    readOnly?: boolean;
    scriptId?: string;
    severity?: string;
    snippet?: string;
}

export interface FunctionAssurancePolicyForbiddenLabel {
    key?: string;
    value?: string;
}

export interface FunctionAssurancePolicyKubernetesControl {
    avdId?: string;
    description?: string;
    enabled?: boolean;
    kind?: string;
    name?: string;
    ootb?: boolean;
    scriptId?: number;
    severity?: string;
}

export interface FunctionAssurancePolicyPackagesBlackList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface FunctionAssurancePolicyPackagesWhiteList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface FunctionAssurancePolicyPolicySettings {
    enforce?: boolean;
    isAuditChecked?: boolean;
    warn?: boolean;
    warningMessage?: string;
}

export interface FunctionAssurancePolicyRequiredLabel {
    key?: string;
    value?: string;
}

export interface FunctionAssurancePolicyScope {
    expression: string;
    variables?: outputs.FunctionAssurancePolicyScopeVariable[];
}

export interface FunctionAssurancePolicyScopeVariable {
    attribute: string;
    name?: string;
    value: string;
}

export interface FunctionAssurancePolicyTrustedBaseImage {
    imagename?: string;
    registry?: string;
}

export interface FunctionRuntimePolicyAllowedExecutable {
    /**
     * List of allowed executables.
     */
    allowExecutables?: string[];
    /**
     * List of allowed root executables.
     */
    allowRootExecutables?: string[];
    /**
     * Whether allowed executables configuration is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to treat executables separately.
     */
    separateExecutables?: boolean;
}

export interface FunctionRuntimePolicyAllowedRegistry {
    /**
     * List of allowed registries.
     */
    allowedRegistries?: string[];
    /**
     * Whether allowed registries are enabled.
     */
    enabled?: boolean;
}

export interface FunctionRuntimePolicyAuditing {
    auditAllNetwork?: boolean;
    auditAllProcesses?: boolean;
    auditFailedLogin?: boolean;
    auditOsUserActivity?: boolean;
    auditProcessCmdline?: boolean;
    auditSuccessLogin?: boolean;
    auditUserAccountManagement?: boolean;
    enabled?: boolean;
}

export interface FunctionRuntimePolicyBlacklistedOsUsers {
    enabled?: boolean;
    groupBlackLists?: string[];
    userBlackLists?: string[];
}

export interface FunctionRuntimePolicyBypassScope {
    /**
     * Whether bypassing the scope is enabled.
     */
    enabled?: boolean;
    /**
     * Scope configuration.
     */
    scopes?: outputs.FunctionRuntimePolicyBypassScopeScope[];
}

export interface FunctionRuntimePolicyBypassScopeScope {
    /**
     * Scope expression.
     */
    expression?: string;
    /**
     * List of variables in the scope.
     */
    variables?: outputs.FunctionRuntimePolicyBypassScopeScopeVariable[];
}

export interface FunctionRuntimePolicyBypassScopeScopeVariable {
    /**
     * Variable attribute.
     */
    attribute?: string;
    /**
     * Variable value.
     */
    value?: string;
}

export interface FunctionRuntimePolicyContainerExec {
    blockContainerExec?: boolean;
    containerExecProcWhiteLists?: string[];
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
}

export interface FunctionRuntimePolicyDriftPrevention {
    /**
     * Whether drift prevention is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to lockdown execution drift.
     */
    execLockdown?: boolean;
    /**
     * List of items in the execution lockdown white list.
     */
    execLockdownWhiteLists?: string[];
    /**
     * Whether to lockdown image drift.
     */
    imageLockdown?: boolean;
}

export interface FunctionRuntimePolicyExecutableBlacklist {
    /**
     * Whether the executable blacklist is enabled.
     */
    enabled?: boolean;
    /**
     * List of blacklisted executables.
     */
    executables?: string[];
}

export interface FunctionRuntimePolicyFailedKubernetesChecks {
    enabled?: boolean;
    failedChecks?: string[];
}

export interface FunctionRuntimePolicyFileBlock {
    blockFilesProcesses?: string[];
    blockFilesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockFiles?: string[];
    exceptionalBlockFilesProcesses?: string[];
    exceptionalBlockFilesUsers?: string[];
    filenameBlockLists?: string[];
}

export interface FunctionRuntimePolicyFileIntegrityMonitoring {
    /**
     * If true, file integrity monitoring is enabled.
     */
    enabled?: boolean;
    /**
     * List of paths to be excluded from monitoring.
     */
    exceptionalMonitoredFiles?: string[];
    /**
     * List of processes to be excluded from monitoring.
     */
    exceptionalMonitoredFilesProcesses?: string[];
    /**
     * List of users to be excluded from monitoring.
     */
    exceptionalMonitoredFilesUsers?: string[];
    /**
     * List of paths to be monitored.
     */
    monitoredFiles?: string[];
    /**
     * Whether to monitor file attribute operations.
     */
    monitoredFilesAttributes?: boolean;
    /**
     * Whether to monitor file create operations.
     */
    monitoredFilesCreate?: boolean;
    /**
     * Whether to monitor file delete operations.
     */
    monitoredFilesDelete?: boolean;
    /**
     * Whether to monitor file modify operations.
     */
    monitoredFilesModify?: boolean;
    /**
     * List of processes associated with monitored files.
     */
    monitoredFilesProcesses?: string[];
    /**
     * Whether to monitor file read operations.
     */
    monitoredFilesRead?: boolean;
    /**
     * List of users associated with monitored files.
     */
    monitoredFilesUsers?: string[];
}

export interface FunctionRuntimePolicyLimitContainerPrivilege {
    /**
     * Whether to block adding capabilities.
     */
    blockAddCapabilities?: boolean;
    /**
     * Whether container privilege limitations are enabled.
     */
    enabled?: boolean;
    /**
     * Whether to limit IPC-related capabilities.
     */
    ipcmode?: boolean;
    /**
     * Whether to limit network-related capabilities.
     */
    netmode?: boolean;
    /**
     * Whether to limit process-related capabilities.
     */
    pidmode?: boolean;
    /**
     * Whether to prevent low port binding.
     */
    preventLowPortBinding?: boolean;
    /**
     * Whether to prevent the use of the root user.
     */
    preventRootUser?: boolean;
    /**
     * Whether the container is run in privileged mode.
     */
    privileged?: boolean;
    /**
     * Whether to use the host user.
     */
    useHostUser?: boolean;
    /**
     * Whether to limit user-related capabilities.
     */
    usermode?: boolean;
    /**
     * Whether to limit UTS-related capabilities.
     */
    utsmode?: boolean;
}

export interface FunctionRuntimePolicyLinuxCapabilities {
    enabled?: boolean;
    removeLinuxCapabilities?: string[];
}

export interface FunctionRuntimePolicyMalwareScanOptions {
    /**
     * Set Action, Defaults to 'Alert' when empty
     */
    action?: string;
    /**
     * Defines if enabled or not
     */
    enabled?: boolean;
    /**
     * List of registry paths to be excluded from being protected.
     */
    excludeDirectories?: string[];
    /**
     * List of registry processes to be excluded from being protected.
     */
    excludeProcesses?: string[];
    /**
     * List of registry paths to be excluded from being protected.
     */
    includeDirectories?: string[];
}

export interface FunctionRuntimePolicyPackageBlock {
    blockPackagesProcesses?: string[];
    blockPackagesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockPackagesFiles?: string[];
    exceptionalBlockPackagesProcesses?: string[];
    exceptionalBlockPackagesUsers?: string[];
    packagesBlackLists?: string[];
}

export interface FunctionRuntimePolicyPortBlock {
    blockInboundPorts?: string[];
    blockOutboundPorts?: string[];
    enabled?: boolean;
}

export interface FunctionRuntimePolicyReadonlyFiles {
    enabled?: boolean;
    exceptionalReadonlyFiles?: string[];
    exceptionalReadonlyFilesProcesses?: string[];
    exceptionalReadonlyFilesUsers?: string[];
    readonlyFiles?: string[];
    readonlyFilesProcesses?: string[];
    readonlyFilesUsers?: string[];
}

export interface FunctionRuntimePolicyReadonlyRegistry {
    enabled?: boolean;
    exceptionalReadonlyRegistryPaths?: string[];
    exceptionalReadonlyRegistryProcesses?: string[];
    exceptionalReadonlyRegistryUsers?: string[];
    readonlyRegistryPaths?: string[];
    readonlyRegistryProcesses?: string[];
    readonlyRegistryUsers?: string[];
}

export interface FunctionRuntimePolicyRegistryAccessMonitoring {
    enabled?: boolean;
    exceptionalMonitoredRegistryPaths?: string[];
    exceptionalMonitoredRegistryProcesses?: string[];
    exceptionalMonitoredRegistryUsers?: string[];
    monitoredRegistryAttributes?: boolean;
    monitoredRegistryCreate?: boolean;
    monitoredRegistryDelete?: boolean;
    monitoredRegistryModify?: boolean;
    monitoredRegistryPaths?: string[];
    monitoredRegistryProcesses?: string[];
    monitoredRegistryRead?: boolean;
    monitoredRegistryUsers?: string[];
}

export interface FunctionRuntimePolicyRestrictedVolume {
    /**
     * Whether restricted volumes are enabled.
     */
    enabled?: boolean;
    /**
     * List of restricted volumes.
     */
    volumes?: string[];
}

export interface FunctionRuntimePolicyReverseShell {
    blockReverseShell?: boolean;
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
    reverseShellProcWhiteLists?: string[];
}

export interface FunctionRuntimePolicyScope {
    /**
     * Scope expression.
     */
    expression: string;
    /**
     * List of variables in the scope.
     */
    variables: outputs.FunctionRuntimePolicyScopeVariable[];
}

export interface FunctionRuntimePolicyScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Name assigned to the attribute.
     */
    name?: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface FunctionRuntimePolicySystemIntegrityProtection {
    auditSystemtimeChange?: boolean;
    enabled?: boolean;
    monitorAuditLogIntegrity?: boolean;
    windowsServicesMonitoring?: boolean;
}

export interface FunctionRuntimePolicyTripwire {
    applyOns?: string[];
    enabled?: boolean;
    serverlessApp?: string;
    userId?: string;
    userPassword?: string;
}

export interface FunctionRuntimePolicyWhitelistedOsUsers {
    enabled?: boolean;
    groupWhiteLists?: string[];
    userWhiteLists?: string[];
}

export interface GetAcknowledgesAcknowledge {
    /**
     * The user who acknowledged the issue.
     */
    author: string;
    /**
     * A comment describing the reason for the acknowledgment
     */
    comment: string;
    /**
     * The date and time of the acknowledgment.
     */
    date: string;
    dockerId: string;
    /**
     * The current dat and time when the expiration was set
     */
    expirationConfiguredAt: string;
    /**
     * The user who set the expiration of the issue.
     */
    expirationConfiguredBy: string;
    /**
     * Number of days until expiration of the acknowledgement. The value must be integer from 1 to 999, inclusive.
     */
    expirationDays: number;
    /**
     * The version of the package that having a fix for the issue.
     */
    fixVersion: string;
    /**
     * Only acknowledge the issue in the context of the specified image (also requires 'registry_name')
     */
    imageName: string;
    /**
     * The name of the security issue (the CVE or security advisory for vulnerabilities, name of malware or type of sensitive data)
     */
    issueName: string;
    /**
     * The type of the security issue (either 'vulnerability', 'sensitive_data' or 'malware')
     */
    issueType: string;
    /**
     * When the resourceType is 'package', the operating system is required (e.g., 'ubuntu', 'alpine').
     */
    os: string;
    /**
     * When the resourceType is 'package', the operating system version is required.
     */
    osVersion: string;
    /**
     * The permissions of the user who acknowledged the issue.
     */
    permission: string;
    /**
     * Only acknowledge the issue in the context of the specified repository (also requires 'registry_name').
     */
    registryName: string;
    /**
     * The CPE of the resource as listed in the issue by the Aqua API. This is required for resources of type 'executable'. For packages and files, the next parameters can be specified instead.
     */
    resourceCpe: string;
    /**
     * The format of the resource.
     */
    resourceFormat: string;
    /**
     * When the resourceType is 'file', the hash of the file is required
     */
    resourceHash: string;
    /**
     * When the resourceType is 'package', the name of the package is required.
     */
    resourceName: string;
    /**
     * The path of the resource. This is required for resources of type 'file' and 'executable'.
     */
    resourcePath: string;
    /**
     * The type of the resource where the issue was detected (either 'package', 'file' or 'executable')
     */
    resourceType: string;
    /**
     * When the resourceType is 'package', the version of the package is required
     */
    resourceVersion: string;
}

export interface GetApplicationScopeCategory {
    artifacts?: outputs.GetApplicationScopeCategoryArtifact[];
    entityScopes?: outputs.GetApplicationScopeCategoryEntityScope[];
    infrastructures?: outputs.GetApplicationScopeCategoryInfrastructure[];
    workloads?: outputs.GetApplicationScopeCategoryWorkload[];
}

export interface GetApplicationScopeCategoryArtifact {
    cfs?: outputs.GetApplicationScopeCategoryArtifactCf[];
    functions?: outputs.GetApplicationScopeCategoryArtifactFunction[];
    images?: outputs.GetApplicationScopeCategoryArtifactImage[];
}

export interface GetApplicationScopeCategoryArtifactCf {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryArtifactCfVariable[];
}

export interface GetApplicationScopeCategoryArtifactCfVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryArtifactFunction {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryArtifactFunctionVariable[];
}

export interface GetApplicationScopeCategoryArtifactFunctionVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryArtifactImage {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryArtifactImageVariable[];
}

export interface GetApplicationScopeCategoryArtifactImageVariable {
    attribute?: string;
    value?: string;
}

export interface GetApplicationScopeCategoryEntityScope {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryEntityScopeVariable[];
}

export interface GetApplicationScopeCategoryEntityScopeVariable {
    attribute: string;
    value: string;
}

export interface GetApplicationScopeCategoryInfrastructure {
    kubernetes?: outputs.GetApplicationScopeCategoryInfrastructureKubernete[];
    os?: outputs.GetApplicationScopeCategoryInfrastructureO[];
}

export interface GetApplicationScopeCategoryInfrastructureKubernete {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryInfrastructureKuberneteVariable[];
}

export interface GetApplicationScopeCategoryInfrastructureKuberneteVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryInfrastructureO {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryInfrastructureOVariable[];
}

export interface GetApplicationScopeCategoryInfrastructureOVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryWorkload {
    cfs?: outputs.GetApplicationScopeCategoryWorkloadCf[];
    kubernetes?: outputs.GetApplicationScopeCategoryWorkloadKubernete[];
    os?: outputs.GetApplicationScopeCategoryWorkloadO[];
}

export interface GetApplicationScopeCategoryWorkloadCf {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryWorkloadCfVariable[];
}

export interface GetApplicationScopeCategoryWorkloadCfVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryWorkloadKubernete {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryWorkloadKuberneteVariable[];
}

export interface GetApplicationScopeCategoryWorkloadKuberneteVariable {
    attribute: string;
    value?: string;
}

export interface GetApplicationScopeCategoryWorkloadO {
    expression: string;
    variables?: outputs.GetApplicationScopeCategoryWorkloadOVariable[];
}

export interface GetApplicationScopeCategoryWorkloadOVariable {
    attribute: string;
    value?: string;
}

export interface GetAquaLabelsAquaLabel {
    /**
     * The name of the user who created the Aqua label.
     */
    author: string;
    /**
     * The creation date of the Aqua label.
     */
    created: string;
    /**
     * Aqua label description.
     */
    description: string;
    /**
     * Aqua label name.
     */
    name: string;
}

export interface GetContainerRuntimePolicyAllowedExecutable {
    /**
     * List of allowed executables.
     */
    allowExecutables?: string[];
    /**
     * List of allowed root executables.
     */
    allowRootExecutables?: string[];
    /**
     * Whether allowed executables configuration is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to treat executables separately.
     */
    separateExecutables?: boolean;
}

export interface GetContainerRuntimePolicyAllowedRegistry {
    /**
     * List of allowed registries.
     */
    allowedRegistries?: string[];
    /**
     * Whether allowed registries are enabled.
     */
    enabled?: boolean;
}

export interface GetContainerRuntimePolicyAuditing {
    auditAllNetwork?: boolean;
    auditAllProcesses?: boolean;
    auditFailedLogin?: boolean;
    auditOsUserActivity?: boolean;
    auditProcessCmdline?: boolean;
    auditSuccessLogin?: boolean;
    auditUserAccountManagement?: boolean;
    enabled?: boolean;
}

export interface GetContainerRuntimePolicyContainerExec {
    blockContainerExec?: boolean;
    containerExecProcWhiteLists?: string[];
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
}

export interface GetContainerRuntimePolicyFileBlock {
    blockFilesProcesses?: string[];
    blockFilesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockFiles?: string[];
    exceptionalBlockFilesProcesses?: string[];
    exceptionalBlockFilesUsers?: string[];
    filenameBlockLists?: string[];
}

export interface GetContainerRuntimePolicyFileIntegrityMonitoring {
    /**
     * If true, file integrity monitoring is enabled.
     */
    enabled?: boolean;
    /**
     * List of paths to be excluded from monitoring.
     */
    exceptionalMonitoredFiles?: string[];
    /**
     * List of processes to be excluded from monitoring.
     */
    exceptionalMonitoredFilesProcesses?: string[];
    /**
     * List of users to be excluded from monitoring.
     */
    exceptionalMonitoredFilesUsers?: string[];
    /**
     * List of paths to be monitored.
     */
    monitoredFiles?: string[];
    /**
     * Whether to monitor file attribute operations.
     */
    monitoredFilesAttributes?: boolean;
    /**
     * Whether to monitor file create operations.
     */
    monitoredFilesCreate?: boolean;
    /**
     * Whether to monitor file delete operations.
     */
    monitoredFilesDelete?: boolean;
    /**
     * Whether to monitor file modify operations.
     */
    monitoredFilesModify?: boolean;
    /**
     * List of processes associated with monitored files.
     */
    monitoredFilesProcesses?: string[];
    /**
     * Whether to monitor file read operations.
     */
    monitoredFilesRead?: boolean;
    /**
     * List of users associated with monitored files.
     */
    monitoredFilesUsers?: string[];
}

export interface GetContainerRuntimePolicyLimitContainerPrivilege {
    /**
     * Whether to block adding capabilities.
     */
    blockAddCapabilities?: boolean;
    /**
     * Whether container privilege limitations are enabled.
     */
    enabled?: boolean;
    /**
     * Whether to limit IPC-related capabilities.
     */
    ipcmode?: boolean;
    /**
     * Whether to limit network-related capabilities.
     */
    netmode?: boolean;
    /**
     * Whether to limit process-related capabilities.
     */
    pidmode?: boolean;
    /**
     * Whether to prevent low port binding.
     */
    preventLowPortBinding?: boolean;
    /**
     * Whether to prevent the use of the root user.
     */
    preventRootUser?: boolean;
    /**
     * Whether the container is run in privileged mode.
     */
    privileged?: boolean;
    /**
     * Whether to use the host user.
     */
    useHostUser?: boolean;
    /**
     * Whether to limit user-related capabilities.
     */
    usermode?: boolean;
    /**
     * Whether to limit UTS-related capabilities.
     */
    utsmode?: boolean;
}

export interface GetContainerRuntimePolicyMalwareScanOption {
    /**
     * Set Action, Defaults to 'Alert' when empty
     */
    action?: string;
    /**
     * Defines if enabled or not
     */
    enabled?: boolean;
    /**
     * List of registry paths to be excluded from being protected.
     */
    excludeDirectories?: string[];
    /**
     * List of registry processes to be excluded from being protected.
     */
    excludeProcesses?: string[];
    /**
     * List of registry paths to be excluded from being protected.
     */
    includeDirectories?: string[];
}

export interface GetContainerRuntimePolicyPortBlock {
    blockInboundPorts?: string[];
    blockOutboundPorts?: string[];
    enabled?: boolean;
}

export interface GetContainerRuntimePolicyReadonlyFiles {
    enabled?: boolean;
    exceptionalReadonlyFiles?: string[];
    exceptionalReadonlyFilesProcesses?: string[];
    exceptionalReadonlyFilesUsers?: string[];
    readonlyFiles?: string[];
    readonlyFilesProcesses?: string[];
    readonlyFilesUsers?: string[];
}

export interface GetContainerRuntimePolicyRestrictedVolume {
    /**
     * Whether restricted volumes are enabled.
     */
    enabled?: boolean;
    /**
     * List of restricted volumes.
     */
    volumes?: string[];
}

export interface GetContainerRuntimePolicyScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Name assigned to the attribute.
     */
    name: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface GetEnforcerGroupsCommand {
    default: string;
    kubernetes: string;
    swarm: string;
    windows: string;
}

export interface GetEnforcerGroupsOrchestrator {
    master: boolean;
    /**
     * May be specified for these orchestrators: Kubernetes, Kubernetes GKE, VMware Tanzu Kubernetes Grid Integrated Edition (PKS).
     */
    namespace: string;
    /**
     * May be specified for these orchestrators: Kubernetes, Kubernetes GKE, OpenShift, VMware Tanzu Kubernetes Grid Integrated Edition (PKS).
     */
    serviceAccount: string;
    type: string;
}

export interface GetFirewallPolicyInboundNetwork {
    /**
     * Indicates whether the specified resources are allowed to pass in data or requests.
     */
    allow: boolean;
    /**
     * Range of ports affected by firewall.
     */
    portRange: string;
    /**
     * Information of the resource.
     */
    resource: string;
    /**
     * Type of the resource
     */
    resourceType: string;
}

export interface GetFirewallPolicyOutboundNetwork {
    /**
     * Indicates whether the specified resources are allowed to receive data or requests.
     */
    allow: boolean;
    /**
     * Range of ports affected by firewall.
     */
    portRange: string;
    /**
     * Information of the resource.
     */
    resource: string;
    /**
     * Type of the resource.
     */
    resourceType: string;
}

export interface GetFunctionAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType: string;
    time: string;
    weekDays: string[];
}

export interface GetFunctionAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author: string;
    description: string;
    engine: string;
    lastModified: number;
    name: string;
    path: string;
    readOnly: boolean;
    scriptId: string;
    severity: string;
    snippet: string;
}

export interface GetFunctionAssurancePolicyForbiddenLabel {
    key: string;
    value: string;
}

export interface GetFunctionAssurancePolicyPackagesBlackList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetFunctionAssurancePolicyPackagesWhiteList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetFunctionAssurancePolicyRequiredLabel {
    key: string;
    value: string;
}

export interface GetFunctionAssurancePolicyScope {
    expression: string;
    variables?: outputs.GetFunctionAssurancePolicyScopeVariable[];
}

export interface GetFunctionAssurancePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetFunctionAssurancePolicyTrustedBaseImage {
    imagename: string;
    registry: string;
}

export interface GetFunctionRuntimePolicyDriftPrevention {
    /**
     * Whether drift prevention is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to lockdown execution drift.
     */
    execLockdown?: boolean;
    /**
     * List of items in the execution lockdown white list.
     */
    execLockdownWhiteLists?: string[];
    /**
     * Whether to lockdown image drift.
     */
    imageLockdown?: boolean;
}

export interface GetFunctionRuntimePolicyExecutableBlacklist {
    /**
     * Whether the executable blacklist is enabled.
     */
    enabled?: boolean;
    /**
     * List of blacklisted executables.
     */
    executables?: string[];
}

export interface GetFunctionRuntimePolicyScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Name assigned to the attribute.
     */
    name: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface GetGatewaysGateway {
    /**
     * The description of the gateway.
     */
    description: string;
    /**
     * The GRPC address of the gateway.
     */
    grpcAddress: string;
    /**
     * The name of the gateway's host.
     */
    hostname: string;
    /**
     * The ID of the gateway (for example: 8522744b25e2_gateway)
     */
    id: string;
    /**
     * The logical name of the gateway (for example: 8522744b25e2)
     */
    logicalname: string;
    /**
     * The public IP address of the gateway.
     */
    publicAddress: string;
    /**
     * The status of the gateway.
     */
    status: string;
    /**
     * The version of the gateway.
     */
    version: string;
}

export interface GetGroupsGroup {
    /**
     * The creation date of the group.
     */
    created: string;
    /**
     * The ID of the created group.
     */
    groupId: string;
    /**
     * The desired name of the group.
     */
    name: string;
}

export interface GetHostAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType: string;
    time: string;
    weekDays: string[];
}

export interface GetHostAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author: string;
    description: string;
    engine: string;
    lastModified: number;
    name: string;
    path: string;
    readOnly: boolean;
    scriptId: string;
    severity: string;
    snippet: string;
}

export interface GetHostAssurancePolicyForbiddenLabel {
    key: string;
    value: string;
}

export interface GetHostAssurancePolicyPackagesBlackList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetHostAssurancePolicyPackagesWhiteList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetHostAssurancePolicyRequiredLabel {
    key: string;
    value: string;
}

export interface GetHostAssurancePolicyScope {
    expression: string;
    variables?: outputs.GetHostAssurancePolicyScopeVariable[];
}

export interface GetHostAssurancePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetHostAssurancePolicyTrustedBaseImage {
    imagename: string;
    registry: string;
}

export interface GetHostRuntimePolicyAuditing {
    auditAllNetwork?: boolean;
    auditAllProcesses?: boolean;
    auditFailedLogin?: boolean;
    auditOsUserActivity?: boolean;
    auditProcessCmdline?: boolean;
    auditSuccessLogin?: boolean;
    auditUserAccountManagement?: boolean;
    enabled?: boolean;
}

export interface GetHostRuntimePolicyFileIntegrityMonitoring {
    /**
     * If true, file integrity monitoring is enabled.
     */
    enabled?: boolean;
    /**
     * List of paths to be excluded from monitoring.
     */
    exceptionalMonitoredFiles?: string[];
    /**
     * List of processes to be excluded from monitoring.
     */
    exceptionalMonitoredFilesProcesses?: string[];
    /**
     * List of users to be excluded from monitoring.
     */
    exceptionalMonitoredFilesUsers?: string[];
    /**
     * List of paths to be monitored.
     */
    monitoredFiles?: string[];
    /**
     * Whether to monitor file attribute operations.
     */
    monitoredFilesAttributes?: boolean;
    /**
     * Whether to monitor file create operations.
     */
    monitoredFilesCreate?: boolean;
    /**
     * Whether to monitor file delete operations.
     */
    monitoredFilesDelete?: boolean;
    /**
     * Whether to monitor file modify operations.
     */
    monitoredFilesModify?: boolean;
    /**
     * List of processes associated with monitored files.
     */
    monitoredFilesProcesses?: string[];
    /**
     * Whether to monitor file read operations.
     */
    monitoredFilesRead?: boolean;
    /**
     * List of users associated with monitored files.
     */
    monitoredFilesUsers?: string[];
}

export interface GetHostRuntimePolicyMalwareScanOption {
    /**
     * Set Action, Defaults to 'Alert' when empty
     */
    action?: string;
    /**
     * Defines if enabled or not
     */
    enabled?: boolean;
    /**
     * List of registry paths to be excluded from being protected.
     */
    excludeDirectories?: string[];
    /**
     * List of registry processes to be excluded from being protected.
     */
    excludeProcesses?: string[];
    /**
     * List of registry paths to be excluded from being protected.
     */
    includeDirectories?: string[];
}

export interface GetHostRuntimePolicyPackageBlock {
    blockPackagesProcesses?: string[];
    blockPackagesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockPackagesFiles?: string[];
    exceptionalBlockPackagesProcesses?: string[];
    exceptionalBlockPackagesUsers?: string[];
    packagesBlackLists?: string[];
}

export interface GetHostRuntimePolicyScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Name assigned to the attribute.
     */
    name: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface GetHostRuntimePolicyWindowsRegistryMonitoring {
    /**
     * List of paths to be excluded from being monitored.
     */
    excludedPaths: string[];
    /**
     * List of registry processes to be excluded from being monitored.
     */
    excludedProcesses: string[];
    /**
     * List of registry users to be excluded from being monitored.
     */
    excludedUsers: string[];
    /**
     * If true, add attributes operations will be monitored.
     */
    monitorAttributes: boolean;
    /**
     * If true, create operations will be monitored.
     */
    monitorCreate: boolean;
    /**
     * If true, deletion operations will be monitored.
     */
    monitorDelete: boolean;
    /**
     * If true, modification operations will be monitored.
     */
    monitorModify: boolean;
    /**
     * If true, read operations will be monitored.
     */
    monitorRead: boolean;
    /**
     * List of paths to be monitored.
     */
    monitoredPaths: string[];
    /**
     * List of registry processes to be monitored.
     */
    monitoredProcesses: string[];
    /**
     * List of registry users to be monitored.
     */
    monitoredUsers: string[];
}

export interface GetHostRuntimePolicyWindowsRegistryProtection {
    /**
     * List of registry paths to be excluded from being protected.
     */
    excludedPaths: string[];
    /**
     * List of registry processes to be excluded from being protected.
     */
    excludedProcesses: string[];
    /**
     * List of registry paths to be users from being protected.
     */
    excludedUsers: string[];
    /**
     * List of registry paths to be protected.
     */
    protectedPaths: string[];
    /**
     * List of registry processes to be protected.
     */
    protectedProcesses: string[];
    /**
     * List of registry users to be protected.
     */
    protectedUsers: string[];
}

export interface GetImageAssuranceChecksPerformed {
    /**
     * The type of the Assurance Policy the check originated from.
     */
    assuranceType: string;
    /**
     * Whether the check is blocking (i.e. a failure should trigger a disallow).
     */
    blocking: boolean;
    /**
     * The name of the image assurance control.
     */
    control: string;
    /**
     * If DTA was skipped.
     */
    dtaSkipped: boolean;
    /**
     * The reason why DTA was skipped.
     */
    dtaSkippedReason: string;
    /**
     * Whether the image failed the check.
     */
    failed: boolean;
    /**
     * The name of the Image Assurance Policy the check originated from.
     */
    policyName: string;
}

export interface GetImageAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType: string;
    time: string;
    weekDays: string[];
}

export interface GetImageAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author: string;
    description: string;
    engine: string;
    lastModified: number;
    name: string;
    path: string;
    readOnly: boolean;
    scriptId: string;
    severity: string;
    snippet: string;
}

export interface GetImageAssurancePolicyForbiddenLabel {
    key: string;
    value: string;
}

export interface GetImageAssurancePolicyPackagesBlackList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetImageAssurancePolicyPackagesWhiteList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetImageAssurancePolicyRequiredLabel {
    key: string;
    value: string;
}

export interface GetImageAssurancePolicyScope {
    expression: string;
    variables?: outputs.GetImageAssurancePolicyScopeVariable[];
}

export interface GetImageAssurancePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetImageAssurancePolicyTrustedBaseImage {
    imagename: string;
    registry: string;
}

export interface GetImageHistory {
    /**
     * The commit comment for the image, if any.
     */
    comment: string;
    /**
     * The date of creation of the layer.
     */
    created: string;
    /**
     * The command that generated the layer.
     */
    createdBy: string;
    /**
     * The image ID of the layer (if any).
     */
    id: string;
    /**
     * The size of the image.
     */
    size: number;
}

export interface GetImageVulnerability {
    ackAuthor: string;
    ackComment: string;
    ackExpirationConfiguredAt: string;
    ackExpirationConfiguredBy: string;
    ackExpirationDays: number;
    ackScope: string;
    acknowledgeDate: string;
    /**
     * The ancestor of this package.
     */
    ancestorPkg: string;
    /**
     * The score generated for the vulnerability by Aqua.
     */
    aquaScore: number;
    /**
     * Score classification by Aqua.
     */
    aquaScoreClassification: string;
    /**
     * The score system for the vulnerability by Aqua
     */
    aquaScoringSystem: string;
    /**
     * The severity generated for the vulnerability by Aqua.
     */
    aquaSeverity: string;
    /**
     * Classification of the severity defined by Aqua.
     */
    aquaSeverityClassification: string;
    /**
     * The vectors generated for the vulnerability by Aqua
     */
    aquaVectors: string;
    /**
     * Number of audit events.
     */
    auditEventsCount: number;
    /**
     * Number of blocked events.
     */
    blockEventsCount: number;
    /**
     * Classification of the vulnerability.
     */
    classification: string;
    /**
     * The description of the vulnerability.
     */
    description: string;
    /**
     * The content digest of the image.
     */
    digest: string;
    /**
     * Reference of the exploit.
     */
    exploitReference: string;
    /**
     * Type of the exploit.
     */
    exploitType: string;
    /**
     * The date when this vulnerability was first found.
     */
    firstFoundDate: string;
    /**
     * Fixed version of the resource.
     */
    fixVersion: string;
    /**
     * Name of the image.
     */
    imageName: string;
    /**
     * The date when this vulnerability was last found.
     */
    lastFoundDate: string;
    /**
     * Thhe date when this vulnerability was modified.
     */
    modificationDate: string;
    /**
     * The name of the vulnerability.
     */
    name: string;
    /**
     * CVSS2 score by NVD
     */
    nvdCvss2Score: number;
    /**
     * CVSS2 vectors by NVD
     */
    nvdCvss2Vectors: string;
    /**
     * CVSS3 score by NVD
     */
    nvdCvss3Score: number;
    /**
     * CVSS3 severity by NVD
     */
    nvdCvss3Severity: string;
    /**
     * CVSS3 vectors by NVD
     */
    nvdCvss3Vectors: string;
    /**
     * Type of the severity identified by NVD.
     */
    nvdSeverity: string;
    /**
     * URL of the details of this vulnerability by NVD.
     */
    nvdUrl: string;
    /**
     * Name of the Operating System.
     */
    os: string;
    /**
     * The version of the OS.
     */
    osVersion: string;
    /**
     * permission on the image
     */
    permission: string;
    /**
     * The date this vulnerability was published.
     */
    publishDate: string;
    /**
     * Registry of the image.
     */
    registry: string;
    /**
     * Repository of the image.
     */
    repository: string;
    /**
     * Architecture of the resource.
     */
    resourceArchitecture: string;
    /**
     * Common Platform Enumeration (CPE) of the resource.
     */
    resourceCpe: string;
    /**
     * Code format of the resource (java, apk etc.).
     */
    resourceFormat: string;
    /**
     * Hash of the resource.
     */
    resourceHash: string;
    /**
     * List of license supported by the resource.
     */
    resourceLicenses: string[];
    /**
     * Name of the resource.
     */
    resourceName: string;
    /**
     * Path of the resource.
     */
    resourcePath: string;
    /**
     * Type of the resource
     */
    resourceType: string;
    /**
     * Version of the resource.
     */
    resourceVersion: string;
    /**
     * Classification of the severity.
     */
    severityClassification: string;
    /**
     * Solution for the vulnerability.
     */
    solution: string;
    temporalVector: string;
    vPatchAppliedBy: string;
    vPatchAppliedOn: string;
    vPatchEnforcedBy: string;
    vPatchEnforcedOn: string;
    vPatchPolicyEnforce: boolean;
    vPatchPolicyName: string;
    vPatchRevertedBy: string;
    vPatchRevertedOn: string;
    vPatchStatus: string;
    vendorCvss2Score: number;
    vendorCvss2Vectors: string;
    vendorSeverity: string;
    vendorStatement: string;
    vendorUrl: string;
}

export interface GetIntegrationRegistriesOption {
    option?: string;
    value?: string;
}

export interface GetIntegrationRegistriesWebhook {
    authToken?: string;
    enabled?: boolean;
    unQuarantine?: boolean;
    url?: string;
}

export interface GetIntegrationRegistryOption {
    option?: string;
    value?: string;
}

export interface GetIntegrationRegistryWebhook {
    authToken?: string;
    enabled?: boolean;
    unQuarantine?: boolean;
    url?: string;
}

export interface GetKubernetesAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType: string;
    time: string;
    weekDays: string[];
}

export interface GetKubernetesAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author: string;
    description: string;
    engine: string;
    lastModified: number;
    name: string;
    path: string;
    readOnly: boolean;
    scriptId: string;
    severity: string;
    snippet: string;
}

export interface GetKubernetesAssurancePolicyForbiddenLabel {
    key: string;
    value: string;
}

export interface GetKubernetesAssurancePolicyPackagesBlackList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetKubernetesAssurancePolicyPackagesWhiteList {
    arch: string;
    display: string;
    epoch: string;
    format: string;
    license: string;
    name: string;
    release: string;
    version: string;
    versionRange: string;
}

export interface GetKubernetesAssurancePolicyRequiredLabel {
    key: string;
    value: string;
}

export interface GetKubernetesAssurancePolicyScope {
    expression: string;
    variables?: outputs.GetKubernetesAssurancePolicyScopeVariable[];
}

export interface GetKubernetesAssurancePolicyScopeVariable {
    attribute: string;
    name: string;
    value: string;
}

export interface GetKubernetesAssurancePolicyTrustedBaseImage {
    imagename: string;
    registry: string;
}

export interface GetNotificationsEmail {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetNotificationsJira {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetNotificationsServicenow {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetNotificationsSlack {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetNotificationsSplunk {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetNotificationsTeam {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetNotificationsWebhook {
    author: string;
    id: number;
    lastUpdated: string;
    name: string;
    properties: {[key: string]: string};
    template: {[key: string]: string};
    type: string;
}

export interface GetPermissionsSetsPermissionsSet {
    /**
     * List of allowed actions for the Permission Set (not relevant if 'is_super' is true).
     */
    actions: string[];
    /**
     * The name of the user who created the Permission Set.
     */
    author: string;
    /**
     * Free text description for the Permission Set.
     */
    description: string;
    /**
     * Give the Permission Set full access, meaning all actions are allowed without restriction.
     */
    isSuper: boolean;
    /**
     * The name of the Permission Set, comprised of alphanumeric characters and '-', '_', ' ', ':', '.', '@', '!', '^'.
     */
    name: string;
    /**
     * Whether to allow UI access for users with this Permission Set.
     */
    uiAccess: boolean;
    /**
     * The date of the last modification of the Role.
     */
    updatedAt: string;
}

export interface GetRolesMappingLdap {
    /**
     * Role Mapping is used to define the IdP role that the user will assume in Aqua
     */
    roleMapping: {[key: string]: string};
}

export interface GetRolesMappingOauth2 {
    /**
     * Role Mapping is used to define the IdP role that the user will assume in Aqua
     */
    roleMapping: {[key: string]: string};
}

export interface GetRolesMappingOpenid {
    /**
     * Role Mapping is used to define the IdP role that the user will assume in Aqua
     */
    roleMapping: {[key: string]: string};
}

export interface GetRolesMappingSaasRolesMapping {
    accountId: number;
    created: string;
    cspRole: string;
    id: number;
    samlGroups: string[];
}

export interface GetRolesMappingSaml {
    /**
     * Role Mapping is used to define the IdP role that the user will assume in Aqua
     */
    roleMapping: {[key: string]: string};
}

export interface GetRolesRole {
    /**
     * Free text description for the role.
     */
    description: string;
    /**
     * The name of the role, comprised of alphanumeric characters and '-', '_', ' ', ':', '.', '@', '!', '^'.
     */
    name: string;
    /**
     * The name of the Permission Set that will affect the users assigned to this specific Role.
     */
    permission: string;
    /**
     * List of Application Scopes that will affect the users assigned to this specific Role.
     */
    scopes: string[];
    /**
     * The date of the last modification of the role.
     */
    updatedAt: string;
}

export interface GetServiceScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Name assigned to the attribute.
     */
    name: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface GetUsersSaasUser {
    accountAdmin: boolean;
    confirmed: boolean;
    created: string;
    cspRoles: string[];
    dashboard: boolean;
    email: string;
    groups: outputs.GetUsersSaasUserGroup[];
    logins: outputs.GetUsersSaasUserLogin[];
    multiaccount: boolean;
    passwordReset: boolean;
    provider: string;
    sendAnnouncements: boolean;
    sendNewPlugins: boolean;
    sendNewRisks: boolean;
    sendScanResults: boolean;
    userId: string;
}

export interface GetUsersSaasUserGroup {
    created: string;
    id: number;
    name: string;
}

export interface GetUsersSaasUserLogin {
    created: string;
    id: number;
    ipAddress: string;
    userId: number;
}

export interface GetUsersUser {
    /**
     * The user Email.
     */
    email: string;
    /**
     * If the user must change password at next login.
     */
    firstTime: boolean;
    /**
     * Give the Permission Set full access, meaning all actions are allowed without restriction.
     */
    isSuper: boolean;
    /**
     * The user name.
     */
    name: string;
    /**
     * User's Aqua plan (Developer / Team / Advanced).
     */
    plan: string;
    /**
     * The first role that assigned to the user for backward compatibility.
     */
    role: string;
    /**
     * The roles that will be assigned to the user.
     */
    roles: string[];
    /**
     * The user type (Aqua, LDAP, SAML, OAuth2, OpenID, Tenant Manager).
     */
    type: string;
    /**
     * Whether to allow UI access for users with this Permission Set.
     */
    uiAccess: boolean;
    /**
     * The user ID.
     */
    userId: string;
}

export interface HostAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType?: string;
    time?: string;
    weekDays: string[];
}

export interface HostAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author?: string;
    description?: string;
    engine?: string;
    lastModified?: number;
    name?: string;
    path?: string;
    readOnly?: boolean;
    scriptId?: string;
    severity?: string;
    snippet?: string;
}

export interface HostAssurancePolicyForbiddenLabel {
    key?: string;
    value?: string;
}

export interface HostAssurancePolicyPackagesBlackList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface HostAssurancePolicyPackagesWhiteList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface HostAssurancePolicyPolicySettings {
    enforce?: boolean;
    isAuditChecked?: boolean;
    warn?: boolean;
    warningMessage?: string;
}

export interface HostAssurancePolicyRequiredLabel {
    key?: string;
    value?: string;
}

export interface HostAssurancePolicyScope {
    expression: string;
    variables?: outputs.HostAssurancePolicyScopeVariable[];
}

export interface HostAssurancePolicyScopeVariable {
    attribute: string;
    name?: string;
    value: string;
}

export interface HostAssurancePolicyTrustedBaseImage {
    imagename?: string;
    registry?: string;
}

export interface HostRuntimePolicyAllowedExecutable {
    /**
     * List of allowed executables.
     */
    allowExecutables?: string[];
    /**
     * List of allowed root executables.
     */
    allowRootExecutables?: string[];
    /**
     * Whether allowed executables configuration is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to treat executables separately.
     */
    separateExecutables?: boolean;
}

export interface HostRuntimePolicyAllowedRegistry {
    /**
     * List of allowed registries.
     */
    allowedRegistries?: string[];
    /**
     * Whether allowed registries are enabled.
     */
    enabled?: boolean;
}

export interface HostRuntimePolicyAuditing {
    auditAllNetwork?: boolean;
    auditAllProcesses?: boolean;
    auditFailedLogin?: boolean;
    auditOsUserActivity?: boolean;
    auditProcessCmdline?: boolean;
    auditSuccessLogin?: boolean;
    auditUserAccountManagement?: boolean;
    enabled?: boolean;
}

export interface HostRuntimePolicyBlacklistedOsUsers {
    enabled?: boolean;
    groupBlackLists?: string[];
    userBlackLists?: string[];
}

export interface HostRuntimePolicyBypassScope {
    /**
     * Whether bypassing the scope is enabled.
     */
    enabled?: boolean;
    /**
     * Scope configuration.
     */
    scopes?: outputs.HostRuntimePolicyBypassScopeScope[];
}

export interface HostRuntimePolicyBypassScopeScope {
    /**
     * Scope expression.
     */
    expression?: string;
    /**
     * List of variables in the scope.
     */
    variables?: outputs.HostRuntimePolicyBypassScopeScopeVariable[];
}

export interface HostRuntimePolicyBypassScopeScopeVariable {
    /**
     * Variable attribute.
     */
    attribute?: string;
    /**
     * Variable value.
     */
    value?: string;
}

export interface HostRuntimePolicyContainerExec {
    blockContainerExec?: boolean;
    containerExecProcWhiteLists?: string[];
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
}

export interface HostRuntimePolicyDriftPrevention {
    /**
     * Whether drift prevention is enabled.
     */
    enabled?: boolean;
    /**
     * Whether to lockdown execution drift.
     */
    execLockdown?: boolean;
    /**
     * List of items in the execution lockdown white list.
     */
    execLockdownWhiteLists?: string[];
    /**
     * Whether to lockdown image drift.
     */
    imageLockdown?: boolean;
}

export interface HostRuntimePolicyExecutableBlacklist {
    /**
     * Whether the executable blacklist is enabled.
     */
    enabled?: boolean;
    /**
     * List of blacklisted executables.
     */
    executables?: string[];
}

export interface HostRuntimePolicyFailedKubernetesChecks {
    enabled?: boolean;
    failedChecks?: string[];
}

export interface HostRuntimePolicyFileBlock {
    blockFilesProcesses?: string[];
    blockFilesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockFiles?: string[];
    exceptionalBlockFilesProcesses?: string[];
    exceptionalBlockFilesUsers?: string[];
    filenameBlockLists?: string[];
}

export interface HostRuntimePolicyFileIntegrityMonitoring {
    /**
     * If true, file integrity monitoring is enabled.
     */
    enabled?: boolean;
    /**
     * List of paths to be excluded from monitoring.
     */
    exceptionalMonitoredFiles?: string[];
    /**
     * List of processes to be excluded from monitoring.
     */
    exceptionalMonitoredFilesProcesses?: string[];
    /**
     * List of users to be excluded from monitoring.
     */
    exceptionalMonitoredFilesUsers?: string[];
    /**
     * List of paths to be monitored.
     */
    monitoredFiles?: string[];
    /**
     * Whether to monitor file attribute operations.
     */
    monitoredFilesAttributes?: boolean;
    /**
     * Whether to monitor file create operations.
     */
    monitoredFilesCreate?: boolean;
    /**
     * Whether to monitor file delete operations.
     */
    monitoredFilesDelete?: boolean;
    /**
     * Whether to monitor file modify operations.
     */
    monitoredFilesModify?: boolean;
    /**
     * List of processes associated with monitored files.
     */
    monitoredFilesProcesses?: string[];
    /**
     * Whether to monitor file read operations.
     */
    monitoredFilesRead?: boolean;
    /**
     * List of users associated with monitored files.
     */
    monitoredFilesUsers?: string[];
}

export interface HostRuntimePolicyLimitContainerPrivilege {
    /**
     * Whether to block adding capabilities.
     */
    blockAddCapabilities?: boolean;
    /**
     * Whether container privilege limitations are enabled.
     */
    enabled?: boolean;
    /**
     * Whether to limit IPC-related capabilities.
     */
    ipcmode?: boolean;
    /**
     * Whether to limit network-related capabilities.
     */
    netmode?: boolean;
    /**
     * Whether to limit process-related capabilities.
     */
    pidmode?: boolean;
    /**
     * Whether to prevent low port binding.
     */
    preventLowPortBinding?: boolean;
    /**
     * Whether to prevent the use of the root user.
     */
    preventRootUser?: boolean;
    /**
     * Whether the container is run in privileged mode.
     */
    privileged?: boolean;
    /**
     * Whether to use the host user.
     */
    useHostUser?: boolean;
    /**
     * Whether to limit user-related capabilities.
     */
    usermode?: boolean;
    /**
     * Whether to limit UTS-related capabilities.
     */
    utsmode?: boolean;
}

export interface HostRuntimePolicyLinuxCapabilities {
    enabled?: boolean;
    removeLinuxCapabilities?: string[];
}

export interface HostRuntimePolicyMalwareScanOptions {
    /**
     * Set Action, Defaults to 'Alert' when empty
     */
    action?: string;
    /**
     * Defines if enabled or not
     */
    enabled?: boolean;
    /**
     * List of registry paths to be excluded from being protected.
     */
    excludeDirectories?: string[];
    /**
     * List of registry processes to be excluded from being protected.
     */
    excludeProcesses?: string[];
    /**
     * List of registry paths to be excluded from being protected.
     */
    includeDirectories?: string[];
}

export interface HostRuntimePolicyPackageBlock {
    blockPackagesProcesses?: string[];
    blockPackagesUsers?: string[];
    enabled?: boolean;
    exceptionalBlockPackagesFiles?: string[];
    exceptionalBlockPackagesProcesses?: string[];
    exceptionalBlockPackagesUsers?: string[];
    packagesBlackLists?: string[];
}

export interface HostRuntimePolicyPortBlock {
    blockInboundPorts?: string[];
    blockOutboundPorts?: string[];
    enabled?: boolean;
}

export interface HostRuntimePolicyReadonlyFiles {
    enabled?: boolean;
    exceptionalReadonlyFiles?: string[];
    exceptionalReadonlyFilesProcesses?: string[];
    exceptionalReadonlyFilesUsers?: string[];
    readonlyFiles?: string[];
    readonlyFilesProcesses?: string[];
    readonlyFilesUsers?: string[];
}

export interface HostRuntimePolicyReadonlyRegistry {
    enabled?: boolean;
    exceptionalReadonlyRegistryPaths?: string[];
    exceptionalReadonlyRegistryProcesses?: string[];
    exceptionalReadonlyRegistryUsers?: string[];
    readonlyRegistryPaths?: string[];
    readonlyRegistryProcesses?: string[];
    readonlyRegistryUsers?: string[];
}

export interface HostRuntimePolicyRegistryAccessMonitoring {
    enabled?: boolean;
    exceptionalMonitoredRegistryPaths?: string[];
    exceptionalMonitoredRegistryProcesses?: string[];
    exceptionalMonitoredRegistryUsers?: string[];
    monitoredRegistryAttributes?: boolean;
    monitoredRegistryCreate?: boolean;
    monitoredRegistryDelete?: boolean;
    monitoredRegistryModify?: boolean;
    monitoredRegistryPaths?: string[];
    monitoredRegistryProcesses?: string[];
    monitoredRegistryRead?: boolean;
    monitoredRegistryUsers?: string[];
}

export interface HostRuntimePolicyRestrictedVolume {
    /**
     * Whether restricted volumes are enabled.
     */
    enabled?: boolean;
    /**
     * List of restricted volumes.
     */
    volumes?: string[];
}

export interface HostRuntimePolicyReverseShell {
    blockReverseShell?: boolean;
    enabled?: boolean;
    reverseShellIpWhiteLists?: string[];
    reverseShellProcWhiteLists?: string[];
}

export interface HostRuntimePolicyScope {
    /**
     * Scope expression.
     */
    expression: string;
    /**
     * List of variables in the scope.
     */
    variables: outputs.HostRuntimePolicyScopeVariable[];
}

export interface HostRuntimePolicyScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute: string;
    /**
     * Name assigned to the attribute.
     */
    name?: string;
    /**
     * Value assigned to the attribute.
     */
    value: string;
}

export interface HostRuntimePolicySystemIntegrityProtection {
    auditSystemtimeChange?: boolean;
    enabled?: boolean;
    monitorAuditLogIntegrity?: boolean;
    windowsServicesMonitoring?: boolean;
}

export interface HostRuntimePolicyTripwire {
    applyOns?: string[];
    enabled?: boolean;
    serverlessApp?: string;
    userId?: string;
    userPassword?: string;
}

export interface HostRuntimePolicyWhitelistedOsUsers {
    enabled?: boolean;
    groupWhiteLists?: string[];
    userWhiteLists?: string[];
}

export interface ImageAssuranceChecksPerformed {
    /**
     * The type of the Assurance Policy the check originated from.
     */
    assuranceType: string;
    /**
     * Whether the check is blocking (i.e. a failure should trigger a disallow).
     */
    blocking: boolean;
    /**
     * The name of the image assurance control.
     */
    control: string;
    /**
     * If DTA was skipped.
     */
    dtaSkipped: boolean;
    /**
     * The reason why DTA was skipped.
     */
    dtaSkippedReason: string;
    /**
     * Whether the image failed the check.
     */
    failed: boolean;
    /**
     * The name of the Image Assurance Policy the check originated from.
     */
    policyName: string;
}

export interface ImageAssurancePolicyAutoScanTime {
    iteration?: number;
    iterationType?: string;
    time?: string;
    weekDays?: string[];
}

export interface ImageAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author?: string;
    description?: string;
    engine?: string;
    lastModified?: number;
    name?: string;
    path?: string;
    readOnly?: boolean;
    scriptId?: string;
    severity?: string;
    snippet?: string;
}

export interface ImageAssurancePolicyForbiddenLabel {
    key?: string;
    value?: string;
}

export interface ImageAssurancePolicyKubernetesControls {
    avdId?: string;
    description?: string;
    enabled?: boolean;
    kind?: string;
    name?: string;
    ootb?: boolean;
    scriptId?: number;
    severity?: string;
}

export interface ImageAssurancePolicyPackagesBlackList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface ImageAssurancePolicyPackagesWhiteList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface ImageAssurancePolicyPolicySettings {
    enforce?: boolean;
    isAuditChecked?: boolean;
    warn?: boolean;
    warningMessage?: string;
}

export interface ImageAssurancePolicyRequiredLabel {
    key?: string;
    value?: string;
}

export interface ImageAssurancePolicyScope {
    expression: string;
    variables?: outputs.ImageAssurancePolicyScopeVariable[];
}

export interface ImageAssurancePolicyScopeVariable {
    attribute: string;
    name?: string;
    value: string;
}

export interface ImageAssurancePolicyTrustedBaseImage {
    imagename?: string;
    registry?: string;
}

export interface ImageHistory {
    /**
     * The commit comment for the image, if any.
     */
    comment: string;
    /**
     * The date of creation of the layer.
     */
    created: string;
    /**
     * The command that generated the layer.
     */
    createdBy: string;
    /**
     * The image ID of the layer (if any).
     */
    id: string;
    /**
     * The size of the image.
     */
    size: number;
}

export interface ImageVulnerability {
    ackAuthor: string;
    ackComment: string;
    ackExpirationConfiguredAt: string;
    ackExpirationConfiguredBy: string;
    ackExpirationDays: number;
    ackScope: string;
    acknowledgeDate: string;
    /**
     * The ancestor of this package.
     */
    ancestorPkg: string;
    /**
     * The score generated for the vulnerability by Aqua.
     */
    aquaScore: number;
    /**
     * Score classification by Aqua.
     */
    aquaScoreClassification: string;
    /**
     * The score system for the vulnerability by Aqua
     */
    aquaScoringSystem: string;
    /**
     * The severity generated for the vulnerability by Aqua.
     */
    aquaSeverity: string;
    /**
     * Classification of the severity defined by Aqua.
     */
    aquaSeverityClassification: string;
    /**
     * The vectors generated for the vulnerability by Aqua
     */
    aquaVectors: string;
    /**
     * Number of audit events.
     */
    auditEventsCount: number;
    /**
     * Number of blocked events.
     */
    blockEventsCount: number;
    /**
     * Classification of the vulnerability.
     */
    classification: string;
    /**
     * The description of the vulnerability.
     */
    description: string;
    /**
     * The content digest of the image.
     */
    digest: string;
    /**
     * Reference of the exploit.
     */
    exploitReference: string;
    /**
     * Type of the exploit.
     */
    exploitType: string;
    /**
     * The date when this vulnerability was first found.
     */
    firstFoundDate: string;
    /**
     * Fixed version of the resource.
     */
    fixVersion: string;
    /**
     * Name of the image.
     */
    imageName: string;
    /**
     * The date when this vulnerability was last found.
     */
    lastFoundDate: string;
    /**
     * Thhe date when this vulnerability was modified.
     */
    modificationDate: string;
    /**
     * The name of the vulnerability.
     */
    name: string;
    /**
     * CVSS2 score by NVD
     */
    nvdCvss2Score: number;
    /**
     * CVSS2 vectors by NVD
     */
    nvdCvss2Vectors: string;
    /**
     * CVSS3 score by NVD
     */
    nvdCvss3Score: number;
    /**
     * CVSS3 severity by NVD
     */
    nvdCvss3Severity: string;
    /**
     * CVSS3 vectors by NVD
     */
    nvdCvss3Vectors: string;
    /**
     * Type of the severity identified by NVD.
     */
    nvdSeverity: string;
    /**
     * URL of the details of this vulnerability by NVD.
     */
    nvdUrl: string;
    /**
     * Name of the Operating System.
     */
    os: string;
    /**
     * The version of the OS.
     */
    osVersion: string;
    /**
     * permission on the image
     */
    permission: string;
    /**
     * The date this vulnerability was published.
     */
    publishDate: string;
    /**
     * Registry of the image.
     */
    registry: string;
    /**
     * Repository of the image.
     */
    repository: string;
    /**
     * Architecture of the resource.
     */
    resourceArchitecture: string;
    /**
     * Common Platform Enumeration (CPE) of the resource.
     */
    resourceCpe: string;
    /**
     * Code format of the resource (java, apk etc.).
     */
    resourceFormat: string;
    /**
     * Hash of the resource.
     */
    resourceHash: string;
    /**
     * List of license supported by the resource.
     */
    resourceLicenses: string[];
    /**
     * Name of the resource.
     */
    resourceName: string;
    /**
     * Path of the resource.
     */
    resourcePath: string;
    /**
     * Type of the resource
     */
    resourceType: string;
    /**
     * Version of the resource.
     */
    resourceVersion: string;
    /**
     * Classification of the severity.
     */
    severityClassification: string;
    /**
     * Solution for the vulnerability.
     */
    solution: string;
    temporalVector: string;
    vPatchAppliedBy: string;
    vPatchAppliedOn: string;
    vPatchEnforcedBy: string;
    vPatchEnforcedOn: string;
    vPatchPolicyEnforce: boolean;
    vPatchPolicyName: string;
    vPatchRevertedBy: string;
    vPatchRevertedOn: string;
    vPatchStatus: string;
    vendorCvss2Score: number;
    vendorCvss2Vectors: string;
    vendorSeverity: string;
    vendorStatement: string;
    vendorUrl: string;
}

export interface IntegrationRegistryOption {
    option?: string;
    value?: string;
}

export interface IntegrationRegistryWebhook {
    authToken?: string;
    enabled: boolean;
    unQuarantine: boolean;
    url?: string;
}

export interface KubernetesAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType?: string;
    time?: string;
    weekDays: string[];
}

export interface KubernetesAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author?: string;
    description?: string;
    engine?: string;
    lastModified?: number;
    name?: string;
    path?: string;
    readOnly?: boolean;
    scriptId?: string;
    severity?: string;
    snippet?: string;
}

export interface KubernetesAssurancePolicyForbiddenLabel {
    key?: string;
    value?: string;
}

export interface KubernetesAssurancePolicyKubernetesControl {
    /**
     * AVD ID.
     */
    avdId?: string;
    /**
     * Description of the control.
     */
    description?: string;
    /**
     * Is the control enabled?
     */
    enabled?: boolean;
    /**
     * Kind of the control.
     */
    kind?: string;
    /**
     * Name of the control.
     */
    name?: string;
    /**
     * Out-of-the-box status of the control.
     */
    ootb?: boolean;
    /**
     * Script ID.
     */
    scriptId?: number;
    /**
     * Severity of the control.
     */
    severity?: string;
}

export interface KubernetesAssurancePolicyPackagesBlackList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface KubernetesAssurancePolicyPackagesWhiteList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface KubernetesAssurancePolicyPolicySettings {
    enforce?: boolean;
    isAuditChecked?: boolean;
    warn?: boolean;
    warningMessage?: string;
}

export interface KubernetesAssurancePolicyRequiredLabel {
    key?: string;
    value?: string;
}

export interface KubernetesAssurancePolicyScope {
    expression: string;
    variables?: outputs.KubernetesAssurancePolicyScopeVariable[];
}

export interface KubernetesAssurancePolicyScopeVariable {
    attribute: string;
    name?: string;
    value: string;
}

export interface KubernetesAssurancePolicyTrustedBaseImage {
    imagename?: string;
    registry?: string;
}

export interface RoleMappingLdap {
    /**
     * Role Mapping is used to define the IdP role that the user will assume in Aqua. Use '|' as a separator for multiple roles.
     */
    roleMapping: {[key: string]: string};
}

export interface RoleMappingOauth2 {
    /**
     * Role Mapping is used to define the IdP role that the user will assume in Aqua. Use '|' as a separator for multiple roles.
     */
    roleMapping: {[key: string]: string};
}

export interface RoleMappingOpenid {
    /**
     * Role Mapping is used to define the IdP role that the user will assume in Aqua. Use '|' as a separator for multiple roles.
     */
    roleMapping: {[key: string]: string};
}

export interface RoleMappingSaml {
    /**
     * Role Mapping is used to define the IdP role that the user will assume in Aqua. Use '|' as a separator for multiple roles.
     */
    roleMapping: {[key: string]: string};
}

export interface ServiceScopeVariable {
    /**
     * Class of supported scope.
     */
    attribute?: string;
    /**
     * Name assigned to the attribute.
     */
    name?: string;
    /**
     * Value assigned to the attribute.
     */
    value?: string;
}

export interface UserSaasGroup {
    groupAdmin?: boolean;
    name?: string;
}

export interface UserSaasLogin {
    created: string;
    id: number;
    ipAddress: string;
    userId: number;
}

export interface VmwareAssurancePolicyAutoScanTime {
    iteration: number;
    iterationType?: string;
    time?: string;
    weekDays: string[];
}

export interface VmwareAssurancePolicyCustomCheck {
    /**
     * Name of user account that created the policy.
     */
    author?: string;
    description?: string;
    engine?: string;
    lastModified?: number;
    name?: string;
    path?: string;
    readOnly?: boolean;
    scriptId?: string;
    severity?: string;
    snippet?: string;
}

export interface VmwareAssurancePolicyForbiddenLabel {
    key?: string;
    value?: string;
}

export interface VmwareAssurancePolicyKubernetesControl {
    avdId?: string;
    description?: string;
    enabled?: boolean;
    kind?: string;
    name?: string;
    ootb?: boolean;
    scriptId?: number;
    severity?: string;
}

export interface VmwareAssurancePolicyPackagesBlackList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface VmwareAssurancePolicyPackagesWhiteList {
    arch?: string;
    display?: string;
    epoch?: string;
    format?: string;
    license?: string;
    name?: string;
    release?: string;
    version?: string;
    versionRange?: string;
}

export interface VmwareAssurancePolicyPolicySettings {
    enforce?: boolean;
    isAuditChecked?: boolean;
    warn?: boolean;
    warningMessage?: string;
}

export interface VmwareAssurancePolicyRequiredLabel {
    key?: string;
    value?: string;
}

export interface VmwareAssurancePolicyScope {
    expression: string;
    variables?: outputs.VmwareAssurancePolicyScopeVariable[];
}

export interface VmwareAssurancePolicyScopeVariable {
    attribute: string;
    name?: string;
    value: string;
}

export interface VmwareAssurancePolicyTrustedBaseImage {
    imagename?: string;
    registry?: string;
}

